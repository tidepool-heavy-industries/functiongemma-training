{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I send  as a response?\nSymbol: parseSelectionResponse\nModule: Tidepool.Control.Scout.Teach.Gemma\nPackage: tidepool-control-server\nSignature: parseSelectionResponse :: ByteString -> Either Text [Text] Parse Ollama response for symbol selection (array format).\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Parse, Ollama\n  References: Gemma.hs:243, Gemma.hs:287, Gemma.hs:288\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Parse,Ollama<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I retrieve the graph entry point value?\nSymbol: getEntry\nModule: Tidepool.Effect.GraphContext\nPackage: tidepool-core\nSignature: getEntry :: forall entry (effs :: [Type -> Type]). Member (GraphContext entry) effs => Eff effs entry Read the entry value that spawned this graph. Usage requires type application to specify the entry type: entry <- getEntry @ScaffoldInput let depth = entry.siCurrentDepth This value is constant for the lifetime of the graph instance. In recursive execution, each child sees its own entry.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Read, Usage, This, In\n  References: GraphContext.hs:52, GraphContext.hs:101, GraphContext.hs:105\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Usage<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Type and TeachGemma into Mock or Simply or Useful?\nSymbol: runTeachGemmaMock\nModule: Tidepool.Control.Scout.Teach.Gemma\nPackage: tidepool-control-server\nSignature: runTeachGemmaMock :: forall (effs :: [Type -> Type]) a. Eff (TeachGemma : effs) a -> Eff effs a Mock interpreter for testing. Simply returns all candidates (no filtering). Useful for testing the exploration loop without Gemma dependency.\n\nCandidates:\n  Fields: (none)\n  Inputs: Type, TeachGemma\n  Output: Mock, Simply, Useful, Gemma\n  References: Gemma.hs:39, Gemma.hs:371, Gemma.hs:372\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I fetch the current Habitica user profile?\nSymbol: getUser\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: getUser :: forall (effs :: [Type -> Type]). Member Habitica effs => Eff effs UserInfo\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: UserInfo\n  References: Habitica.hs:11, Habitica.hs:96, Habitica.hs:97\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>UserInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming MemoryStore into Nothing' or Left or Type?\nSymbol: getScope\nModule: Tidepool.Graph.Memory\nPackage: tidepool-core\nSignature: getScope :: forall s. FromJSON s => Text -> MemoryStore -> Either Text (Maybe s) Get a scope from the store, deserializing to the expected type. Returns 'Right Nothing' if the scope doesn't exist. Returns `Left` error if deserialization fails (type mismatch). Type safety is enforced by the `FromJSON` constraint - if the stored JSON doesn't match the expected type, parsing will fail with an error.\n\nCandidates:\n  Fields: (none)\n  Inputs: MemoryStore\n  Output: Get, Returns, Nothing', Left, Type, FromJSON, JSON\n  References: Memory.hs:89, Memory.hs:279, Memory.hs:364, Memory.hs:394, Memory.hs:399, Memory.hs:410, Memory.hs:428, Memory.hs:444\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming GetRecentCommits into Git?\nSymbol: GetRecentCommits\nModule: Tidepool.Effects.Git\nPackage: tidepool-core\nSignature: GetRecentCommits :: Int %1 -> Git [Text] Get recent commit subjects.\n\nCandidates:\n  Fields: (none)\n  Inputs: GetRecentCommits\n  Output: Git, Get\n  References: Git.hs:90, Git.hs:110\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if workers don't need synchronization?\nSymbol: GetWorkerArriveBarrier\nModule: Tidepool.Graph.Validate.ForkBarrier\nPackage: tidepool-core\nSignature: GetWorkerArriveBarrier\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetWorkerArriveBarrier\n  References: ForkBarrier.hs:48, ForkBarrier.hs:217, ForkBarrier.hs:220, ForkBarrier.hs:221, ForkBarrier.hs:222\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming HandlerBuilder and Value into Each or Messages or Node?\nSymbol: runGraphAsActors\nModule: Tidepool.Actor.Graph\nPackage: tidepool-actor\nSignature: runGraphAsActors :: forall result. FromJSON result => Map Text HandlerBuilder -> Value -> IO result Run a graph as an actor system. Each entry in the handler map becomes one actor. Each handler builder is run once when its actor spawns, allowing per-actor state initialization. Messages flow between actors via the router. The system terminates when a handler routes to \"exit\", returning the exit payload. # Node Names + `\"entry\"` - Entry point (receives initial input) + `\"exit\"` - Exit handler (returns result) + Other names map directly to graph node names # Example handlers :: Map Text HandlerBuilder handlers = Map.fromList [ (\"entry\", pureHandler entryHandler) , (\"processor\", effHandlerWithMem 0 processorHandler) -- has its own Int memory , (\"logger\", effHandlerWithMem [] logHandler) -- has its own [Text] memory ] result <- runGraphAsActors handlers (toJSON (Message \"hello\"))\n\nCandidates:\n  Fields: (none)\n  Inputs: HandlerBuilder, Value\n  Output: Run, Each, Messages, The, Node, Names, Entry, Exit, Other, Example, HandlerBuilder, Map.fromList, Message\n  References: Graph.hs:36, Graph.hs:296, Graph.hs:302, Graph.hs:450, Graph.hs:451\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform CabalTestFailure and TestFailure into CabalResult?\nSymbol: CabalTestFailure\nModule: Tidepool.Effects.Cabal\nPackage: tidepool-core\nSignature: CabalTestFailure :: [TestFailure] %1 -> Text %1 -> CabalResult\n\nCandidates:\n  Fields: (none)\n  Inputs: CabalTestFailure, TestFailure\n  Output: CabalResult\n  References: Cabal.hs:115, Cabal.hs:116, Cabal.hs:118, Cabal.hs:151\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>CabalTestFailure,TestFailure,CabalResult<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Type into Alias or State?\nSymbol: runMemoryPure\nModule: Tidepool.Graph.Memory\nPackage: tidepool-core\nSignature: runMemoryPure :: forall s (effs :: [Type -> Type]) a. s -> Eff (Memory s : effs) a -> Eff effs a Run memory effect with pure initial value, discarding final state. Alias for `evalMemory` for symmetry with State naming conventions.\n\nCandidates:\n  Fields: (none)\n  Inputs: Type\n  Output: Run, Alias, State\n  References: Memory.hs:77, Memory.hs:218, Memory.hs:219\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Type,Alias<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform SymbolInformation and WorkspaceSymbol and Null into SymbolInformation?\nSymbol: fromSymbolsResult\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromSymbolsResult :: ([SymbolInformation] |? ([WorkspaceSymbol] |? Null)) -> [SymbolInformation]\n\nCandidates:\n  Fields: (none)\n  Inputs: SymbolInformation, WorkspaceSymbol, Null\n  Output: SymbolInformation\n  References: Interpreter.hs:250, Interpreter.hs:446, Interpreter.hs:447\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>SymbolInformation,WorkspaceSymbol<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform CodeAction into CodeAction?\nSymbol: fromCodeAction\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromCodeAction :: CodeAction -> CodeAction\n\nCandidates:\n  Fields: (none)\n  Inputs: CodeAction\n  Output: CodeAction\n  References: Interpreter.hs:358, Interpreter.hs:360, Interpreter.hs:361\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>CodeAction<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if templates don't use includes?\nSymbol: parseTemplateIncludes\nModule: Tidepool.Template.DependencyTree\nPackage: tidepool-core\nSignature: parseTemplateIncludes :: Text -> [FilePath] Parse a template for {% include \"...\" %} directives. Returns a list of included template paths. parseTemplateIncludes \"{% include \"_shared/context.jinja\" %}\" == [\"_shared/context.jinja\"]\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: FilePath, Parse, Returns\n  References: DependencyTree.hs:32, DependencyTree.hs:209, DependencyTree.hs:210, DependencyTree.hs:229\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Value into MemorySnapshot?\nSymbol: mkMemorySnapshot\nModule: Tidepool.Graph.Memory\nPackage: tidepool-core\nSignature: mkMemorySnapshot :: Map Text Value -> MemorySnapshot Create a `MemorySnapshot` with the current version. This smart constructor ensures snapshots are always created with the correct version number, preventing invalid version states. let snapshot = mkMemorySnapshot myScopes\n\nCandidates:\n  Fields: (none)\n  Inputs: Value\n  Output: MemorySnapshot, Create, This\n  References: Memory.hs:84, Memory.hs:295, Memory.hs:313, Memory.hs:314\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I extract tool metadata as ToolInfo?\nSymbol: toolToInfo\nModule: Tidepool.Graph.Tool\nPackage: tidepool-core\nSignature: toolToInfo :: forall t. ToolDef t => t -> ToolInfo\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: ToolInfo\n  References: Tool.hs:73, Tool.hs:249, Tool.hs:250, Graph.hs:208\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>ToolInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to AsHandler?\nSymbol: runGraphFrom\nModule: Tidepool.Graph.Interpret\nPackage: tidepool-core\nSignature: runGraphFrom :: forall (name :: Symbol) (graph :: Type -> Type) entryType (targets :: [Type]) exitType (es :: [Effect]) handler. (KnownSymbol name, HasField name (graph (AsHandler es)) handler, CallHandler handler entryType es targets, DispatchGoto graph targets es exitType) => graph (AsHandler es) -> entryType -> Eff es exitType\n\nCandidates:\n  Fields: (none)\n  Inputs: AsHandler\n  Output: (none)\n  References: Interpret.hs:32, Interpret.hs:153, Interpret.hs:163, Interpret.hs:198, Interpret.hs:203\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if conversation history is not needed?\nSymbol: GetHistory\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: GetHistory :: ChatHistory [Message]\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetHistory, ChatHistory, Message\n  References: Types.hs:512, Types.hs:517, Types.hs:532\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When is batch conversion overkill?\nSymbol: toolDefsToCf\nModule: Tidepool.Tool.Convert\nPackage: tidepool-core\nSignature: toolDefsToCf :: forall (f :: Type -> Type) t. (Functor f, ToCfTool t) => f t -> f CfTool Convert a collection of tools to CloudFlare AI format. tools :: [MyTool] cfTools :: [CfTool] cfTools = toolDefsToCf tools\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: CfTool, Convert, CloudFlare, AI, MyTool\n  References: Convert.hs:54, Convert.hs:148, Convert.hs:149\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When is effect metadata not needed?\nSymbol: allEffectMeta\nModule: Tidepool.Effect.Metadata\nPackage: tidepool-core\nSignature: allEffectMeta :: [EffectMeta]\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: EffectMeta\n  References: Metadata.hs:15, Metadata.hs:25, Metadata.hs:93, Metadata.hs:94\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I serialize a tool for Cloudflare?\nSymbol: toCfTool\nModule: Tidepool.Tool.Convert\nPackage: tidepool-core\nSignature: toCfTool :: forall t. ToCfTool t => t -> CfTool\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: CfTool\n  References: Convert.hs:118, Convert.hs:120, Convert.hs:121, Convert.hs:149\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>CfTool<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Type into NodeInput or Each?\nSymbol: runNodeInput\nModule: Tidepool.Effect.GraphContext\nPackage: tidepool-core\nSignature: runNodeInput :: forall input (effs :: [Type -> Type]) a. input -> Eff (NodeInput input : effs) a -> Eff effs a Run NodeInput effect with a fixed input value. Typically provided by the dispatcher when calling a handler. Each node invocation wraps the handler in `runNodeInput` . -- In dispatcher runNodeInput implInput $ do (exit, sid) <- runLLMNode ... implAfter (exit, sid) -- can now call getNodeInput\n\nCandidates:\n  Fields: (none)\n  Inputs: Type\n  Output: Run, NodeInput, Typically, Each, In\n  References: GraphContext.hs:60, GraphContext.hs:201, GraphContext.hs:205\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Type,NodeInput<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform AsHandler into Run?\nSymbol: runGraphFrom\nModule: Tidepool.Graph.Interpret\nPackage: tidepool-core\nSignature: runGraphFrom :: forall (name :: Symbol) (graph :: Type -> Type) entryType (targets :: [Type]) exitType (es :: [Effect]) handler. (KnownSymbol name, HasField name (graph (AsHandler es)) handler, CallHandler handler entryType es targets, DispatchGoto graph targets es exitType) => graph (AsHandler es) -> entryType -> Eff es exitType Run a graph starting from a named handler. Use this when you want to explicitly specify which handler to start from, bypassing automatic entry handler discovery. result <- runGraphFrom @\"compute\" handlers inputValue\n\nCandidates:\n  Fields: (none)\n  Inputs: AsHandler\n  Output: Run, Use\n  References: Interpret.hs:32, Interpret.hs:153, Interpret.hs:163, Interpret.hs:198, Interpret.hs:203\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>AsHandler,Use<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I access the entry value passed to this graph?\nSymbol: GetEntry\nModule: Tidepool.Effect.GraphContext\nPackage: tidepool-core\nSignature: GetEntry :: forall {k} (entry :: k). GraphContext entry entry Get the entry value that spawned this graph.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetEntry, GraphContext, Get\n  References: GraphContext.hs:87, GraphContext.hs:105, GraphContext.hs:187\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetEntry,GraphContext<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming TaskType into HabiticaTask?\nSymbol: getTasks\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: getTasks :: forall (effs :: [Type -> Type]). Member Habitica effs => TaskType -> Eff effs [HabiticaTask]\n\nCandidates:\n  Fields: (none)\n  Inputs: TaskType\n  Output: HabiticaTask\n  References: Habitica.hs:13, Habitica.hs:102, Habitica.hs:103\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I send control responses back to connected clients?\nSymbol: sendResponse\nModule: Tidepool.Control.Server\nPackage: tidepool-control-server\nSignature: sendResponse :: Socket -> ControlResponse -> IO ()\n\nCandidates:\n  Fields: (none)\n  Inputs: Socket, ControlResponse\n  Output: (none)\n  References: Server.hs:120, Server.hs:126, Server.hs:131, Server.hs:148, Server.hs:149\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Socket,ControlResponse<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming GetFieldInput and Symbol and Type and Symbol into Type or Input?\nSymbol: GetFieldInput\nModule: Tidepool.Graph.Validate.RecordStructure\nPackage: tidepool-core\nSignature: GetFieldInput :: [(Symbol, Type)] -> Symbol -> Maybe Type Get Input type for a field by name.\n\nCandidates:\n  Fields: (none)\n  Inputs: GetFieldInput, Symbol, Type, Symbol\n  Output: Type, Get, Input\n  References: RecordStructure.hs:460, RecordStructure.hs:464, RecordStructure.hs:465, RecordStructure.hs:466, RecordStructure.hs:467, RecordStructure.hs:470\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I initialize an empty TeachingDoc?\nSymbol: emptyDoc\nModule: Tidepool.Control.Scout.Teach\nPackage: tidepool-control-server\nSignature: emptyDoc :: TeachQuery -> TeachingDoc\n\nCandidates:\n  Fields: (none)\n  Inputs: TeachQuery\n  Output: TeachingDoc\n  References: Teach.hs:119, Teach.hs:393, Teach.hs:394\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>TeachQuery,TeachingDoc<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I batch convert tool definitions to Anthropic format?\nSymbol: toolDefsToAnthropic\nModule: Tidepool.Tool.Convert\nPackage: tidepool-core\nSignature: toolDefsToAnthropic :: forall (f :: Type -> Type) t. (Functor f, ToAnthropicTool t) => f t -> f AnthropicTool\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: AnthropicTool\n  References: Convert.hs:53, Convert.hs:138, Convert.hs:139\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>AnthropicTool<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming LSPSymbol into Format or TODO or Replace?\nSymbol: formatSelectionPrompt\nModule: Tidepool.Control.Scout.Teach.Gemma\nPackage: tidepool-control-server\nSignature: formatSelectionPrompt :: Text -> LSPSymbol -> [Text] -> Text Format the selection prompt. TODO: Replace with proper FunctionGemma token format once training data is ready. For now, training data format in training-generator/Format.hs is the source of truth.\n\nCandidates:\n  Fields: (none)\n  Inputs: LSPSymbol\n  Output: Format, TODO, Replace, FunctionGemma, For\n  References: Gemma.hs:219, Gemma.hs:254, Gemma.hs:255\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Parser into CLI or Combines or Input?\nSymbol: runGraphCLIWith\nModule: Tidepool.Graph.CLI\nPackage: tidepool-core\nSignature: runGraphCLIWith :: forall output input. (Show output, ToJSON output) => Text -> Parser input -> (input -> IO output) -> IO () Run a graph as a CLI application. Combines: + Input parser (from `deriveCLIParser` ) + `--format` flag for output formatting + `--help` with description main :: IO () main = runGraphCLIWith \"Process files with my graph\" $(deriveCLIParser ''MyInput) runMyGraph\n\nCandidates:\n  Fields: (none)\n  Inputs: Parser\n  Output: Run, CLI, Combines, Input\n  References: CLI.hs:74, CLI.hs:474, CLI.hs:480, CLI.hs:529\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Parser into CLI or Combines or Input?\nSymbol: runGraphCLIWith\nModule: Tidepool.Graph.CLI\nPackage: tidepool-core\nSignature: runGraphCLIWith :: forall output input. (Show output, ToJSON output) => Text -> Parser input -> (input -> IO output) -> IO () Run a graph as a CLI application. Combines: + Input parser (from `deriveCLIParser` ) + `--format` flag for output formatting + `--help` with description main :: IO () main = runGraphCLIWith \"Process files with my graph\" $(deriveCLIParser ''MyInput) runMyGraph\n\nCandidates:\n  Fields: (none)\n  Inputs: Parser\n  Output: Run, CLI, Combines, Input\n  References: CLI.hs:74, CLI.hs:474, CLI.hs:480, CLI.hs:529\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Parser,CLI<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming GetTasks and TaskType into Habitica or HabiticaTask?\nSymbol: GetTasks\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: GetTasks :: TaskType %1 -> Habitica [HabiticaTask]\n\nCandidates:\n  Fields: (none)\n  Inputs: GetTasks, TaskType\n  Output: Habitica, HabiticaTask\n  References: Habitica.hs:72, Habitica.hs:103, Habitica.hs:151\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform CompleteTry and LLMProvider. and SProvider and LLMProviderConfig and Value into LLMComplete or LLMError or LLMProviderResponse?\nSymbol: CompleteTry\nModule: Tidepool.Effects.LLMProvider\nPackage: tidepool-core\nSignature: CompleteTry :: forall (p :: LLMProvider). SProvider p %1 -> LLMProviderConfig p %1 -> Text %1 -> Maybe [Value] %1 -> LLMComplete (Either LLMError (LLMProviderResponse p))\n\nCandidates:\n  Fields: (none)\n  Inputs: CompleteTry, LLMProvider., SProvider, LLMProviderConfig, Value\n  Output: LLMComplete, LLMError, LLMProviderResponse\n  References: LLMProvider.hs:300, LLMProvider.hs:320, LLMProvider.hs:364, Interpreter.hs:255, Interpreter.hs:291, Interpreter.hs:294\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>CompleteTry,LLMProvider.,LLMComplete,LLMError<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform AsHandler into GraphNode?\nSymbol: executeGraphNode\nModule: Tidepool.Graph.Interpret\nPackage: tidepool-core\nSignature: executeGraphNode :: forall (childGraph :: Type -> Type) (es :: [Effect]) entryType (targets :: [Type]) exitType (entryHandlerName :: Symbol) handler. (Generic (childGraph AsGraph), FindEntryHandler entryType (FieldsWithNamesOf childGraph) ~ 'Just entryHandlerName, KnownSymbol entryHandlerName, HasField entryHandlerName (childGraph (AsHandler es)) handler, CallHandler handler entryType es targets, DispatchGoto childGraph targets es exitType) => childGraph (AsHandler es) -> entryType -> Eff es exitType Execute a GraphNode by running the child graph to completion. The child graph's handlers must be provided. The input is passed to the child graph's EntryNode, and execution continues until Exit is reached. This function is a thin wrapper around `runGraph` that documents the GraphNode execution pattern. Use it in parent graph handlers when manually delegating to child graphs. -- In a parent graph handler: childResult <- executeGraphNode childHandlers input pure $ gotoChoice @\"nextNode\" childResult\n\nCandidates:\n  Fields: (none)\n  Inputs: AsHandler\n  Output: Execute, GraphNode, The, EntryNode, Exit, This, Use, In\n  References: Interpret.hs:574, Interpret.hs:586\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>AsHandler,GraphNode<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Value into ParseDiagnostic?\nSymbol: expectedArray\nModule: Tidepool.StructuredOutput.Error\nPackage: tidepool-core\nSignature: expectedArray :: [Text] -> Value -> ParseDiagnostic Error for when an array was expected.\n\nCandidates:\n  Fields: (none)\n  Inputs: Value\n  Output: ParseDiagnostic, Error\n  References: Error.hs:14, Error.hs:49, Error.hs:50, Instances.hs:45, Instances.hs:128, Instances.hs:136, Instances.hs:166\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I find uncommitted files in the working directory?\nSymbol: GetDirtyFiles\nModule: Tidepool.Effects.Git\nPackage: tidepool-core\nSignature: GetDirtyFiles :: Git [FilePath] Get list of dirty (uncommitted) files.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetDirtyFiles, Git, FilePath, Get\n  References: Git.hs:87, Git.hs:106\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetDirtyFiles,Git<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if my data structure is not array-based?\nSymbol: arraySchema\nModule: Tidepool.Schema\nPackage: tidepool-core\nSignature: arraySchema :: JSONSchema -> JSONSchema Array schema combinator\n\nCandidates:\n  Fields: (none)\n  Inputs: JSONSchema\n  Output: JSONSchema\n  References: Schema.hs:18, Schema.hs:88, Schema.hs:89, Schema.hs:205, Instances.hs:30, Instances.hs:112, Instances.hs:132, Instances.hs:140, Instances.hs:154, Types.hs:60, Types.hs:186, Types.hs:48, Types.hs:210\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming CreateTodoTry into Habitica or HabiticaError or TodoId?\nSymbol: CreateTodoTry\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: CreateTodoTry :: Text %1 -> Habitica (Either HabiticaError TodoId)\n\nCandidates:\n  Fields: (none)\n  Inputs: CreateTodoTry\n  Output: Habitica, HabiticaError, TodoId\n  References: Habitica.hs:77, Habitica.hs:117, Habitica.hs:162\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Read and Usage and In and True and False and FailureResult and This and Memory and OLD into NEW or Direct or NodeInput?\nSymbol: getNodeInput\nModule: Tidepool.Effect.GraphContext\nPackage: tidepool-core\nSignature: getNodeInput :: forall input (effs :: [Type -> Type]). Member (NodeInput input) effs => Eff effs input Read the current node's input value. Usage requires type application to specify the input type: -- In implAfter originalInput <- getNodeInput @ImplInput case originalInput.iiAttemptCount < 5 of True -> pure $ gotoSelf originalInput { iiAttemptCount = originalInput.iiAttemptCount + 1 } False -> pure $ gotoExit FailureResult This replaces the pattern of storing input in Memory: -- OLD: Memory round-trip implBefore input = do updateMem @ImplMem $ \\m -> m { imOriginalInput = Just input } ... implAfter (exit, sid) = do mem <- getMem @ImplMem let originalInput = fromMaybe (error \"impossible\") mem.imOriginalInput ... -- NEW: Direct via NodeInput implAfter (exit, sid) = do originalInput <- getNodeInput @ImplInput ...\n\nCandidates:\n  Fields: (none)\n  Inputs: Read, Usage, In, True, False, FailureResult, This, Memory, OLD\n  Output: Just, NEW, Direct, NodeInput\n  References: GraphContext.hs:56, GraphContext.hs:161, GraphContext.hs:165\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with TemplateDependency and Render and Output?\nSymbol: renderDepTreeCompact\nModule: Tidepool.Graph.Docs\nPackage: tidepool-core\nSignature: renderDepTreeCompact :: TemplateDependency -> Text Render a compact single-line representation. Output example: `main.jinja -> header.jinja, footer.jinja`\n\nCandidates:\n  Fields: (none)\n  Inputs: TemplateDependency, Render, Output\n  Output: (none)\n  References: Docs.hs:37, Docs.hs:105, Docs.hs:106, Graph.hs:125\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>TemplateDependency<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Value into MemorySnapshot?\nSymbol: mkMemorySnapshot\nModule: Tidepool.Graph.Memory\nPackage: tidepool-core\nSignature: mkMemorySnapshot :: Map Text Value -> MemorySnapshot Create a `MemorySnapshot` with the current version. This smart constructor ensures snapshots are always created with the correct version number, preventing invalid version states. let snapshot = mkMemorySnapshot myScopes\n\nCandidates:\n  Fields: (none)\n  Inputs: Value\n  Output: MemorySnapshot, Create, This\n  References: Memory.hs:84, Memory.hs:295, Memory.hs:313, Memory.hs:314\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Value,MemorySnapshot<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to IORef?\nSymbol: runMemoryWithIORef\nModule: Tidepool.Actor.Graph\nPackage: tidepool-actor\nSignature: runMemoryWithIORef :: forall s (effs :: [Type -> Type]) a. LastMember IO effs => IORef s -> Eff (Memory s : effs) a -> Eff effs a\n\nCandidates:\n  Fields: (none)\n  Inputs: IORef\n  Output: (none)\n  References: Graph.hs:59, Graph.hs:248, Graph.hs:254, Graph.hs:423\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform TeachQuery and SymbolKey and LSPSymbol into TeachingDoc or Build or Groups?\nSymbol: buildTeachingDoc\nModule: Tidepool.Control.Scout.Teach\nPackage: tidepool-control-server\nSignature: buildTeachingDoc :: TeachQuery -> Map SymbolKey (Int, LSPSymbol) -> TeachingDoc Build a teaching document from the exploration graph. Groups by BFS depth: - Depth 0: Core (seed symbols) - Depth 1-2: Prerequisites - Depth 3+: Support\n\nCandidates:\n  Fields: (none)\n  Inputs: TeachQuery, SymbolKey, LSPSymbol\n  Output: TeachingDoc, Build, Groups, BFS, Depth, Core, Prerequisites, Support\n  References: Teach.hs:130, Teach.hs:366, Teach.hs:367\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>TeachQuery,SymbolKey,TeachingDoc,Build<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming GetPullRequest and Repo into GitHub or PullRequest?\nSymbol: GetPullRequest\nModule: Tidepool.Effects.GitHub\nPackage: tidepool-core\nSignature: GetPullRequest :: Repo %1 -> Int %1 -> Bool %1 -> GitHub (Maybe PullRequest)\n\nCandidates:\n  Fields: (none)\n  Inputs: GetPullRequest, Repo\n  Output: GitHub, PullRequest\n  References: GitHub.hs:306, GitHub.hs:328, GitHub.hs:359\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with HandlerBuilder and Value?\nSymbol: runGraphAsActors\nModule: Tidepool.Actor.Graph\nPackage: tidepool-actor\nSignature: runGraphAsActors :: forall result. FromJSON result => Map Text HandlerBuilder -> Value -> IO result\n\nCandidates:\n  Fields: (none)\n  Inputs: HandlerBuilder, Value\n  Output: (none)\n  References: Graph.hs:36, Graph.hs:296, Graph.hs:302, Graph.hs:450, Graph.hs:451\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>HandlerBuilder,Value<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I retrieve worktree configuration?\nSymbol: getWorktreeInfo\nModule: Tidepool.Effects.Git\nPackage: tidepool-core\nSignature: getWorktreeInfo :: forall (effs :: [Type -> Type]). Member Git effs => Eff effs (Maybe WorktreeInfo) Get worktree/repo information.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: WorktreeInfo, Get\n  References: Git.hs:20, Git.hs:101, Git.hs:102\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>WorktreeInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform SProvider and LLMProviderConfig and Value into LLMProviderResponse?\nSymbol: complete\nModule: Tidepool.Effects.LLMProvider\nPackage: tidepool-core\nSignature: complete :: forall (p :: LLMProvider) (effs :: [Type -> Type]). Member LLMComplete effs => SProvider p -> LLMProviderConfig p -> Text -> Maybe [Value] -> Eff effs (LLMProviderResponse p)\n\nCandidates:\n  Fields: (none)\n  Inputs: SProvider, LLMProviderConfig, Value\n  Output: LLMProviderResponse\n  References: LLMProvider.hs:32, LLMProvider.hs:335, LLMProvider.hs:342\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>SProvider,LLMProviderConfig,LLMProviderResponse<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Command and CodeAction into CodeAction?\nSymbol: fromCodeActionsResult\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromCodeActionsResult :: [Command |? CodeAction] -> [CodeAction]\n\nCandidates:\n  Fields: (none)\n  Inputs: Command, CodeAction\n  Output: CodeAction\n  References: Interpreter.hs:215, Interpreter.hs:352, Interpreter.hs:353\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Command,CodeAction<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Value and Value into TurnOutcome or TurnParseResult?\nSymbol: runTurn\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: runTurn :: forall output (effs :: [Type -> Type]). (Member LLM effs, StructuredOutput output, ValidStructuredOutput output) => Text -> Text -> Value -> [Value] -> Eff effs (TurnOutcome (TurnParseResult output))\n\nCandidates:\n  Fields: (none)\n  Inputs: Value, Value\n  Output: TurnOutcome, TurnParseResult\n  References: Types.hs:53, Types.hs:383, Types.hs:388, Types.hs:435, Types.hs:450, Types.hs:485, Types.hs:500, Interpret.hs:75, Interpret.hs:281\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Value,TurnOutcome,TurnParseResult<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to ServerConfig?\nSymbol: runServer\nModule: Tidepool.Control.Server\nPackage: tidepool-control-server\nSignature: runServer :: ServerConfig -> IO ()\n\nCandidates:\n  Fields: (none)\n  Inputs: ServerConfig\n  Output: (none)\n  References: Server.hs:10, Server.hs:52, Server.hs:53\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to MarkupContent and MarkedString?\nSymbol: extractMarkupContent\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: extractMarkupContent :: (MarkupContent |? (MarkedString |? [MarkedString])) -> Text\n\nCandidates:\n  Fields: (none)\n  Inputs: MarkupContent, MarkedString\n  Output: (none)\n  References: Interpreter.hs:311, Interpreter.hs:315, Interpreter.hs:316\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform GetFieldGotoTargetsWithPayloads and Type into Symbol or Type?\nSymbol: GetFieldGotoTargetsWithPayloads\nModule: Tidepool.Graph.Validate.RecordStructure\nPackage: tidepool-core\nSignature: GetFieldGotoTargetsWithPayloads :: Type -> [(Symbol, Type)] Get (target, payload) pairs from a field definition.\n\nCandidates:\n  Fields: (none)\n  Inputs: GetFieldGotoTargetsWithPayloads, Type\n  Output: Symbol, Type, Get\n  References: RecordStructure.hs:420, RecordStructure.hs:423, RecordStructure.hs:424, RecordStructure.hs:425\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetFieldGotoTargetsWithPayloads,Type,Symbol<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming HookInput into ControlResponse?\nSymbol: handleHook\nModule: Tidepool.Control.Handler.Hook\nPackage: tidepool-control-server\nSignature: handleHook :: HookInput -> IO ControlResponse\n\nCandidates:\n  Fields: (none)\n  Inputs: HookInput\n  Output: ControlResponse\n  References: Hook.hs:6, Hook.hs:19, Hook.hs:20, Handler.hs:7, Handler.hs:14\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming GotoAll into Value?\nSymbol: extractTargets\nModule: Tidepool.Actor.Dispatch\nPackage: tidepool-actor\nSignature: extractTargets :: forall (targets :: [Type]). SpawnWorkers targets => GotoAll targets -> [(Text, Value)] Extract (targetName, jsonPayload) pairs from a GotoAll.\n\nCandidates:\n  Fields: (none)\n  Inputs: GotoAll\n  Output: Value, Extract, GotoAll.\n  References: Dispatch.hs:129, Dispatch.hs:133, Dispatch.hs:141, Dispatch.hs:144\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When should I avoid spawning child graphs?\nSymbol: GetPending\nModule: Tidepool.Effect.Subgraph\nPackage: tidepool-core\nSignature: GetPending :: forall entry result. Subgraph entry result [ChildHandle] Get handles to children that haven't completed yet.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetPending, Subgraph, ChildHandle, Get\n  References: Subgraph.hs:362, Subgraph.hs:84, Subgraph.hs:143\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Location into Location?\nSymbol: fromLocation\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromLocation :: Location -> Location\n\nCandidates:\n  Fields: (none)\n  Inputs: Location\n  Output: Location\n  References: Interpreter.hs:201, Interpreter.hs:301, Interpreter.hs:302, Interpreter.hs:339, Interpreter.hs:340, Interpreter.hs:457, Interpreter.hs:471\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Value into Value or Parse or Expected?\nSymbol: parseArriveMessage\nModule: Tidepool.Actor.Graph\nPackage: tidepool-actor\nSignature: parseArriveMessage :: Value -> Either String (Text, Text, Value) Parse an arrive message from a worker. Expected format: { \"barrier\": \"hJoin\", \"source\": \"hTests\", \"payload\": {...} } For MVP, source is optional - if missing, extracted from barrier name. This works when barrier names match source node names, which is common. TODO: Require source in message or track provenance at router level.\n\nCandidates:\n  Fields: (none)\n  Inputs: Value\n  Output: Value, Parse, Expected, For, MVP, This, TODO, Require\n  References: Graph.hs:327, Graph.hs:558, Graph.hs:559\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform CandidateGroups into Format?\nSymbol: formatUserTurnGrouped\nModule: Tidepool.Training.Format\nPackage: tidepool-training-generator\nSignature: formatUserTurnGrouped :: Text -> Text -> Text -> Text -> CandidateGroups -> Text Format user turn with grouped candidates (v2 format).\n\nCandidates:\n  Fields: (none)\n  Inputs: CandidateGroups\n  Output: Format\n  References: Format.hs:8, Format.hs:117, Format.hs:124, Format.hs:148\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>CandidateGroups,Format<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform OutputFormat into Format?\nSymbol: formatOutput\nModule: Tidepool.Graph.CLI\nPackage: tidepool-core\nSignature: formatOutput :: forall a. (Show a, ToJSON a) => OutputFormat -> a -> Text Format output value according to the chosen format.\n\nCandidates:\n  Fields: (none)\n  Inputs: OutputFormat\n  Output: Format\n  References: CLI.hs:71, CLI.hs:451, CLI.hs:452, CLI.hs:453, CLI.hs:488\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>OutputFormat,Format<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with SpanKind and SpanAttribute?\nSymbol: withSpan\nModule: Tidepool.Effects.Observability\nPackage: tidepool-core\nSignature: withSpan :: forall (effs :: [Type -> Type]) a. Member Observability effs => Text -> SpanKind -> [SpanAttribute] -> Eff effs a -> Eff effs a\n\nCandidates:\n  Fields: (none)\n  Inputs: SpanKind, SpanAttribute\n  Output: (none)\n  References: Observability.hs:18, Observability.hs:164, Observability.hs:189, Observability.hs:219, Observability.hs:226\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>SpanKind,SpanAttribute<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to LSPSession and Socket?\nSymbol: handleConnection\nModule: Tidepool.Control.Server\nPackage: tidepool-control-server\nSignature: handleConnection :: LSPSession -> Socket -> IO ()\n\nCandidates:\n  Fields: (none)\n  Inputs: LSPSession, Socket\n  Output: (none)\n  References: Server.hs:82, Server.hs:101, Server.hs:102\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming TaskType into HabiticaTask?\nSymbol: getTasks\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: getTasks :: forall (effs :: [Type -> Type]). Member Habitica effs => TaskType -> Eff effs [HabiticaTask]\n\nCandidates:\n  Fields: (none)\n  Inputs: TaskType\n  Output: HabiticaTask\n  References: Habitica.hs:13, Habitica.hs:102, Habitica.hs:103\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I query handles for spawned child graphs?\nSymbol: GetPending\nModule: Tidepool.Effect.Subgraph\nPackage: tidepool-core\nSignature: GetPending :: forall entry result. Subgraph entry result [ChildHandle] Get handles to children that haven't completed yet.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetPending, Subgraph, ChildHandle, Get\n  References: Subgraph.hs:362, Subgraph.hs:84, Subgraph.hs:143\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetPending,Subgraph<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Stack into Stack?\nSymbol: pop\nModule: Data.Stack\nPackage: tidepool-core\nSignature: pop :: forall a. Stack a -> Maybe (a, Stack a) Remove and return the top element of the stack. Returns `Nothing` if the stack is empty. Returns 'Just (x, s')' where x is the top element and s' is the remaining stack. ### Laws pop empty == Nothing pop (push x s) == Just (x, s) ### Time Complexity O(1)\n\nCandidates:\n  Fields: (none)\n  Inputs: Stack\n  Output: Stack, Remove, Returns, Nothing, Laws, Just, Time, Complexity, O1\n  References: Stack.hs:7, Stack.hs:35, Stack.hs:85, Stack.hs:86\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to MermaidConfig and GraphInfo?\nSymbol: toMermaidWithConfig\nModule: Tidepool.Graph.Mermaid\nPackage: tidepool-core\nSignature: toMermaidWithConfig :: MermaidConfig -> GraphInfo -> Text\n\nCandidates:\n  Fields: (none)\n  Inputs: MermaidConfig, GraphInfo\n  Output: (none)\n  References: Mermaid.hs:30, Mermaid.hs:90, Mermaid.hs:136, Mermaid.hs:143, Mermaid.hs:144, Graph.hs:164\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I query handles for spawned child graphs?\nSymbol: GetPending\nModule: Tidepool.Effect.Subgraph\nPackage: tidepool-core\nSignature: GetPending :: forall entry result. Subgraph entry result [ChildHandle] Get handles to children that haven't completed yet.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetPending, Subgraph, ChildHandle, Get\n  References: Subgraph.hs:362, Subgraph.hs:84, Subgraph.hs:143\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetPending,Subgraph<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I format a model turn with annotation holes?\nSymbol: formatModelTurnWithHole\nModule: Tidepool.Training.Format\nPackage: tidepool-training-generator\nSignature: formatModelTurnWithHole :: Text Format model turn with hole for selected symbols.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Format\n  References: Format.hs:10, Format.hs:71, Format.hs:72, Format.hs:95, Format.hs:149\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Format<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with MermaidConfig and GraphInfo and ExecutionPath?\nSymbol: toSequenceDiagram\nModule: Tidepool.Graph.Mermaid\nPackage: tidepool-core\nSignature: toSequenceDiagram :: MermaidConfig -> GraphInfo -> ExecutionPath -> Text\n\nCandidates:\n  Fields: (none)\n  Inputs: MermaidConfig, GraphInfo, ExecutionPath\n  Output: (none)\n  References: Mermaid.hs:39, Mermaid.hs:509, Mermaid.hs:510\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>MermaidConfig,GraphInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I do to skip initializing an empty stack data structure?\nSymbol: empty\nModule: Data.Stack\nPackage: tidepool-core\nSignature: empty :: forall a. Stack a\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Stack\n  References: Stack.hs:32, Stack.hs:57, Stack.hs:58\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if you have non-enum types that shouldn't be enumerated?\nSymbol: enumSchema\nModule: Tidepool.Schema\nPackage: tidepool-core\nSignature: enumSchema :: [Text] -> JSONSchema Enum schema combinator\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: JSONSchema, Enum\n  References: Schema.hs:19, Schema.hs:92, Schema.hs:93, Schema.hs:170, Instances.hs:30\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I determine the entry type of a graph?\nSymbol: GetEntryType\nModule: Tidepool.Graph.Generic\nPackage: tidepool-core\nSignature: GetEntryType\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetEntryType\n  References: Generic.hs:106, Generic.hs:1120, Generic.hs:1121, Generic.hs:1122, Generic.hs:1122, Generic.hs:1123, Generic.hs:1123, Generic.hs:1124, Generic.hs:1125, Generic.hs:1126, Generic.hs:1126, Generic.hs:1126, Generic.hs:1127\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetEntryType<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming CodeAction into CodeAction?\nSymbol: fromCodeAction\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromCodeAction :: CodeAction -> CodeAction\n\nCandidates:\n  Fields: (none)\n  Inputs: CodeAction\n  Output: CodeAction\n  References: Interpreter.hs:358, Interpreter.hs:360, Interpreter.hs:361\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform TemplateInfo into Render?\nSymbol: renderTemplateComment\nModule: Tidepool.Graph.Mermaid\nPackage: tidepool-core\nSignature: renderTemplateComment :: Maybe TemplateInfo -> Text Render template comment.\n\nCandidates:\n  Fields: (none)\n  Inputs: TemplateInfo\n  Output: Render\n  References: Mermaid.hs:179, Mermaid.hs:193, Mermaid.hs:194, Mermaid.hs:195\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>TemplateInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Read and Usage and In and True and False and FailureResult and This and Memory and OLD into NEW or Direct or NodeInput?\nSymbol: getNodeInput\nModule: Tidepool.Effect.GraphContext\nPackage: tidepool-core\nSignature: getNodeInput :: forall input (effs :: [Type -> Type]). Member (NodeInput input) effs => Eff effs input Read the current node's input value. Usage requires type application to specify the input type: -- In implAfter originalInput <- getNodeInput @ImplInput case originalInput.iiAttemptCount < 5 of True -> pure $ gotoSelf originalInput { iiAttemptCount = originalInput.iiAttemptCount + 1 } False -> pure $ gotoExit FailureResult This replaces the pattern of storing input in Memory: -- OLD: Memory round-trip implBefore input = do updateMem @ImplMem $ \\m -> m { imOriginalInput = Just input } ... implAfter (exit, sid) = do mem <- getMem @ImplMem let originalInput = fromMaybe (error \"impossible\") mem.imOriginalInput ... -- NEW: Direct via NodeInput implAfter (exit, sid) = do originalInput <- getNodeInput @ImplInput ...\n\nCandidates:\n  Fields: (none)\n  Inputs: Read, Usage, In, True, False, FailureResult, This, Memory, OLD\n  Output: Just, NEW, Direct, NodeInput\n  References: GraphContext.hs:56, GraphContext.hs:161, GraphContext.hs:165\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Value into ParseDiagnostic?\nSymbol: expectedBool\nModule: Tidepool.StructuredOutput.Error\nPackage: tidepool-core\nSignature: expectedBool :: [Text] -> Value -> ParseDiagnostic Error for when a boolean was expected.\n\nCandidates:\n  Fields: (none)\n  Inputs: Value\n  Output: ParseDiagnostic, Error\n  References: Error.hs:17, Error.hs:76, Error.hs:77, Instances.hs:44, Instances.hs:94\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform GetTasksTry and TaskType into Habitica or HabiticaError or HabiticaTask?\nSymbol: GetTasksTry\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: GetTasksTry :: TaskType %1 -> Habitica (Either HabiticaError [HabiticaTask])\n\nCandidates:\n  Fields: (none)\n  Inputs: GetTasksTry, TaskType\n  Output: Habitica, HabiticaError, HabiticaTask\n  References: Habitica.hs:80, Habitica.hs:126, Habitica.hs:171\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetTasksTry,TaskType,Habitica,HabiticaError<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Position into Position?\nSymbol: fromPosition\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromPosition :: Position -> Position\n\nCandidates:\n  Fields: (none)\n  Inputs: Position\n  Output: Position\n  References: Interpreter.hs:289, Interpreter.hs:290, Interpreter.hs:297, Interpreter.hs:298\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When is edge scoring context not needed?\nSymbol: mkEdgeContext\nModule: Tidepool.Control.Scout.EdgeTypes\nPackage: tidepool-control-server\nSignature: mkEdgeContext :: Text -> Text -> Text -> Int -> Maybe Text -> EdgeContext\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: EdgeContext\n  References: EdgeTypes.hs:17, EdgeTypes.hs:131, EdgeTypes.hs:138\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform ScoringContext into Turn?\nSymbol: renderScoringPrompt\nModule: Tidepool.Control.Scout.Templates\nPackage: tidepool-control-server\nSignature: renderScoringPrompt :: ScoringContext -> Text Render the Turn 2 prompt for FunctionGemma. This is the user request that asks the model to rate the edge. Turn 1 (function declaration) is prepended by the interpreter.\n\nCandidates:\n  Fields: (none)\n  Inputs: ScoringContext\n  Output: Render, Turn, FunctionGemma., This\n  References: Templates.hs:18, Templates.hs:76, Templates.hs:77\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>ScoringContext,Turn<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with Position?\nSymbol: formatPosition\nModule: Tidepool.Control.Scout.LSP\nPackage: tidepool-control-server\nSignature: formatPosition :: Position -> Text\n\nCandidates:\n  Fields: (none)\n  Inputs: Position\n  Output: (none)\n  References: LSP.hs:13, LSP.hs:61, LSP.hs:62\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Position<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform WorkspaceEdit into WorkspaceEdit?\nSymbol: fromWorkspaceEditMaybe\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromWorkspaceEditMaybe :: Maybe WorkspaceEdit -> Maybe WorkspaceEdit\n\nCandidates:\n  Fields: (none)\n  Inputs: WorkspaceEdit\n  Output: WorkspaceEdit\n  References: Interpreter.hs:364, Interpreter.hs:384, Interpreter.hs:387, Interpreter.hs:388, Interpreter.hs:389\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>WorkspaceEdit<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if I only care about committed changes?\nSymbol: GetDirtyFiles\nModule: Tidepool.Effects.Git\nPackage: tidepool-core\nSignature: GetDirtyFiles :: Git [FilePath] Get list of dirty (uncommitted) files.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetDirtyFiles, Git, FilePath, Get\n  References: Git.hs:87, Git.hs:106\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with GraphInfo?\nSymbol: toMermaid\nModule: Tidepool.Graph.Mermaid\nPackage: tidepool-core\nSignature: toMermaid :: GraphInfo -> Text\n\nCandidates:\n  Fields: (none)\n  Inputs: GraphInfo\n  Output: (none)\n  References: Mermaid.hs:29, Mermaid.hs:89, Mermaid.hs:90, Mermaid.hs:98, Mermaid.hs:124, Graph.hs:163\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GraphInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Complete and LLMProvider. and SProvider and LLMProviderConfig and Value into LLMComplete or LLMProviderResponse?\nSymbol: Complete\nModule: Tidepool.Effects.LLMProvider\nPackage: tidepool-core\nSignature: Complete :: forall (p :: LLMProvider). SProvider p %1 -> LLMProviderConfig p %1 -> Text %1 -> Maybe [Value] %1 -> LLMComplete (LLMProviderResponse p)\n\nCandidates:\n  Fields: (none)\n  Inputs: Complete, LLMProvider., SProvider, LLMProviderConfig, Value\n  Output: LLMComplete, LLMProviderResponse\n  References: LLMProvider.hs:299, LLMProvider.hs:313, LLMProvider.hs:342, Interpreter.hs:254, Interpreter.hs:278, Interpreter.hs:284\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Complete,LLMProvider.,LLMComplete,LLMProviderResponse<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Stack into Stack?\nSymbol: pop\nModule: Data.Stack\nPackage: tidepool-core\nSignature: pop :: forall a. Stack a -> Maybe (a, Stack a) Remove and return the top element of the stack. Returns `Nothing` if the stack is empty. Returns 'Just (x, s')' where x is the top element and s' is the remaining stack. ### Laws pop empty == Nothing pop (push x s) == Just (x, s) ### Time Complexity O(1)\n\nCandidates:\n  Fields: (none)\n  Inputs: Stack\n  Output: Stack, Remove, Returns, Nothing, Laws, Just, Time, Complexity, O1\n  References: Stack.hs:7, Stack.hs:35, Stack.hs:85, Stack.hs:86\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Stack<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Definition and DefinitionLink and Null into Location?\nSymbol: fromDefinitionResult\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromDefinitionResult :: (Definition |? ([DefinitionLink] |? Null)) -> [Location]\n\nCandidates:\n  Fields: (none)\n  Inputs: Definition, DefinitionLink, Null\n  Output: Location\n  References: Interpreter.hs:208, Interpreter.hs:330, Interpreter.hs:331\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I retrieve dependencies of a bead?\nSymbol: getDeps\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: getDeps :: forall (effs :: [Type -> Type]). Member BD effs => Text -> Eff effs [BeadInfo] Get dependencies (beads this one depends on).\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: BeadInfo, Get\n  References: BD.hs:36, BD.hs:377, BD.hs:378\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>BeadInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with TemplateDependency and Render and Output?\nSymbol: renderDepTreeCompact\nModule: Tidepool.Graph.Docs\nPackage: tidepool-core\nSignature: renderDepTreeCompact :: TemplateDependency -> Text Render a compact single-line representation. Output example: `main.jinja -> header.jinja, footer.jinja`\n\nCandidates:\n  Fields: (none)\n  Inputs: TemplateDependency, Render, Output\n  Output: (none)\n  References: Docs.hs:37, Docs.hs:105, Docs.hs:106, Graph.hs:125\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>TemplateDependency<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When do I need a single schema type instead of a union?\nSymbol: oneOfSchema\nModule: Tidepool.Schema\nPackage: tidepool-core\nSignature: oneOfSchema :: [JSONSchema] -> JSONSchema OneOf schema combinator (for sum types)\n\nCandidates:\n  Fields: (none)\n  Inputs: JSONSchema\n  Output: JSONSchema, OneOf\n  References: Schema.hs:20, Schema.hs:96, Schema.hs:97\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if I need branch-agnostic operations?\nSymbol: GetCurrentBranch\nModule: Tidepool.Effects.Git\nPackage: tidepool-core\nSignature: GetCurrentBranch :: Git Text Get current branch name.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetCurrentBranch, Git, Get\n  References: Git.hs:93, Git.hs:114\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming TaskType into HabiticaError or HabiticaTask?\nSymbol: getTasksTry\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: getTasksTry :: forall (effs :: [Type -> Type]). Member Habitica effs => TaskType -> Eff effs (Either HabiticaError [HabiticaTask])\n\nCandidates:\n  Fields: (none)\n  Inputs: TaskType\n  Output: HabiticaError, HabiticaTask\n  References: Habitica.hs:21, Habitica.hs:125, Habitica.hs:126\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if time should be injected as input?\nSymbol: GetCurrentTime\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: GetCurrentTime :: Time UTCTime\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetCurrentTime, Time, UTCTime\n  References: Types.hs:196, Types.hs:199, Types.hs:203\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Position into Position?\nSymbol: fromPosition\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromPosition :: Position -> Position\n\nCandidates:\n  Fields: (none)\n  Inputs: Position\n  Output: Position\n  References: Interpreter.hs:289, Interpreter.hs:290, Interpreter.hs:297, Interpreter.hs:298\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Position<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to Position?\nSymbol: formatPosition\nModule: Tidepool.Control.Scout.LSP\nPackage: tidepool-control-server\nSignature: formatPosition :: Position -> Text\n\nCandidates:\n  Fields: (none)\n  Inputs: Position\n  Output: (none)\n  References: LSP.hs:13, LSP.hs:61, LSP.hs:62\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What does an implicit runtime edge (data flow) represent?\nSymbol: RuntimeImplicit\nModule: Tidepool.Graph.Reify\nPackage: tidepool-core\nSignature: RuntimeImplicit :: RuntimeEdgeKind Schema \u2192 Needs (data flow)\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: RuntimeImplicit, RuntimeEdgeKind, Schema, Needs\n  References: Reify.hs:206, Reify.hs:827, Reify.hs:834, Reify.hs:852, Export.hs:288\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>RuntimeImplicit,RuntimeEdgeKind<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform SymbolKind into SymbolKind?\nSymbol: fromSymbolKind\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromSymbolKind :: SymbolKind -> SymbolKind\n\nCandidates:\n  Fields: (none)\n  Inputs: SymbolKind\n  Output: SymbolKind\n  References: Interpreter.hs:456, Interpreter.hs:464, Interpreter.hs:477, Interpreter.hs:478\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>SymbolKind<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When is entry type known at compile time?\nSymbol: GetEntryType\nModule: Tidepool.Graph.Generic\nPackage: tidepool-core\nSignature: GetEntryType\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetEntryType\n  References: Generic.hs:106, Generic.hs:1120, Generic.hs:1121, Generic.hs:1122, Generic.hs:1122, Generic.hs:1123, Generic.hs:1123, Generic.hs:1124, Generic.hs:1125, Generic.hs:1126, Generic.hs:1126, Generic.hs:1126, Generic.hs:1127\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I create a todo with error handling?\nSymbol: createTodoTry\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: createTodoTry :: forall (effs :: [Type -> Type]). Member Habitica effs => Text -> Eff effs (Either HabiticaError TodoId)\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: HabiticaError, TodoId\n  References: Habitica.hs:18, Habitica.hs:116, Habitica.hs:117\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>HabiticaError,TodoId<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming EdgeType into ValueReference?\nSymbol: extractFunctionSig\nModule: Tidepool.Control.Scout.EdgeTypes\nPackage: tidepool-control-server\nSignature: extractFunctionSig :: EdgeType -> Text -> Maybe Text Extract function signature from hover for ValueReference edges.\n\nCandidates:\n  Fields: (none)\n  Inputs: EdgeType\n  Output: Extract, ValueReference\n  References: EdgeTypes.hs:149, EdgeTypes.hs:166, EdgeTypes.hs:167, EdgeTypes.hs:169, EdgeTypes.hs:171\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming TaskType into HabiticaError or HabiticaTask?\nSymbol: getTasksTry\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: getTasksTry :: forall (effs :: [Type -> Type]). Member Habitica effs => TaskType -> Eff effs (Either HabiticaError [HabiticaTask])\n\nCandidates:\n  Fields: (none)\n  Inputs: TaskType\n  Output: HabiticaError, HabiticaTask\n  References: Habitica.hs:21, Habitica.hs:125, Habitica.hs:126\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform GetBlocking into BD or BeadInfo?\nSymbol: GetBlocking\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: GetBlocking :: Text %1 -> BD [BeadInfo] Get beads that this bead is blocking.\n\nCandidates:\n  Fields: (none)\n  Inputs: GetBlocking\n  Output: BD, BeadInfo, Get\n  References: BD.hs:328, BD.hs:382\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetBlocking,BD,BeadInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming GetGotoTargetsFromEffects and Effect into Symbol or Type or Goto?\nSymbol: GetGotoTargetsFromEffects\nModule: Tidepool.Graph.Validate.RecordStructure\nPackage: tidepool-core\nSignature: GetGotoTargetsFromEffects :: [Effect] -> [(Symbol, Type)] Get Goto targets from effect list.\n\nCandidates:\n  Fields: (none)\n  Inputs: GetGotoTargetsFromEffects, Effect\n  Output: Symbol, Type, Get, Goto\n  References: RecordStructure.hs:432, RecordStructure.hs:435, RecordStructure.hs:436, RecordStructure.hs:437, RecordStructure.hs:438, RecordStructure.hs:439, RecordStructure.hs:440, RecordStructure.hs:440, RecordStructure.hs:441, RecordStructure.hs:441\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Type into JSONSchema?\nSymbol: typeToSchemaExp\nModule: Tidepool.Schema\nPackage: tidepool-core\nSignature: typeToSchemaExp :: Type -> Q Exp Convert a Haskell type to a JSONSchema expression\n\nCandidates:\n  Fields: (none)\n  Inputs: Type\n  Output: Exp, Convert, Haskell, JSONSchema\n  References: Schema.hs:185, Schema.hs:189, Schema.hs:190, Schema.hs:204, Schema.hs:208\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Type<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform EdgeContext into ScoringContext?\nSymbol: mkScoringContext\nModule: Tidepool.Control.Scout.Templates\nPackage: tidepool-control-server\nSignature: mkScoringContext :: Text -> EdgeContext -> ScoringContext\n\nCandidates:\n  Fields: (none)\n  Inputs: EdgeContext\n  Output: ScoringContext\n  References: Templates.hs:15, Templates.hs:58, Templates.hs:59\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>EdgeContext,ScoringContext<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to SProvider and LLMProviderConfig and Value and LLMError and LLMProviderResponse and Call and LLM and Use and SAnthropic and Left and LLMRateLimited and SAnthropic and Left and Right?\nSymbol: completeTry\nModule: Tidepool.Effects.LLMProvider\nPackage: tidepool-core\nSignature: completeTry :: forall (p :: LLMProvider) (effs :: [Type -> Type]). Member LLMComplete effs => SProvider p -> LLMProviderConfig p -> Text -> Maybe [Value] -> Eff effs (Either LLMError (LLMProviderResponse p)) Call an LLM with provider-specific config, returning errors as `Either` . Use this when you want to handle errors gracefully: result <- completeTry SAnthropic config msg tools case result of Left LLMRateLimited -> do liftIO $ threadDelay 1000000 completeTry SAnthropic config msg tools -- retry Left err -> logError $ \"LLM failed: \" <> show err Right response -> processResponse response\n\nCandidates:\n  Fields: (none)\n  Inputs: SProvider, LLMProviderConfig, Value, LLMError, LLMProviderResponse, Call, LLM, Use, SAnthropic, Left, LLMRateLimited, SAnthropic, Left, Right\n  Output: (none)\n  References: LLMProvider.hs:33, LLMProvider.hs:270, LLMProvider.hs:334, LLMProvider.hs:357, LLMProvider.hs:364\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform MemoryStore and MemoryStore and Run and This and Loads and Runs and Saves and If and Use and ExploreMem into ExploreMem?\nSymbol: runMemoryScoped\nModule: Tidepool.Graph.Memory\nPackage: tidepool-core\nSignature: runMemoryScoped :: forall s (effs :: [Type -> Type]) a. (ToJSON s, FromJSON s) => Text -> s -> MemoryStore -> Eff (Memory s : effs) a -> Eff effs (a, MemoryStore) Run memory effect with scoped persistence. This interpreter: 1. Loads initial state from the store (or uses default if scope missing) 2. Runs the action 3. Saves final state back to the store If deserialization fails (e.g., schema mismatch after code changes), the default value is used. Use `getScope` directly if you need to detect errors. (result, finalStore) <- runMemoryScoped \"explore\" defaultState store $ do updateMem `ExploreMem $ \\m -> m { visited = newUrl : m.visited } getMem ` ExploreMem\n\nCandidates:\n  Fields: (none)\n  Inputs: MemoryStore, MemoryStore, Run, This, Loads, Runs, Saves, If, Use, ExploreMem\n  Output: ExploreMem\n  References: Memory.hs:91, Memory.hs:435, Memory.hs:442, Memory.hs:467\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>MemoryStore,ExploreMem<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform MemoryStore into Nothing' or Left or Type?\nSymbol: getScope\nModule: Tidepool.Graph.Memory\nPackage: tidepool-core\nSignature: getScope :: forall s. FromJSON s => Text -> MemoryStore -> Either Text (Maybe s) Get a scope from the store, deserializing to the expected type. Returns 'Right Nothing' if the scope doesn't exist. Returns `Left` error if deserialization fails (type mismatch). Type safety is enforced by the `FromJSON` constraint - if the stored JSON doesn't match the expected type, parsing will fail with an error.\n\nCandidates:\n  Fields: (none)\n  Inputs: MemoryStore\n  Output: Get, Returns, Nothing', Left, Type, FromJSON, JSON\n  References: Memory.hs:89, Memory.hs:279, Memory.hs:364, Memory.hs:394, Memory.hs:399, Memory.hs:410, Memory.hs:428, Memory.hs:444\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>MemoryStore<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When should I ignore bead dependencies?\nSymbol: getDeps\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: getDeps :: forall (effs :: [Type -> Type]). Member BD effs => Text -> Eff effs [BeadInfo] Get dependencies (beads this one depends on).\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: BeadInfo, Get\n  References: BD.hs:36, BD.hs:377, BD.hs:378\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming MermaidConfig and NodeInfo into Render?\nSymbol: renderNodeWithComments\nModule: Tidepool.Graph.Mermaid\nPackage: tidepool-core\nSignature: renderNodeWithComments :: MermaidConfig -> NodeInfo -> [Text] Render a node with optional structured comments.\n\nCandidates:\n  Fields: (none)\n  Inputs: MermaidConfig, NodeInfo\n  Output: Render\n  References: Mermaid.hs:161, Mermaid.hs:164, Mermaid.hs:165\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When should I start fresh without history?\nSymbol: getHistory\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: getHistory :: forall (effs :: [Type -> Type]). Member ChatHistory effs => Eff effs [Message]\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Message\n  References: Types.hs:45, Types.hs:516, Types.hs:517\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Range into Range?\nSymbol: toRange\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: toRange :: Range -> Range\n\nCandidates:\n  Fields: (none)\n  Inputs: Range\n  Output: Range\n  References: Interpreter.hs:212, Interpreter.hs:278, Interpreter.hs:279\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Range<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming GetUsesEffectsFixed and Type into Effect or UsesEffects?\nSymbol: GetUsesEffectsFixed\nModule: Tidepool.Graph.Validate.RecordStructure\nPackage: tidepool-core\nSignature: GetUsesEffectsFixed :: Type -> Maybe [Effect] Get UsesEffects with fixed kind.\n\nCandidates:\n  Fields: (none)\n  Inputs: GetUsesEffectsFixed, Type\n  Output: Effect, Get, UsesEffects\n  References: RecordStructure.hs:318, RecordStructure.hs:321, RecordStructure.hs:322, RecordStructure.hs:323, RecordStructure.hs:324, RecordStructure.hs:324, RecordStructure.hs:325, RecordStructure.hs:363, RecordStructure.hs:426, RecordStructure.hs:571, RecordStructure.hs:630, RecordStructure.hs:646\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming JSONSchema into Check?\nSymbol: isEmptyObject\nModule: Tidepool.StructuredOutput.Generic\nPackage: tidepool-core\nSignature: isEmptyObject :: JSONSchema -> Bool Check if a schema represents an empty object {}. An empty object has type TObject with no properties and no required fields.\n\nCandidates:\n  Fields: (none)\n  Inputs: JSONSchema\n  Output: Check, An, TObject\n  References: Generic.hs:303, Generic.hs:308, Generic.hs:309\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform FilePath and FilePath and FilePath and FilePath into FilePath or Recursively?\nSymbol: buildTreeFrom\nModule: Tidepool.Template.DependencyTree\nPackage: tidepool-core\nSignature: buildTreeFrom :: FilePath -> Set FilePath -> Map FilePath [FilePath] -> Map FilePath [FilePath] -> IO (Map FilePath [FilePath], Map FilePath [FilePath]) Recursively build dependency maps.\n\nCandidates:\n  Fields: (none)\n  Inputs: FilePath, FilePath, FilePath, FilePath\n  Output: FilePath, Recursively\n  References: DependencyTree.hs:155, DependencyTree.hs:163, DependencyTree.hs:169, DependencyTree.hs:193\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>FilePath,Recursively<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming GetBead into BD or BeadInfo?\nSymbol: GetBead\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: GetBead :: Text %1 -> BD (Maybe BeadInfo) Get full bead info by ID.\n\nCandidates:\n  Fields: (none)\n  Inputs: GetBead\n  Output: BD, BeadInfo, Get, ID.\n  References: BD.hs:322, BD.hs:374\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with LogLevel?\nSymbol: runLog\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: runLog :: forall (effs :: [Type -> Type]) a. LastMember IO effs => LogLevel -> Eff (Log : effs) a -> Eff effs a\n\nCandidates:\n  Fields: (none)\n  Inputs: LogLevel\n  Output: (none)\n  References: Types.hs:94, Types.hs:715, Types.hs:716, MCP.hs:20, MCP.hs:71\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>LogLevel<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming GetBarrierTargetOrError and Symbol and Type into Symbol?\nSymbol: GetBarrierTargetOrError\nModule: Tidepool.Graph.Validate.ForkBarrier\nPackage: tidepool-core\nSignature: GetBarrierTargetOrError :: Symbol -> Type -> Symbol Get barrier target or produce error.\n\nCandidates:\n  Fields: (none)\n  Inputs: GetBarrierTargetOrError, Symbol, Type\n  Output: Symbol, Get\n  References: ForkBarrier.hs:146, ForkBarrier.hs:152, ForkBarrier.hs:153, ForkBarrier.hs:154\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When should I avoid LLM calls in a node?\nSymbol: RuntimeLLM\nModule: Tidepool.Graph.Reify\nPackage: tidepool-core\nSignature: RuntimeLLM :: RuntimeNodeKind Standard LLM API call\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: RuntimeLLM, RuntimeNodeKind, Standard, LLM, API\n  References: Reify.hs:197, Reify.hs:410, Reify.hs:762, Mermaid.hs:186, Mermaid.hs:245, Mermaid.hs:253, Mermaid.hs:414, Export.hs:280\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform JSONSchema into JSONSchema?\nSymbol: describeField\nModule: Tidepool.Schema\nPackage: tidepool-core\nSignature: describeField :: Text -> Text -> JSONSchema -> JSONSchema Add description to schema\n\nCandidates:\n  Fields: (none)\n  Inputs: JSONSchema\n  Output: JSONSchema, Add\n  References: Schema.hs:21, Schema.hs:100, Schema.hs:101, Schema.hs:186\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>JSONSchema<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I do to skip initializing the node-private memory store for a fresh graph execution?\nSymbol: emptyMemoryStore\nModule: Tidepool.Graph.Memory\nPackage: tidepool-core\nSignature: emptyMemoryStore :: MemoryStore\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: MemoryStore\n  References: Memory.hs:86, Memory.hs:286, Memory.hs:287\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I retrieve Habitica user information?\nSymbol: GetUser\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: GetUser :: Habitica UserInfo\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetUser, Habitica, UserInfo\n  References: Habitica.hs:70, Habitica.hs:97, Habitica.hs:145\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetUser,Habitica<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with McpConfig?\nSymbol: runMcpServer\nModule: Tidepool.MCP.Server\nPackage: unknown\nSignature: runMcpServer :: McpConfig -> IO ()\n\nCandidates:\n  Fields: (none)\n  Inputs: McpConfig\n  Output: (none)\n  References: Server.hs:11, Server.hs:54, Server.hs:55, Server.hs:11, Server.hs:54, Server.hs:55\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>McpConfig<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to MermaidConfig and GraphInfo?\nSymbol: toStateDiagramWithConfig\nModule: Tidepool.Graph.Mermaid\nPackage: tidepool-core\nSignature: toStateDiagramWithConfig :: MermaidConfig -> GraphInfo -> Text\n\nCandidates:\n  Fields: (none)\n  Inputs: MermaidConfig, GraphInfo\n  Output: (none)\n  References: Mermaid.hs:36, Mermaid.hs:388, Mermaid.hs:391, Mermaid.hs:392\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if I need to work without bead lookups?\nSymbol: getBead\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: getBead :: forall (effs :: [Type -> Type]). Member BD effs => Text -> Eff effs (Maybe BeadInfo) Get bead info by ID.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: BeadInfo, Get, ID.\n  References: BD.hs:35, BD.hs:373, BD.hs:374\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with Type?\nSymbol: runGraphContext\nModule: Tidepool.Effect.GraphContext\nPackage: tidepool-core\nSignature: runGraphContext :: forall entry (effs :: [Type -> Type]) a. entry -> Eff (GraphContext entry : effs) a -> Eff effs a\n\nCandidates:\n  Fields: (none)\n  Inputs: Type\n  Output: (none)\n  References: GraphContext.hs:59, GraphContext.hs:182, GraphContext.hs:186\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Type<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming GetFieldGotoTargetNames and Type into Symbol or Goto?\nSymbol: GetFieldGotoTargetNames\nModule: Tidepool.Graph.Validate.RecordStructure\nPackage: tidepool-core\nSignature: GetFieldGotoTargetNames :: Type -> [Symbol] Get Goto target names from a field definition.\n\nCandidates:\n  Fields: (none)\n  Inputs: GetFieldGotoTargetNames, Type\n  Output: Symbol, Get, Goto\n  References: RecordStructure.hs:357, RecordStructure.hs:360, RecordStructure.hs:361, RecordStructure.hs:362\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming BaseUrl into Unwrap?\nSymbol: getBaseUrl\nModule: Tidepool.LLM.Types\nPackage: unknown\nSignature: getBaseUrl :: BaseUrl -> Text Unwrap a base URL to get the underlying text.\n\nCandidates:\n  Fields: (none)\n  Inputs: BaseUrl\n  Output: Unwrap, URL\n  References: Interpreter.hs:73, Interpreter.hs:104, Interpreter.hs:146, Types.hs:43, Types.hs:95, Types.hs:96\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with SProvider and LLMProviderConfig and Value and LLMError and LLMProviderResponse and Call and LLM and Use and SAnthropic and Left and LLMRateLimited and SAnthropic and Left and Right?\nSymbol: completeTry\nModule: Tidepool.Effects.LLMProvider\nPackage: tidepool-core\nSignature: completeTry :: forall (p :: LLMProvider) (effs :: [Type -> Type]). Member LLMComplete effs => SProvider p -> LLMProviderConfig p -> Text -> Maybe [Value] -> Eff effs (Either LLMError (LLMProviderResponse p)) Call an LLM with provider-specific config, returning errors as `Either` . Use this when you want to handle errors gracefully: result <- completeTry SAnthropic config msg tools case result of Left LLMRateLimited -> do liftIO $ threadDelay 1000000 completeTry SAnthropic config msg tools -- retry Left err -> logError $ \"LLM failed: \" <> show err Right response -> processResponse response\n\nCandidates:\n  Fields: (none)\n  Inputs: SProvider, LLMProviderConfig, Value, LLMError, LLMProviderResponse, Call, LLM, Use, SAnthropic, Left, LLMRateLimited, SAnthropic, Left, Right\n  Output: (none)\n  References: LLMProvider.hs:33, LLMProvider.hs:270, LLMProvider.hs:334, LLMProvider.hs:357, LLMProvider.hs:364\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>SProvider,LLMProviderConfig<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform ImageSource into ContentBlock or Build?\nSymbol: withImages\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: withImages :: Text -> [ImageSource] -> [ContentBlock] Build content blocks from text + images\n\nCandidates:\n  Fields: (none)\n  Inputs: ImageSource\n  Output: ContentBlock, Build\n  References: Types.hs:60, Types.hs:380, Types.hs:381\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>ImageSource,ContentBlock,Build<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming OpenAIConfig and Value into OpenAIRequest or Build or OpenAI?\nSymbol: buildOpenAIRequest\nModule: Tidepool.LLM.Interpreter\nPackage: unknown\nSignature: buildOpenAIRequest :: OpenAIConfig -> Text -> Maybe [Value] -> OpenAIRequest Build OpenAI Chat Completions API request. **Tools format** : Tools should be in OpenAI function format: { \"type\": \"function\", \"function\": { \"name\": \"...\", \"description\": \"...\", \"parameters\": {...} } } Use `CfTool` from `Tidepool.Tool.Wire` or the `ToCfTool` typeclass to produce correctly formatted tools. Do NOT pass Anthropic-format tools here.\n\nCandidates:\n  Fields: (none)\n  Inputs: OpenAIConfig, Value\n  Output: OpenAIRequest, Build, OpenAI, Chat, Completions, API, Tools, Use, CfTool, Tidepool.Tool.Wire, ToCfTool, Do, NOT, Anthropic-format\n  References: Interpreter.hs:39, Interpreter.hs:148, Interpreter.hs:163, Interpreter.hs:164\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When is spawning not an option?\nSymbol: GetSpawnTargetNames\nModule: Tidepool.Graph.Validate.ForkBarrier\nPackage: tidepool-core\nSignature: GetSpawnTargetNames\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetSpawnTargetNames\n  References: ForkBarrier.hs:47, ForkBarrier.hs:187, ForkBarrier.hs:188, ForkBarrier.hs:189, ForkBarrier.hs:190, ForkBarrier.hs:190, ForkBarrier.hs:191, ForkBarrier.hs:191\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming AsHandler into Run?\nSymbol: runGraphWithSpans\nModule: Tidepool.Graph.Interpret.Instrumented\nPackage: tidepool-core\nSignature: runGraphWithSpans :: forall (graph :: Type -> Type) entryType (targets :: [Type]) exitType (es :: [Effect]) (entryHandlerName :: Symbol) handler. (Generic (graph AsGraph), FindEntryHandler entryType (FieldsWithNamesOf graph) ~ 'Just entryHandlerName, KnownSymbol entryHandlerName, HasField entryHandlerName (graph (AsHandler es)) handler, CallHandler handler entryType es targets, DispatchGotoTraced graph targets es exitType, Member Observability es) => graph (AsHandler es) -> entryType -> Eff es exitType Run a graph with automatic span emission for each node transition. Creates a root span for the graph and child spans for each handler invocation. result <- runGraphWithSpans @MyGraph handlers inputValue\n\nCandidates:\n  Fields: (none)\n  Inputs: AsHandler\n  Output: Run, Creates\n  References: Instrumented.hs:44, Instrumented.hs:121, Instrumented.hs:134\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming GetDeps into BD or BeadInfo?\nSymbol: GetDeps\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: GetDeps :: Text %1 -> BD [BeadInfo] Get beads that this bead depends on (blockers).\n\nCandidates:\n  Fields: (none)\n  Inputs: GetDeps\n  Output: BD, BeadInfo, Get\n  References: BD.hs:325, BD.hs:378\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When are runtime edge types not relevant?\nSymbol: RuntimeEdgeKind\nModule: Tidepool.Graph.Reify\nPackage: tidepool-core\nSignature: RuntimeEdgeKind\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: RuntimeEdgeKind\n  References: Reify.hs:32, Reify.hs:191, Reify.hs:205, Reify.hs:191, Reify.hs:193, Reify.hs:193, Reify.hs:208, Reify.hs:208, Graph.hs:141, Export.hs:40, Export.hs:287, Export.hs:229, Export.hs:288\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming GetRecordEntryType and Type into Type?\nSymbol: GetRecordEntryType\nModule: Tidepool.Graph.Validate.RecordStructure\nPackage: tidepool-core\nSignature: GetRecordEntryType :: (Type -> Type) -> Type Get EntryNode type from a graph record (unwrap Maybe).\n\nCandidates:\n  Fields: (none)\n  Inputs: GetRecordEntryType, Type\n  Output: Type, Get, EntryNode, Maybe.\n  References: RecordStructure.hs:128, RecordStructure.hs:131, RecordStructure.hs:132, RecordStructure.hs:133, RecordStructure.hs:390\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with MermaidConfig and GraphInfo?\nSymbol: toStateDiagramWithConfig\nModule: Tidepool.Graph.Mermaid\nPackage: tidepool-core\nSignature: toStateDiagramWithConfig :: MermaidConfig -> GraphInfo -> Text\n\nCandidates:\n  Fields: (none)\n  Inputs: MermaidConfig, GraphInfo\n  Output: (none)\n  References: Mermaid.hs:36, Mermaid.hs:388, Mermaid.hs:391, Mermaid.hs:392\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>MermaidConfig,GraphInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with SProvider and LLMProviderConfig and Value and LLMError and LLMProviderResponse and Call and LLM and Use and SAnthropic and Left and LLMRateLimited and SAnthropic and Left and Right?\nSymbol: completeTry\nModule: Tidepool.Effects.LLMProvider\nPackage: tidepool-core\nSignature: completeTry :: forall (p :: LLMProvider) (effs :: [Type -> Type]). Member LLMComplete effs => SProvider p -> LLMProviderConfig p -> Text -> Maybe [Value] -> Eff effs (Either LLMError (LLMProviderResponse p)) Call an LLM with provider-specific config, returning errors as `Either` . Use this when you want to handle errors gracefully: result <- completeTry SAnthropic config msg tools case result of Left LLMRateLimited -> do liftIO $ threadDelay 1000000 completeTry SAnthropic config msg tools -- retry Left err -> logError $ \"LLM failed: \" <> show err Right response -> processResponse response\n\nCandidates:\n  Fields: (none)\n  Inputs: SProvider, LLMProviderConfig, Value, LLMError, LLMProviderResponse, Call, LLM, Use, SAnthropic, Left, LLMRateLimited, SAnthropic, Left, Right\n  Output: (none)\n  References: LLMProvider.hs:33, LLMProvider.hs:270, LLMProvider.hs:334, LLMProvider.hs:357, LLMProvider.hs:364\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>SProvider,LLMProviderConfig<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform GetBead into BD or BeadInfo?\nSymbol: GetBead\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: GetBead :: Text %1 -> BD (Maybe BeadInfo) Get full bead info by ID.\n\nCandidates:\n  Fields: (none)\n  Inputs: GetBead\n  Output: BD, BeadInfo, Get, ID.\n  References: BD.hs:322, BD.hs:374\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetBead,BD,BeadInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I read the current memory state for this node?\nSymbol: GetMem\nModule: Tidepool.Actor.Graph\nPackage: tidepool-actor\nSignature: GetMem :: forall s. Memory s s\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetMem, Memory\n  References: Graph.hs:229, Graph.hs:234, Graph.hs:255\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetMem,Memory<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming TextDocumentIdentifier into TextDocumentIdentifier?\nSymbol: toTextDocumentId\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: toTextDocumentId :: TextDocumentIdentifier -> TextDocumentIdentifier\n\nCandidates:\n  Fields: (none)\n  Inputs: TextDocumentIdentifier\n  Output: TextDocumentIdentifier\n  References: Interpreter.hs:188, Interpreter.hs:204, Interpreter.hs:211, Interpreter.hs:218, Interpreter.hs:234, Interpreter.hs:267, Interpreter.hs:268\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform GetRecentCommits into Git?\nSymbol: GetRecentCommits\nModule: Tidepool.Effects.Git\nPackage: tidepool-core\nSignature: GetRecentCommits :: Int %1 -> Git [Text] Get recent commit subjects.\n\nCandidates:\n  Fields: (none)\n  Inputs: GetRecentCommits\n  Output: Git, Get\n  References: Git.hs:90, Git.hs:110\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetRecentCommits,Git<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform GetGotoTargetsFromMaybeEffects and Effect into Symbol or Type or Goto?\nSymbol: GetGotoTargetsFromMaybeEffects\nModule: Tidepool.Graph.Validate.RecordStructure\nPackage: tidepool-core\nSignature: GetGotoTargetsFromMaybeEffects :: Maybe [Effect] -> [(Symbol, Type)] Get Goto targets from Maybe effect list.\n\nCandidates:\n  Fields: (none)\n  Inputs: GetGotoTargetsFromMaybeEffects, Effect\n  Output: Symbol, Type, Get, Goto\n  References: RecordStructure.hs:426, RecordStructure.hs:429, RecordStructure.hs:430, RecordStructure.hs:431, RecordStructure.hs:432\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetGotoTargetsFromMaybeEffects,Effect,Symbol,Type<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming NodeInfo into LLM?\nSymbol: renderNodeComments\nModule: Tidepool.Graph.Mermaid\nPackage: tidepool-core\nSignature: renderNodeComments :: NodeInfo -> [Text] Render structured comments for a node (for LLM context).\n\nCandidates:\n  Fields: (none)\n  Inputs: NodeInfo\n  Output: Render, LLM\n  References: Mermaid.hs:169, Mermaid.hs:174, Mermaid.hs:175\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform TaskType into HabiticaError or HabiticaTask?\nSymbol: getTasksTry\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: getTasksTry :: forall (effs :: [Type -> Type]). Member Habitica effs => TaskType -> Eff effs (Either HabiticaError [HabiticaTask])\n\nCandidates:\n  Fields: (none)\n  Inputs: TaskType\n  Output: HabiticaError, HabiticaTask\n  References: Habitica.hs:21, Habitica.hs:125, Habitica.hs:126\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>TaskType,HabiticaError,HabiticaTask<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with MarkupContent and MarkedString?\nSymbol: extractMarkupContent\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: extractMarkupContent :: (MarkupContent |? (MarkedString |? [MarkedString])) -> Text\n\nCandidates:\n  Fields: (none)\n  Inputs: MarkupContent, MarkedString\n  Output: (none)\n  References: Interpreter.hs:311, Interpreter.hs:315, Interpreter.hs:316\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>MarkupContent,MarkedString<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming SchemaInfo into Render?\nSymbol: renderSchemaComment\nModule: Tidepool.Graph.Mermaid\nPackage: tidepool-core\nSignature: renderSchemaComment :: Maybe SchemaInfo -> Text Render schema comment.\n\nCandidates:\n  Fields: (none)\n  Inputs: SchemaInfo\n  Output: Render\n  References: Mermaid.hs:180, Mermaid.hs:203, Mermaid.hs:204, Mermaid.hs:205\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When should I avoid recursive subgraph execution?\nSymbol: withRecursiveGraph\nModule: Tidepool.Actor.Subgraph\nPackage: tidepool-actor\nSignature: withRecursiveGraph :: forall entry result a. Maybe Int -> (SubgraphState entry result -> ((ChildId -> entry -> IO result) -> IO ()) -> IO a) -> IO a Run a computation with a recursive subgraph, handling all wiring automatically. **This is the recommended API for DSL users.** The callback receives: 1. `SubgraphState` - pass this to your effect interpreter 2. A `wire` function - call this with your graph runner BEFORE running result [withRecursiveGraph @Spec @V2Result $ \\subgraphState wire -](-) do let interpret = runV2Effects subgraphState ... handlers <- buildHandlerMap interpret -- Wire the recursion (MUST happen before running!) -- Runner receives ChildId for linking child nodes to parent wire $ \\childId childSpec -> runGraphAsActors handlers (toJSON childSpec) -- Now run - children will recursively spawn correctly runGraphAsActors handlers (toJSON rootSpec) ## Why This Pattern? Graph execution has a chicken-and-egg problem: 1. The interpreter needs SubgraphState 2. SubgraphState needs the graph runner 3. The graph runner needs handlers 4. Handlers need the interpreter (step 1!) This function breaks the cycle using deferred binding. The internal IORef is completely hidden - you just call `wire` with your runner. ## Scope-Based Cancellation The function creates a ki scope that wraps the entire computation. All children spawned via `spawnSelf` run within this scope. When the callback returns (success or exception), the scope exits and ki automatically cancels any still-running children.\n\nCandidates:\n  Fields: (none)\n  Inputs: SubgraphState, ChildId, Run, This, API, DSL, The, SubgraphState, BEFORE, Wire, MUST, Runner, ChildId\n  Output: Now, Why, This, Pattern?, Graph, The, SubgraphState, Handlers, IORef, Scope-Based, Cancellation, All, When\n  References: Subgraph.hs:52, Subgraph.hs:171, Subgraph.hs:264, Subgraph.hs:271\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I convert GetFieldSchema and Symbol and Type and Symbol to a Type or Get or Schema?\nSymbol: GetFieldSchema\nModule: Tidepool.Graph.Validate.RecordStructure\nPackage: tidepool-core\nSignature: GetFieldSchema :: [(Symbol, Type)] -> Symbol -> Maybe Type Get Schema type for a field by name.\n\nCandidates:\n  Fields: (none)\n  Inputs: GetFieldSchema, Symbol, Type, Symbol\n  Output: Type, Get, Schema\n  References: RecordStructure.hs:226, RecordStructure.hs:229, RecordStructure.hs:230, RecordStructure.hs:231, RecordStructure.hs:232, RecordStructure.hs:235\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetFieldSchema,Symbol,Type<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When is worktree info irrelevant?\nSymbol: getWorktreeInfo\nModule: Tidepool.Effects.Git\nPackage: tidepool-core\nSignature: getWorktreeInfo :: forall (effs :: [Type -> Type]). Member Git effs => Eff effs (Maybe WorktreeInfo) Get worktree/repo information.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: WorktreeInfo, Get\n  References: Git.hs:20, Git.hs:101, Git.hs:102\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform EdgeType into ValueReference?\nSymbol: extractFunctionSig\nModule: Tidepool.Control.Scout.EdgeTypes\nPackage: tidepool-control-server\nSignature: extractFunctionSig :: EdgeType -> Text -> Maybe Text Extract function signature from hover for ValueReference edges.\n\nCandidates:\n  Fields: (none)\n  Inputs: EdgeType\n  Output: Extract, ValueReference\n  References: EdgeTypes.hs:149, EdgeTypes.hs:166, EdgeTypes.hs:167, EdgeTypes.hs:169, EdgeTypes.hs:171\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>EdgeType,Extract,ValueReference<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Type into Alias or State?\nSymbol: runMemoryPure\nModule: Tidepool.Graph.Memory\nPackage: tidepool-core\nSignature: runMemoryPure :: forall s (effs :: [Type -> Type]) a. s -> Eff (Memory s : effs) a -> Eff effs a Run memory effect with pure initial value, discarding final state. Alias for `evalMemory` for symmetry with State naming conventions.\n\nCandidates:\n  Fields: (none)\n  Inputs: Type\n  Output: Run, Alias, State\n  References: Memory.hs:77, Memory.hs:218, Memory.hs:219\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Type,Alias<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform GetChildren into BD or BeadInfo?\nSymbol: GetChildren\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: GetChildren :: Text %1 -> BD [BeadInfo] Get child beads (beads with this as parent).\n\nCandidates:\n  Fields: (none)\n  Inputs: GetChildren\n  Output: BD, BeadInfo, Get\n  References: BD.hs:334, BD.hs:390\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetChildren,BD,BeadInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to MermaidConfig and GraphInfo?\nSymbol: toStateDiagramWithConfig\nModule: Tidepool.Graph.Mermaid\nPackage: tidepool-core\nSignature: toStateDiagramWithConfig :: MermaidConfig -> GraphInfo -> Text\n\nCandidates:\n  Fields: (none)\n  Inputs: MermaidConfig, GraphInfo\n  Output: (none)\n  References: Mermaid.hs:36, Mermaid.hs:388, Mermaid.hs:391, Mermaid.hs:392\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When is tool metadata not needed?\nSymbol: toolToInfo\nModule: Tidepool.Graph.Tool\nPackage: tidepool-core\nSignature: toolToInfo :: forall t. ToolDef t => t -> ToolInfo\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: ToolInfo\n  References: Tool.hs:73, Tool.hs:249, Tool.hs:250, Graph.hs:208\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I safely fetch user info with error handling?\nSymbol: getUserTry\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: getUserTry :: forall (effs :: [Type -> Type]). Member Habitica effs => Eff effs (Either HabiticaError UserInfo)\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: HabiticaError, UserInfo\n  References: Habitica.hs:19, Habitica.hs:119, Habitica.hs:120\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>HabiticaError,UserInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with Type?\nSymbol: runState\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: runState :: forall s (effs :: [Type -> Type]) a. s -> Eff (State s : effs) a -> Eff effs (a, s)\n\nCandidates:\n  Fields: (none)\n  Inputs: Type\n  Output: (none)\n  References: Types.hs:90, Types.hs:167, Types.hs:168\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Type<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I create a todo with error handling?\nSymbol: createTodoTry\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: createTodoTry :: forall (effs :: [Type -> Type]). Member Habitica effs => Text -> Eff effs (Either HabiticaError TodoId)\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: HabiticaError, TodoId\n  References: Habitica.hs:18, Habitica.hs:116, Habitica.hs:117\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>HabiticaError,TodoId<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Command and CodeAction into CodeAction?\nSymbol: fromCodeActionsResult\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromCodeActionsResult :: [Command |? CodeAction] -> [CodeAction]\n\nCandidates:\n  Fields: (none)\n  Inputs: Command, CodeAction\n  Output: CodeAction\n  References: Interpreter.hs:215, Interpreter.hs:352, Interpreter.hs:353\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Hover into HoverInfo?\nSymbol: fromHoverResult\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromHoverResult :: Maybe Hover -> Maybe HoverInfo\n\nCandidates:\n  Fields: (none)\n  Inputs: Hover\n  Output: HoverInfo\n  References: Interpreter.hs:192, Interpreter.hs:308, Interpreter.hs:309, Interpreter.hs:310\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Hover,HoverInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Command and CodeAction into CodeAction?\nSymbol: fromCommandOrAction\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromCommandOrAction :: (Command |? CodeAction) -> [CodeAction]\n\nCandidates:\n  Fields: (none)\n  Inputs: Command, CodeAction\n  Output: CodeAction\n  References: Interpreter.hs:353, Interpreter.hs:355, Interpreter.hs:356\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Command,CodeAction<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Complete and LLMProvider. and SProvider and LLMProviderConfig and Value into LLMComplete or LLMProviderResponse?\nSymbol: Complete\nModule: Tidepool.Effects.LLMProvider\nPackage: tidepool-core\nSignature: Complete :: forall (p :: LLMProvider). SProvider p %1 -> LLMProviderConfig p %1 -> Text %1 -> Maybe [Value] %1 -> LLMComplete (LLMProviderResponse p)\n\nCandidates:\n  Fields: (none)\n  Inputs: Complete, LLMProvider., SProvider, LLMProviderConfig, Value\n  Output: LLMComplete, LLMProviderResponse\n  References: LLMProvider.hs:299, LLMProvider.hs:313, LLMProvider.hs:342, Interpreter.hs:254, Interpreter.hs:278, Interpreter.hs:284\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I query user info with explicit error handling?\nSymbol: GetUserTry\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: GetUserTry :: Habitica (Either HabiticaError UserInfo)\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetUserTry, Habitica, HabiticaError, UserInfo\n  References: Habitica.hs:78, Habitica.hs:120, Habitica.hs:165\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetUserTry,Habitica<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When can I assume user fetch always succeeds?\nSymbol: getUserTry\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: getUserTry :: forall (effs :: [Type -> Type]). Member Habitica effs => Eff effs (Either HabiticaError UserInfo)\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: HabiticaError, UserInfo\n  References: Habitica.hs:19, Habitica.hs:119, Habitica.hs:120\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform AsHandler into Run?\nSymbol: runGraphFromWithSpans\nModule: Tidepool.Graph.Interpret.Instrumented\nPackage: tidepool-core\nSignature: runGraphFromWithSpans :: forall (name :: Symbol) (graph :: Type -> Type) entryType (targets :: [Type]) exitType (es :: [Effect]) handler. (KnownSymbol name, HasField name (graph (AsHandler es)) handler, CallHandler handler entryType es targets, DispatchGotoTraced graph targets es exitType, Member Observability es) => graph (AsHandler es) -> entryType -> Eff es exitType Run a graph from a named handler with span emission. result <- runGraphFromWithSpans @\"compute\" handlers inputValue\n\nCandidates:\n  Fields: (none)\n  Inputs: AsHandler\n  Output: Run\n  References: Instrumented.hs:45, Instrumented.hs:134, Instrumented.hs:142, Instrumented.hs:153\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>AsHandler<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I access the input value for this node?\nSymbol: GetNodeInput\nModule: Tidepool.Effect.GraphContext\nPackage: tidepool-core\nSignature: GetNodeInput :: forall {k} (input :: k). NodeInput input input Get the input value for this node invocation.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetNodeInput, NodeInput, Get\n  References: GraphContext.hs:129, GraphContext.hs:165, GraphContext.hs:206\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetNodeInput,NodeInput<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I convert camelCase to snake_case?\nSymbol: camelToSnake\nModule: Tidepool.Effect.Session\nPackage: tidepool-core\nSignature: camelToSnake :: ShowS\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: ShowS\n  References: Session.hs:193, Session.hs:222, Session.hs:247, Session.hs:271, Session.hs:292, Session.hs:293\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>ShowS<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform GetFieldGotoTargetNames and Type into Symbol or Goto?\nSymbol: GetFieldGotoTargetNames\nModule: Tidepool.Graph.Validate.RecordStructure\nPackage: tidepool-core\nSignature: GetFieldGotoTargetNames :: Type -> [Symbol] Get Goto target names from a field definition.\n\nCandidates:\n  Fields: (none)\n  Inputs: GetFieldGotoTargetNames, Type\n  Output: Symbol, Get, Goto\n  References: RecordStructure.hs:357, RecordStructure.hs:360, RecordStructure.hs:361, RecordStructure.hs:362\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetFieldGotoTargetNames,Type,Symbol<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Definition and DefinitionLink and Null into Location?\nSymbol: fromDefinitionResult\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromDefinitionResult :: (Definition |? ([DefinitionLink] |? Null)) -> [Location]\n\nCandidates:\n  Fields: (none)\n  Inputs: Definition, DefinitionLink, Null\n  Output: Location\n  References: Interpreter.hs:208, Interpreter.hs:330, Interpreter.hs:331\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Definition,DefinitionLink,Location<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I convert JSONSchema to a JSONSchema?\nSymbol: arraySchema\nModule: Tidepool.Schema\nPackage: tidepool-core\nSignature: arraySchema :: JSONSchema -> JSONSchema Array schema combinator\n\nCandidates:\n  Fields: (none)\n  Inputs: JSONSchema\n  Output: JSONSchema\n  References: Schema.hs:18, Schema.hs:88, Schema.hs:89, Schema.hs:205, Instances.hs:30, Instances.hs:112, Instances.hs:132, Instances.hs:140, Instances.hs:154, Types.hs:60, Types.hs:186, Types.hs:48, Types.hs:210\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>JSONSchema<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming FilePath into CabalResult or Clean or Useful?\nSymbol: cabalClean\nModule: Tidepool.Effects.Cabal\nPackage: tidepool-core\nSignature: cabalClean :: forall (effs :: [Type -> Type]). Member Cabal effs => FilePath -> Eff effs CabalResult Clean build artifacts. Useful before a fresh build or to reclaim disk space.\n\nCandidates:\n  Fields: (none)\n  Inputs: FilePath\n  Output: CabalResult, Clean, Useful\n  References: Cabal.hs:38, Cabal.hs:202, Cabal.hs:206\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When should I let user errors propagate?\nSymbol: GetUserTry\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: GetUserTry :: Habitica (Either HabiticaError UserInfo)\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetUserTry, Habitica, HabiticaError, UserInfo\n  References: Habitica.hs:78, Habitica.hs:120, Habitica.hs:165\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Location into Location?\nSymbol: fromLocation\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromLocation :: Location -> Location\n\nCandidates:\n  Fields: (none)\n  Inputs: Location\n  Output: Location\n  References: Interpreter.hs:201, Interpreter.hs:301, Interpreter.hs:302, Interpreter.hs:339, Interpreter.hs:340, Interpreter.hs:457, Interpreter.hs:471\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Location<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming ToolInfo into Value?\nSymbol: toolInfoToJSON\nModule: Tidepool.Graph.Tool\nPackage: tidepool-core\nSignature: toolInfoToJSON :: ToolInfo -> Value\n\nCandidates:\n  Fields: (none)\n  Inputs: ToolInfo\n  Output: Value\n  References: Tool.hs:72, Tool.hs:231, Tool.hs:232, Graph.hs:207\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform CompletionItemKind into CompletionItemKind?\nSymbol: fromCompletionItemKind\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromCompletionItemKind :: CompletionItemKind -> CompletionItemKind\n\nCandidates:\n  Fields: (none)\n  Inputs: CompletionItemKind\n  Output: CompletionItemKind\n  References: Interpreter.hs:406, Interpreter.hs:417, Interpreter.hs:418\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>CompletionItemKind<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform CabalBuildFailure into CabalResult?\nSymbol: CabalBuildFailure\nModule: Tidepool.Effects.Cabal\nPackage: tidepool-core\nSignature: CabalBuildFailure :: Int %1 -> Text %1 -> Text %1 -> CabalResult\n\nCandidates:\n  Fields: (none)\n  Inputs: CabalBuildFailure\n  Output: CabalResult\n  References: Cabal.hs:106, Cabal.hs:107, Cabal.hs:109, Cabal.hs:111, Cabal.hs:143, Cabal.hs:152, Cabal.hs:160\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>CabalBuildFailure,CabalResult<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When should I pass data through inputs instead of memory?\nSymbol: GetMem\nModule: Tidepool.Graph.Memory\nPackage: tidepool-core\nSignature: GetMem :: forall s. Memory s s Get the current memory value.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetMem, Memory, Get\n  References: Memory.hs:121, Memory.hs:135, Memory.hs:206\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming GetChildren into BD or BeadInfo?\nSymbol: GetChildren\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: GetChildren :: Text %1 -> BD [BeadInfo] Get child beads (beads with this as parent).\n\nCandidates:\n  Fields: (none)\n  Inputs: GetChildren\n  Output: BD, BeadInfo, Get\n  References: BD.hs:334, BD.hs:390\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I block-wait to receive a message from a mailbox?\nSymbol: receive\nModule: Tidepool.Actor.Mailbox\nPackage: tidepool-actor\nSignature: receive :: forall msg. Mailbox msg -> IO msg Receive a message from a mailbox. Blocks until a message is available.\n\nCandidates:\n  Fields: (none)\n  Inputs: Mailbox\n  Output: Receive, Blocks\n  References: Mailbox.hs:12, Mailbox.hs:42, Mailbox.hs:43, Spawn.hs:23, Spawn.hs:67\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Mailbox<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What makes an edge implicit instead?\nSymbol: RuntimeExplicit\nModule: Tidepool.Graph.Reify\nPackage: tidepool-core\nSignature: RuntimeExplicit\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: RuntimeExplicit\n  References: Reify.hs:207, Reify.hs:863, Reify.hs:874, Export.hs:289\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Value into ParseDiagnostic or Generic?\nSymbol: typeMismatch\nModule: Tidepool.StructuredOutput.Error\nPackage: tidepool-core\nSignature: typeMismatch :: [Text] -> Text -> Value -> ParseDiagnostic Generic type mismatch error.\n\nCandidates:\n  Fields: (none)\n  Inputs: Value\n  Output: ParseDiagnostic, Generic\n  References: Error.hs:19, Error.hs:99, Error.hs:100, Generic.hs:38, Generic.hs:377, Generic.hs:385, Generic.hs:386, Generic.hs:400, Instances.hs:46, Instances.hs:72, Instances.hs:81, Instances.hs:145, Instances.hs:161\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Value,ParseDiagnostic,Generic<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform EffectSemantics into EffectSemantics?\nSymbol: semanticsToText\nModule: Tidepool.Effect.Metadata\nPackage: tidepool-core\nSignature: semanticsToText :: EffectSemantics -> Text Convert EffectSemantics to Text for codegen.\n\nCandidates:\n  Fields: (none)\n  Inputs: EffectSemantics\n  Output: Convert, EffectSemantics\n  References: Metadata.hs:29, Metadata.hs:114, Metadata.hs:115, Metadata.hs:116\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>EffectSemantics<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Type into NodeInput or Each?\nSymbol: runNodeInput\nModule: Tidepool.Effect.GraphContext\nPackage: tidepool-core\nSignature: runNodeInput :: forall input (effs :: [Type -> Type]) a. input -> Eff (NodeInput input : effs) a -> Eff effs a Run NodeInput effect with a fixed input value. Typically provided by the dispatcher when calling a handler. Each node invocation wraps the handler in `runNodeInput` . -- In dispatcher runNodeInput implInput $ do (exit, sid) <- runLLMNode ... implAfter (exit, sid) -- can now call getNodeInput\n\nCandidates:\n  Fields: (none)\n  Inputs: Type\n  Output: Run, NodeInput, Typically, Each, In\n  References: GraphContext.hs:60, GraphContext.hs:201, GraphContext.hs:205\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform JSONSchema into Check?\nSymbol: allNullary\nModule: Tidepool.StructuredOutput.Generic\nPackage: tidepool-core\nSignature: allNullary :: [(String, JSONSchema)] -> Bool Check if all variants have empty contents (nullary constructors). For example, `data Priority = Low | Medium | High` has all nullary constructors.\n\nCandidates:\n  Fields: (none)\n  Inputs: JSONSchema\n  Output: Check, For, Priority, Low, Medium, High\n  References: Generic.hs:302, Generic.hs:303, Generic.hs:336, Generic.hs:360, Generic.hs:376, Generic.hs:397\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>JSONSchema<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Value into ParseDiagnostic?\nSymbol: expectedString\nModule: Tidepool.StructuredOutput.Error\nPackage: tidepool-core\nSignature: expectedString :: [Text] -> Value -> ParseDiagnostic Error for when a string was expected.\n\nCandidates:\n  Fields: (none)\n  Inputs: Value\n  Output: ParseDiagnostic, Error\n  References: Error.hs:15, Error.hs:58, Error.hs:59, Instances.hs:42, Instances.hs:58, Instances.hs:64\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I wrap graph execution in an observability span?\nSymbol: withGraphSpan\nModule: Tidepool.Graph.Interpret.Instrumented\nPackage: tidepool-core\nSignature: withGraphSpan :: forall (es :: [Type -> Type]) a. Member Observability es => Text -> Eff es a -> Eff es a Wrap a graph execution with a root span. Creates a server span that contains all node spans as children. Use this when you want explicit control over the root span name. result <- withGraphSpan \"my-agent:handle-request\" $ do runGraphWithSpans handlers input\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Wrap, Creates, Use\n  References: Instrumented.hs:46, Instrumented.hs:244, Instrumented.hs:249\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Wrap<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform CodeActionKind into CodeActionKind?\nSymbol: fromCodeActionKind\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromCodeActionKind :: CodeActionKind -> CodeActionKind\n\nCandidates:\n  Fields: (none)\n  Inputs: CodeActionKind\n  Output: CodeActionKind\n  References: Interpreter.hs:363, Interpreter.hs:368, Interpreter.hs:369\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>CodeActionKind<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform TextDocumentIdentifier into TextDocumentIdentifier?\nSymbol: toTextDocumentId\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: toTextDocumentId :: TextDocumentIdentifier -> TextDocumentIdentifier\n\nCandidates:\n  Fields: (none)\n  Inputs: TextDocumentIdentifier\n  Output: TextDocumentIdentifier\n  References: Interpreter.hs:188, Interpreter.hs:204, Interpreter.hs:211, Interpreter.hs:218, Interpreter.hs:234, Interpreter.hs:267, Interpreter.hs:268\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>TextDocumentIdentifier<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Parser and GraphEntryType and AsHandler into LLM/IO or Example or CLI\"?\nSymbol: runGraphCLIPure\nModule: Tidepool.Graph.CLI\nPackage: tidepool-core\nSignature: runGraphCLIPure :: forall (graph :: Type -> Type) (entryHandlerName :: Symbol) handler (targets :: [Type]). (Show (GraphExitType graph), ToJSON (GraphExitType graph), Generic (graph AsGraph), FindEntryHandler (GraphEntryType graph) (FieldsWithNamesOf graph) ~ 'Just entryHandlerName, KnownSymbol entryHandlerName, HasField entryHandlerName (graph (AsHandler '[])) handler, CallHandler handler (GraphEntryType graph) '[] targets, DispatchGoto graph targets '[] (GraphExitType graph)) => Text -> Parser (GraphEntryType graph) -> graph (AsHandler '[]) -> IO () Run a logic-only graph (no LLM/IO effects) as CLI. This wires a graph with empty effect stack `'[]` directly to CLI. For graphs with LLM/IO effects, use `runGraphCLI` from tidepool-platform. # Example main :: IO () main = runGraphCLIPure \"Counter graph CLI\" $(deriveCLIParser ''CounterInput) counterHandlers # Constraints The graph must: + Have `EntryNode` and `Exit` fields (detected via `GraphEntryType` and `GraphExitType` ) + Have a handler that accepts the entry type via `Needs` (found via `FindEntryHandler` ) + Use empty effect stack `'[]` (all handlers must be pure) + Exit type must have `Show` and `ToJSON` instances for output formatting\n\nCandidates:\n  Fields: (none)\n  Inputs: Parser, GraphEntryType, AsHandler\n  Output: Run, LLM/IO, CLI., This, For, Example, CLI\", Constraints, The, Have, EntryNode, Exit, GraphEntryType, GraphExitType, Needs, FindEntryHandler, Use, Show, ToJSON\n  References: CLI.hs:75, CLI.hs:513, CLI.hs:528\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform MermaidConfig and NodeInfo into Render?\nSymbol: renderNode\nModule: Tidepool.Graph.Mermaid\nPackage: tidepool-core\nSignature: renderNode :: MermaidConfig -> NodeInfo -> Text Render a single node declaration.\n\nCandidates:\n  Fields: (none)\n  Inputs: MermaidConfig, NodeInfo\n  Output: Render\n  References: Mermaid.hs:171, Mermaid.hs:237, Mermaid.hs:238\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>MermaidConfig,NodeInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I do to skip initializing an empty TeachingDoc?\nSymbol: emptyDoc\nModule: Tidepool.Control.Scout.Teach\nPackage: tidepool-control-server\nSignature: emptyDoc :: TeachQuery -> TeachingDoc\n\nCandidates:\n  Fields: (none)\n  Inputs: TeachQuery\n  Output: TeachingDoc\n  References: Teach.hs:119, Teach.hs:393, Teach.hs:394\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is a ClaudeCode subprocess node?\nSymbol: RuntimeClaudeCode\nModule: Tidepool.Graph.Reify\nPackage: tidepool-core\nSignature: RuntimeClaudeCode :: RuntimeNodeKind Claude Code subprocess\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: RuntimeClaudeCode, RuntimeNodeKind, Claude, Code\n  References: Reify.hs:198, Reify.hs:761, Mermaid.hs:187, Mermaid.hs:246, Mermaid.hs:254, Mermaid.hs:415, Export.hs:281\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>RuntimeClaudeCode,RuntimeNodeKind<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When should I ignore bead dependencies?\nSymbol: getDeps\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: getDeps :: forall (effs :: [Type -> Type]). Member BD effs => Text -> Eff effs [BeadInfo] Get dependencies (beads this one depends on).\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: BeadInfo, Get\n  References: BD.hs:36, BD.hs:377, BD.hs:378\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming CabalTest and FilePath into Cabal or CabalResult or Equivalent?\nSymbol: CabalTest\nModule: Tidepool.Effects.Cabal\nPackage: tidepool-core\nSignature: CabalTest :: FilePath %1 -> Cabal CabalResult Run tests. Equivalent to `cabal test --test-show-details=always` . Returns `CabalTestSuccess` or `CabalTestFailure` with parsed failures. Returns `CabalBuildFailure` if build fails.\n\nCandidates:\n  Fields: (none)\n  Inputs: CabalTest, FilePath\n  Output: Cabal, CabalResult, Run, Equivalent, Returns, CabalTestSuccess, CabalTestFailure, CabalBuildFailure\n  References: Cabal.hs:153, Cabal.hs:197\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to FilePath and CabalResult and Run and CabalTestSuccess and CabalTestFailure and CabalBuildFailure?\nSymbol: cabalTest\nModule: Tidepool.Effects.Cabal\nPackage: tidepool-core\nSignature: cabalTest :: forall (effs :: [Type -> Type]). Member Cabal effs => FilePath -> Eff effs CabalResult Run tests with detailed output. result <- cabalTest \" *path* to/project\" case result of CabalTestSuccess output -> logSuccess output CabalTestFailure failures _ -> fixImplementation failures CabalBuildFailure _ stderr _ -> fixCompilation stderr\n\nCandidates:\n  Fields: (none)\n  Inputs: FilePath, CabalResult, Run, CabalTestSuccess, CabalTestFailure, CabalBuildFailure\n  Output: (none)\n  References: Cabal.hs:37, Cabal.hs:193, Cabal.hs:197\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I find include directives in a Jinja template?\nSymbol: parseTemplateIncludes\nModule: Tidepool.Template.DependencyTree\nPackage: tidepool-core\nSignature: parseTemplateIncludes :: Text -> [FilePath] Parse a template for {% include \"...\" %} directives. Returns a list of included template paths. parseTemplateIncludes \"{% include \"_shared/context.jinja\" %}\" == [\"_shared/context.jinja\"]\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: FilePath, Parse, Returns\n  References: DependencyTree.hs:32, DependencyTree.hs:209, DependencyTree.hs:210, DependencyTree.hs:229\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>FilePath,Parse<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming MermaidConfig and NodeInfo into Render?\nSymbol: renderState\nModule: Tidepool.Graph.Mermaid\nPackage: tidepool-core\nSignature: renderState :: MermaidConfig -> NodeInfo -> Text Render a state definition.\n\nCandidates:\n  Fields: (none)\n  Inputs: MermaidConfig, NodeInfo\n  Output: Render\n  References: Mermaid.hs:404, Mermaid.hs:407, Mermaid.hs:408\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When should I let user errors propagate?\nSymbol: GetUserTry\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: GetUserTry :: Habitica (Either HabiticaError UserInfo)\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetUserTry, Habitica, HabiticaError, UserInfo\n  References: Habitica.hs:78, Habitica.hs:120, Habitica.hs:165\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming TypedTemplate and SourcePos and TypedTemplate and SourcePos and GotoChoice into GotoChoice or LLMBoth or LLM?\nSymbol: executeLLMHandler\nModule: Tidepool.Graph.Interpret\nPackage: tidepool-core\nSignature: executeLLMHandler :: forall needs schema (targets :: [Type]) (es :: [Type -> Type]) tpl. (Member LLM es, StructuredOutput schema, ValidStructuredOutput schema, GingerContext tpl, ConvertTransitionHint targets) => Maybe (TypedTemplate tpl SourcePos) -> TypedTemplate tpl SourcePos -> (needs -> Eff es tpl) -> (schema -> Eff es (GotoChoice targets)) -> needs -> Eff es (GotoChoice targets) Execute an LLMBoth handler, returning a GotoChoice. This function: 1. Calls the before-handler to build template context 2. Renders the system template (if provided) and user template 3. Calls the LLM effect with rendered prompts and JSON schema 4. Parses the structured output 5. Calls the after-handler to determine the next transition # Type Parameters + `needs` - The input type from Needs annotation + `schema` - The LLM output schema type + `targets` - The transition targets from UsesEffects + `es` - The effect stack (must include LLM) + `tpl` - The template context type # Example result <- executeLLMHandler Nothing -- no system template userTemplate -- user prompt template (\\input -> pure MyContext {...}) -- build context (\\output -> pure (gotoExit output)) -- route based on output inputValue\n\nCandidates:\n  Fields: (none)\n  Inputs: TypedTemplate, SourcePos, TypedTemplate, SourcePos, GotoChoice\n  Output: GotoChoice, Execute, LLMBoth, GotoChoice., This, Calls, Renders, LLM, JSON, Parses, Type, Parameters, The, Needs, UsesEffects, Example, Nothing, MyContext\n  References: Interpret.hs:39, Interpret.hs:259, Interpret.hs:273, Interpret.hs:298, Interpret.hs:535, Instrumented.hs:55\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to TemplateDependency and Render and Output?\nSymbol: renderDepTreeCompact\nModule: Tidepool.Graph.Docs\nPackage: tidepool-core\nSignature: renderDepTreeCompact :: TemplateDependency -> Text Render a compact single-line representation. Output example: `main.jinja -> header.jinja, footer.jinja`\n\nCandidates:\n  Fields: (none)\n  Inputs: TemplateDependency, Render, Output\n  Output: (none)\n  References: Docs.hs:37, Docs.hs:105, Docs.hs:106, Graph.hs:125\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform AsHandler into Run?\nSymbol: runGraphWithSpans\nModule: Tidepool.Graph.Interpret.Instrumented\nPackage: tidepool-core\nSignature: runGraphWithSpans :: forall (graph :: Type -> Type) entryType (targets :: [Type]) exitType (es :: [Effect]) (entryHandlerName :: Symbol) handler. (Generic (graph AsGraph), FindEntryHandler entryType (FieldsWithNamesOf graph) ~ 'Just entryHandlerName, KnownSymbol entryHandlerName, HasField entryHandlerName (graph (AsHandler es)) handler, CallHandler handler entryType es targets, DispatchGotoTraced graph targets es exitType, Member Observability es) => graph (AsHandler es) -> entryType -> Eff es exitType Run a graph with automatic span emission for each node transition. Creates a root span for the graph and child spans for each handler invocation. result <- runGraphWithSpans @MyGraph handlers inputValue\n\nCandidates:\n  Fields: (none)\n  Inputs: AsHandler\n  Output: Run, Creates\n  References: Instrumented.hs:44, Instrumented.hs:121, Instrumented.hs:134\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>AsHandler<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming RunTurnOp and ContentBlock and Value and Value into LLM or TurnOutcome or TurnResult?\nSymbol: RunTurnOp\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: RunTurnOp :: Text %1 -> [ContentBlock] %1 -> Value %1 -> [Value] %1 -> LLM (TurnOutcome (TurnResult Value))\n\nCandidates:\n  Fields: (none)\n  Inputs: RunTurnOp, ContentBlock, Value, Value\n  Output: LLM, TurnOutcome, TurnResult, Value\n  References: Types.hs:211, Types.hs:397\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I access node-private memory during graph execution?\nSymbol: GetMemory\nModule: Tidepool.Graph.Edges\nPackage: tidepool-core\nSignature: GetMemory\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetMemory\n  References: Edges.hs:21, Edges.hs:207, Edges.hs:208, Edges.hs:209, Edges.hs:210, Edges.hs:210, Edges.hs:211, Reify.hs:94, Reify.hs:753, Reify.hs:775, Reify.hs:784, Reify.hs:800, Reify.hs:749, Reify.hs:758, Reify.hs:783, Reify.hs:788, Graph.hs:191\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetMemory<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming EdgeType into PatternMatchSite?\nSymbol: extractPatterns\nModule: Tidepool.Control.Scout.EdgeTypes\nPackage: tidepool-control-server\nSignature: extractPatterns :: EdgeType -> Text -> Maybe [Text] Extract pattern cases from snippet for PatternMatchSite edges.\n\nCandidates:\n  Fields: (none)\n  Inputs: EdgeType\n  Output: Extract, PatternMatchSite\n  References: EdgeTypes.hs:150, EdgeTypes.hs:174, EdgeTypes.hs:175, EdgeTypes.hs:179\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Name into UsesOneOf?\nSymbol: deriveUsesOneOf\nModule: Tidepool.Schema\nPackage: tidepool-core\nSignature: deriveUsesOneOf :: Name -> Q [Dec] Derive a `UsesOneOf` instance for a type.\n\nCandidates:\n  Fields: (none)\n  Inputs: Name\n  Output: Dec, Derive, UsesOneOf\n  References: Schema.hs:39, Schema.hs:255, Schema.hs:256\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Value into Describe?\nSymbol: describeValue\nModule: Tidepool.StructuredOutput.Error\nPackage: tidepool-core\nSignature: describeValue :: Value -> Text Describe a JSON value for error messages. Truncates long strings and summarizes structures.\n\nCandidates:\n  Fields: (none)\n  Inputs: Value\n  Output: Describe, JSON, Truncates\n  References: Error.hs:23, Error.hs:44, Error.hs:45, Error.hs:53, Error.hs:54, Error.hs:62, Error.hs:63, Error.hs:71, Error.hs:72, Error.hs:80, Error.hs:81, Error.hs:104, Error.hs:105, Error.hs:126, Error.hs:127\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if I need to work without bead lookups?\nSymbol: getBead\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: getBead :: forall (effs :: [Type -> Type]). Member BD effs => Text -> Eff effs (Maybe BeadInfo) Get bead info by ID.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: BeadInfo, Get, ID.\n  References: BD.hs:35, BD.hs:373, BD.hs:374\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I create a bead update record with no field modifications?\nSymbol: emptyUpdateInput\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: emptyUpdateInput :: UpdateBeadInput\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: UpdateBeadInput\n  References: BD.hs:57, BD.hs:302, BD.hs:303\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>UpdateBeadInput<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform WorkspaceEdit into WorkspaceEdit?\nSymbol: fromWorkspaceEditResult\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromWorkspaceEditResult :: WorkspaceEdit -> WorkspaceEdit\n\nCandidates:\n  Fields: (none)\n  Inputs: WorkspaceEdit\n  Output: WorkspaceEdit\n  References: Interpreter.hs:229, Interpreter.hs:383, Interpreter.hs:384\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>WorkspaceEdit<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if I need to ignore working directory state?\nSymbol: getDirtyFiles\nModule: Tidepool.Effects.Git\nPackage: tidepool-core\nSignature: getDirtyFiles :: forall (effs :: [Type -> Type]). Member Git effs => Eff effs [FilePath] Get list of dirty files.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: FilePath, Get\n  References: Git.hs:21, Git.hs:105, Git.hs:106\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I do to prevent sending messages to mailboxes?\nSymbol: send\nModule: Tidepool.Actor.Mailbox\nPackage: tidepool-actor\nSignature: send :: forall msg. Mailbox msg -> msg -> IO () Send a message to a mailbox. Non-blocking, always succeeds (unbounded queue).\n\nCandidates:\n  Fields: (none)\n  Inputs: Mailbox\n  Output: Send, Non-blocking\n  References: Mailbox.hs:11, Mailbox.hs:36, Mailbox.hs:37, Runtime.hs:19, Runtime.hs:89, Graph.hs:98, Graph.hs:341, Graph.hs:350, Graph.hs:366\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming AsHandler into Run?\nSymbol: runGraphWithSpans\nModule: Tidepool.Graph.Interpret.Instrumented\nPackage: tidepool-core\nSignature: runGraphWithSpans :: forall (graph :: Type -> Type) entryType (targets :: [Type]) exitType (es :: [Effect]) (entryHandlerName :: Symbol) handler. (Generic (graph AsGraph), FindEntryHandler entryType (FieldsWithNamesOf graph) ~ 'Just entryHandlerName, KnownSymbol entryHandlerName, HasField entryHandlerName (graph (AsHandler es)) handler, CallHandler handler entryType es targets, DispatchGotoTraced graph targets es exitType, Member Observability es) => graph (AsHandler es) -> entryType -> Eff es exitType Run a graph with automatic span emission for each node transition. Creates a root span for the graph and child spans for each handler invocation. result <- runGraphWithSpans @MyGraph handlers inputValue\n\nCandidates:\n  Fields: (none)\n  Inputs: AsHandler\n  Output: Run, Creates\n  References: Instrumented.hs:44, Instrumented.hs:121, Instrumented.hs:134\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform ScoringContext into Render?\nSymbol: renderConstraints\nModule: Tidepool.Control.Scout.Templates\nPackage: tidepool-control-server\nSignature: renderConstraints :: ScoringContext -> Text Render constraints section if present.\n\nCandidates:\n  Fields: (none)\n  Inputs: ScoringContext\n  Output: Render\n  References: Templates.hs:94, Templates.hs:111, Templates.hs:112\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>ScoringContext<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Type into Useful?\nSymbol: evalMemory\nModule: Tidepool.Graph.Memory\nPackage: tidepool-core\nSignature: evalMemory :: forall s (effs :: [Type -> Type]) a. s -> Eff (Memory s : effs) a -> Eff effs a Run memory effect purely, returning only the result. Useful when you don't need the final state.\n\nCandidates:\n  Fields: (none)\n  Inputs: Type\n  Output: Run, Useful\n  References: Memory.hs:78, Memory.hs:212, Memory.hs:213, Memory.hs:217, Memory.hs:219, Graph.hs:102\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming SymbolInformation and WorkspaceSymbol and Null into SymbolInformation?\nSymbol: fromSymbolsResult\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromSymbolsResult :: ([SymbolInformation] |? ([WorkspaceSymbol] |? Null)) -> [SymbolInformation]\n\nCandidates:\n  Fields: (none)\n  Inputs: SymbolInformation, WorkspaceSymbol, Null\n  Output: SymbolInformation\n  References: Interpreter.hs:250, Interpreter.hs:446, Interpreter.hs:447\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform RetryConfig into RetryResult?\nSymbol: withRetry\nModule: Tidepool.Actor.Retry\nPackage: tidepool-actor\nSignature: withRetry :: forall a. RetryConfig -> IO a -> IO (RetryResult a)\n\nCandidates:\n  Fields: (none)\n  Inputs: RetryConfig\n  Output: RetryResult\n  References: Retry.hs:16, Retry.hs:84, Retry.hs:85, Dispatch.hs:39, Dispatch.hs:158\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>RetryConfig,RetryResult<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming NodeInfo into LLM?\nSymbol: renderNodeComments\nModule: Tidepool.Graph.Mermaid\nPackage: tidepool-core\nSignature: renderNodeComments :: NodeInfo -> [Text] Render structured comments for a node (for LLM context).\n\nCandidates:\n  Fields: (none)\n  Inputs: NodeInfo\n  Output: Render, LLM\n  References: Mermaid.hs:169, Mermaid.hs:174, Mermaid.hs:175\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if symbols are already tokenized?\nSymbol: parseSymbolTokens\nModule: Tidepool.Control.Scout.Teach.Gemma\nPackage: tidepool-control-server\nSignature: parseSymbolTokens :: Text -> [Text] Parse symbol tokens from a space/comma separated string. Handles various formats: \"ScoreConfig Rubric EdgeContext\" \"ScoreConfig, Rubric, EdgeContext\" \"ScoreConfig,Rubric,EdgeContext\"\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Parse, Handles, Rubric, EdgeContext\"\n  References: Gemma.hs:42, Gemma.hs:350, Gemma.hs:351\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When is worktree info irrelevant?\nSymbol: getWorktreeInfo\nModule: Tidepool.Effects.Git\nPackage: tidepool-core\nSignature: getWorktreeInfo :: forall (effs :: [Type -> Type]). Member Git effs => Eff effs (Maybe WorktreeInfo) Get worktree/repo information.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: WorktreeInfo, Get\n  References: Git.hs:20, Git.hs:101, Git.hs:102\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if time should be injected as input?\nSymbol: GetCurrentTime\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: GetCurrentTime :: Time UTCTime\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetCurrentTime, Time, UTCTime\n  References: Types.hs:196, Types.hs:199, Types.hs:203\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming CompleteTry and LLMProvider. and SProvider and LLMProviderConfig and Value into LLMComplete or LLMError or LLMProviderResponse?\nSymbol: CompleteTry\nModule: Tidepool.Effects.LLMProvider\nPackage: tidepool-core\nSignature: CompleteTry :: forall (p :: LLMProvider). SProvider p %1 -> LLMProviderConfig p %1 -> Text %1 -> Maybe [Value] %1 -> LLMComplete (Either LLMError (LLMProviderResponse p))\n\nCandidates:\n  Fields: (none)\n  Inputs: CompleteTry, LLMProvider., SProvider, LLMProviderConfig, Value\n  Output: LLMComplete, LLMError, LLMProviderResponse\n  References: LLMProvider.hs:300, LLMProvider.hs:320, LLMProvider.hs:364, Interpreter.hs:255, Interpreter.hs:291, Interpreter.hs:294\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I get repository and worktree metadata?\nSymbol: GetWorktreeInfo\nModule: Tidepool.Effects.Git\nPackage: tidepool-core\nSignature: GetWorktreeInfo :: Git (Maybe WorktreeInfo) Get worktree/repo information. Returns Nothing if not in a git repository.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetWorktreeInfo, Git, WorktreeInfo, Get, Returns, Nothing\n  References: Git.hs:84, Git.hs:102\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetWorktreeInfo,Git<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I convert a tool definition to Anthropic API format?\nSymbol: ToAnthropicTool\nModule: Tidepool.Tool.Convert\nPackage: tidepool-core\nSignature: $p1ToAnthropicTool :: forall t. ToAnthropicTool t => ToolDef t\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: ToolDef\n  References: Convert.hs:87, Convert.hs:91\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>ToolDef<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming MemoryStore into Nothing' or Left or Type?\nSymbol: getScope\nModule: Tidepool.Graph.Memory\nPackage: tidepool-core\nSignature: getScope :: forall s. FromJSON s => Text -> MemoryStore -> Either Text (Maybe s) Get a scope from the store, deserializing to the expected type. Returns 'Right Nothing' if the scope doesn't exist. Returns `Left` error if deserialization fails (type mismatch). Type safety is enforced by the `FromJSON` constraint - if the stored JSON doesn't match the expected type, parsing will fail with an error.\n\nCandidates:\n  Fields: (none)\n  Inputs: MemoryStore\n  Output: Get, Returns, Nothing', Left, Type, FromJSON, JSON\n  References: Memory.hs:89, Memory.hs:279, Memory.hs:364, Memory.hs:394, Memory.hs:399, Memory.hs:410, Memory.hs:428, Memory.hs:444\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform GetChildren into BD or BeadInfo?\nSymbol: GetChildren\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: GetChildren :: Text %1 -> BD [BeadInfo] Get child beads (beads with this as parent).\n\nCandidates:\n  Fields: (none)\n  Inputs: GetChildren\n  Output: BD, BeadInfo, Get\n  References: BD.hs:334, BD.hs:390\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetChildren,BD,BeadInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming ScoringContext into Render?\nSymbol: renderTypeInfo\nModule: Tidepool.Control.Scout.Templates\nPackage: tidepool-control-server\nSignature: renderTypeInfo :: ScoringContext -> Text Render type info section if present.\n\nCandidates:\n  Fields: (none)\n  Inputs: ScoringContext\n  Output: Render\n  References: Templates.hs:92, Templates.hs:99, Templates.hs:100\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming GetGotoTargetsFromMaybeEffects and Effect into Symbol or Type or Goto?\nSymbol: GetGotoTargetsFromMaybeEffects\nModule: Tidepool.Graph.Validate.RecordStructure\nPackage: tidepool-core\nSignature: GetGotoTargetsFromMaybeEffects :: Maybe [Effect] -> [(Symbol, Type)] Get Goto targets from Maybe effect list.\n\nCandidates:\n  Fields: (none)\n  Inputs: GetGotoTargetsFromMaybeEffects, Effect\n  Output: Symbol, Type, Get, Goto\n  References: RecordStructure.hs:426, RecordStructure.hs:429, RecordStructure.hs:430, RecordStructure.hs:431, RecordStructure.hs:432\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform GetBarrierTargetOrError and Symbol and Type into Symbol?\nSymbol: GetBarrierTargetOrError\nModule: Tidepool.Graph.Validate.ForkBarrier\nPackage: tidepool-core\nSignature: GetBarrierTargetOrError :: Symbol -> Type -> Symbol Get barrier target or produce error.\n\nCandidates:\n  Fields: (none)\n  Inputs: GetBarrierTargetOrError, Symbol, Type\n  Output: Symbol, Get\n  References: ForkBarrier.hs:146, ForkBarrier.hs:152, ForkBarrier.hs:153, ForkBarrier.hs:154\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetBarrierTargetOrError,Symbol<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I check for pending child subgraph results?\nSymbol: getPending\nModule: Tidepool.Effect.Subgraph\nPackage: tidepool-core\nSignature: getPending :: forall entry result (effs :: [Type -> Type]). Member (Subgraph entry result) effs => Eff effs [ChildHandle] Get handles to all children that haven't completed yet. Useful for tracking progress or implementing custom collection strategies. Usage requires type application to specify both types: pending <- getPending @Spec @V2Result\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: ChildHandle, Get, Useful, Usage\n  References: Subgraph.hs:64, Subgraph.hs:96, Subgraph.hs:44, Subgraph.hs:139, Subgraph.hs:143\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>ChildHandle<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming CabalTestFailure and TestFailure into CabalResult?\nSymbol: CabalTestFailure\nModule: Tidepool.Effects.Cabal\nPackage: tidepool-core\nSignature: CabalTestFailure :: [TestFailure] %1 -> Text %1 -> CabalResult\n\nCandidates:\n  Fields: (none)\n  Inputs: CabalTestFailure, TestFailure\n  Output: CabalResult\n  References: Cabal.hs:115, Cabal.hs:116, Cabal.hs:118, Cabal.hs:151\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform LocationLink into Location?\nSymbol: fromLocationLink\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromLocationLink :: LocationLink -> Location\n\nCandidates:\n  Fields: (none)\n  Inputs: LocationLink\n  Output: Location\n  References: Interpreter.hs:343, Interpreter.hs:345, Interpreter.hs:346\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>LocationLink,Location<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I determine the entry type of a graph?\nSymbol: GetEntryType\nModule: Tidepool.Graph.Validate.RecordStructure\nPackage: tidepool-core\nSignature: GetEntryType\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetEntryType\n  References: RecordStructure.hs:91, RecordStructure.hs:92, RecordStructure.hs:93, RecordStructure.hs:93, RecordStructure.hs:94, RecordStructure.hs:94, RecordStructure.hs:95, RecordStructure.hs:96, RecordStructure.hs:97, RecordStructure.hs:97, RecordStructure.hs:97, RecordStructure.hs:98, RecordStructure.hs:133\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetEntryType<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform CreateBeadInput and BeadType and DependencyType into CreateBeadInput?\nSymbol: CreateBeadInput\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: CreateBeadInput :: Text %1 -> Maybe Text %1 -> BeadType %1 -> Int %1 -> Maybe Text %1 -> [Text] %1 -> Maybe Text %1 -> [(Text, DependencyType)] %1 -> CreateBeadInput\n\nCandidates:\n  Fields: (none)\n  Inputs: CreateBeadInput, BeadType, DependencyType\n  Output: CreateBeadInput\n  References: BD.hs:263, BD.hs:264, BD.hs:265, BD.hs:266, BD.hs:267, BD.hs:268, BD.hs:269, BD.hs:270, BD.hs:271, BD.hs:277\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>CreateBeadInput,BeadType<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if fields are optional?\nSymbol: missingField\nModule: Tidepool.StructuredOutput.Error\nPackage: tidepool-core\nSignature: missingField :: [Text] -> ParseDiagnostic Error for a missing required field.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: ParseDiagnostic, Error\n  References: Error.hs:18, Error.hs:85, Error.hs:86, Generic.hs:38, Generic.hs:183, Generic.hs:387\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform LSPSession and Session into Execute?\nSymbol: executeSession\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: executeSession :: forall a. LSPSession -> Session a -> IO a Execute a Session action via the session handle. Sends the action to the worker, waits for response with timeout.\n\nCandidates:\n  Fields: (none)\n  Inputs: LSPSession, Session\n  Output: Execute, Session, Sends\n  References: Interpreter.hs:158, Interpreter.hs:159, Interpreter.hs:187, Interpreter.hs:194, Interpreter.hs:203, Interpreter.hs:210, Interpreter.hs:217, Interpreter.hs:233, Interpreter.hs:240\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>LSPSession,Session<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to InputHandler?\nSymbol: runRequestInput\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: runRequestInput :: forall (effs :: [Type -> Type]) a. LastMember IO effs => InputHandler -> Eff (RequestInput : effs) a -> Eff effs a\n\nCandidates:\n  Fields: (none)\n  Inputs: InputHandler\n  Output: (none)\n  References: Types.hs:96, Types.hs:629, Types.hs:630\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Range into Range?\nSymbol: fromRange\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromRange :: Range -> Range\n\nCandidates:\n  Fields: (none)\n  Inputs: Range\n  Output: Range\n  References: Interpreter.hs:295, Interpreter.hs:296, Interpreter.hs:304, Interpreter.hs:312, Interpreter.hs:348, Interpreter.hs:399\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform GetArriveBarrierFromMaybeEffects and Effect into Symbol or Arrive?\nSymbol: GetArriveBarrierFromMaybeEffects\nModule: Tidepool.Graph.Validate.ForkBarrier\nPackage: tidepool-core\nSignature: GetArriveBarrierFromMaybeEffects :: Maybe [Effect] -> Maybe Symbol Extract Arrive barrier from Maybe effect list.\n\nCandidates:\n  Fields: (none)\n  Inputs: GetArriveBarrierFromMaybeEffects, Effect\n  Output: Symbol, Extract, Arrive\n  References: ForkBarrier.hs:223, ForkBarrier.hs:226, ForkBarrier.hs:227, ForkBarrier.hs:228, ForkBarrier.hs:229\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetArriveBarrierFromMaybeEffects,Effect,Symbol,Extract<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I query user info with explicit error handling?\nSymbol: GetUserTry\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: GetUserTry :: Habitica (Either HabiticaError UserInfo)\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetUserTry, Habitica, HabiticaError, UserInfo\n  References: Habitica.hs:78, Habitica.hs:120, Habitica.hs:165\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetUserTry,Habitica<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming SchemaType into Schema?\nSymbol: typeToText\nModule: Tidepool.Schema\nPackage: tidepool-core\nSignature: typeToText :: SchemaType -> Text Convert schema type to JSON Schema type string\n\nCandidates:\n  Fields: (none)\n  Inputs: SchemaType\n  Output: Convert, JSON, Schema\n  References: Schema.hs:107, Schema.hs:126, Schema.hs:127\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When should I use relative time instead of absolute?\nSymbol: getCurrentTime\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: getCurrentTime :: forall (effs :: [Type -> Type]). Member Time effs => Eff effs UTCTime\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: UTCTime\n  References: Types.hs:29, Types.hs:198, Types.hs:199\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform NodeInfo into Render?\nSymbol: renderTransitionsComment\nModule: Tidepool.Graph.Mermaid\nPackage: tidepool-core\nSignature: renderTransitionsComment :: NodeInfo -> Text Render transitions comment.\n\nCandidates:\n  Fields: (none)\n  Inputs: NodeInfo\n  Output: Render\n  References: Mermaid.hs:183, Mermaid.hs:228, Mermaid.hs:229\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>NodeInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I trigger a Cabal build in an effect?\nSymbol: cabalBuild\nModule: Tidepool.Effects.Cabal\nPackage: tidepool-core\nSignature: cabalBuild :: forall (effs :: [Type -> Type]). Member Cabal effs => String -> Eff effs CabalResult\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: CabalResult\n  References: Cabal.hs:36, Cabal.hs:178, Cabal.hs:182\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>CabalResult<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I lowercase the first character for camelCase?\nSymbol: lcFirst\nModule: Tidepool.StructuredOutput.Prefix\nPackage: tidepool-core\nSignature: lcFirst :: String -> String Lowercase the first character of a string. lcFirst `TypeName` = \"typeName\" lcFirst `URL` = \"uRL\" lcFirst \"\" = \"\"\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Lowercase, TypeName, URL\n  References: Prefix.hs:23, Prefix.hs:48, Prefix.hs:61, Prefix.hs:71, Prefix.hs:120, Prefix.hs:121, Prefix.hs:122\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>TypeName<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Stack into View?\nSymbol: peek\nModule: Data.Stack\nPackage: tidepool-core\nSignature: peek :: forall a. Stack a -> Maybe a View the top element without removing it. Returns `Nothing` if the stack is empty. The stack is not modified. ### Laws peek empty == Nothing peek (push x s) == Just x peek s == fst <$> pop s (ignores the rest) ### Time Complexity O(1)\n\nCandidates:\n  Fields: (none)\n  Inputs: Stack\n  Output: View, Returns, Nothing, The, Laws, Just, Time, Complexity, O1\n  References: Stack.hs:8, Stack.hs:36, Stack.hs:100, Stack.hs:101\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to MergeAccumulator and HList and FromPayloads and Get and HList. and Returns and Nothing and From and Just and Left and Just and Right and HNil?\nSymbol: getCompletedResults\nModule: Tidepool.Actor.Merge\nPackage: tidepool-actor\nSignature: getCompletedResults :: forall (sources :: [Type]) key. (ExtractMergeResults sources, Hashable key) => MergeAccumulator key -> key -> IO (Maybe (Either Text (HList (FromPayloads sources)))) Get the completed results for a correlation key as a typed HList. Returns `Nothing` if the key doesn't exist or isn't complete. Returns 'Left err' if parsing fails for any result. Returns 'Right hlist' with the typed results in source order. acc <- newMergeAccumulator `'[From \"a\" Int, From \"b\" String] -- ... add results ... result <- getCompletedResults ` '[From \"a\" Int, From \"b\" String] acc key case result of Nothing -> putStrLn \"Not complete yet\" Just (Left err) -> putStrLn $ \"Parse error: \" <> err Just (Right (a ::: b ::: HNil)) -> print (a, b)\n\nCandidates:\n  Fields: (none)\n  Inputs: MergeAccumulator, HList, FromPayloads, Get, HList., Returns, Nothing, From, Just, Left, Just, Right, HNil\n  Output: (none)\n  References: Merge.hs:16, Merge.hs:238, Merge.hs:246, Barrier.hs:57, Barrier.hs:180\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if I need flat bead structures?\nSymbol: getChildren\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: getChildren :: forall (effs :: [Type -> Type]). Member BD effs => Text -> Eff effs [BeadInfo] Get child beads (beads with this as parent).\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: BeadInfo, Get\n  References: BD.hs:39, BD.hs:389, BD.hs:390\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming EdgeType into TypeReference?\nSymbol: extractTypeName\nModule: Tidepool.Control.Scout.EdgeTypes\nPackage: tidepool-control-server\nSignature: extractTypeName :: EdgeType -> Text -> Maybe Text Extract type name from hover for TypeReference edges.\n\nCandidates:\n  Fields: (none)\n  Inputs: EdgeType\n  Output: Extract, TypeReference\n  References: EdgeTypes.hs:148, EdgeTypes.hs:155, EdgeTypes.hs:156, EdgeTypes.hs:163\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming CreateWorktree and WorktreeSpec into Worktree or WorktreeError or WorktreePath?\nSymbol: CreateWorktree\nModule: Tidepool.Effects.Worktree\nPackage: tidepool-core\nSignature: CreateWorktree :: WorktreeSpec %1 -> Worktree (Either WorktreeError WorktreePath) Create a new worktree with a branch. Returns the path to the created worktree, or an error.\n\nCandidates:\n  Fields: (none)\n  Inputs: CreateWorktree, WorktreeSpec\n  Output: Worktree, WorktreeError, WorktreePath, Create, Returns\n  References: Worktree.hs:185, Worktree.hs:232\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if you're validating primitive types instead of objects?\nSymbol: objectSchema\nModule: Tidepool.Schema\nPackage: tidepool-core\nSignature: objectSchema :: [(Text, JSONSchema)] -> [Text] -> JSONSchema Object schema combinator\n\nCandidates:\n  Fields: (none)\n  Inputs: JSONSchema\n  Output: JSONSchema, Object\n  References: Generic.hs:36, Generic.hs:69, Generic.hs:267, Generic.hs:348, Schema.hs:17, Schema.hs:81, Schema.hs:82, Schema.hs:166, DecisionTools.hs:62, DecisionTools.hs:221, Types.hs:60, Types.hs:184, Types.hs:48, Types.hs:208\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When should I avoid spawning child graphs?\nSymbol: GetPending\nModule: Tidepool.Effect.Subgraph\nPackage: tidepool-core\nSignature: GetPending :: forall entry result. Subgraph entry result [ChildHandle] Get handles to children that haven't completed yet.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetPending, Subgraph, ChildHandle, Get\n  References: Subgraph.hs:362, Subgraph.hs:84, Subgraph.hs:143\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming TemplateInfo into Render?\nSymbol: renderTemplateComment\nModule: Tidepool.Graph.Mermaid\nPackage: tidepool-core\nSignature: renderTemplateComment :: Maybe TemplateInfo -> Text Render template comment.\n\nCandidates:\n  Fields: (none)\n  Inputs: TemplateInfo\n  Output: Render\n  References: Mermaid.hs:179, Mermaid.hs:193, Mermaid.hs:194, Mermaid.hs:195\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming GetTasks and TaskType into Habitica or HabiticaTask?\nSymbol: GetTasks\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: GetTasks :: TaskType %1 -> Habitica [HabiticaTask]\n\nCandidates:\n  Fields: (none)\n  Inputs: GetTasks, TaskType\n  Output: Habitica, HabiticaTask\n  References: Habitica.hs:72, Habitica.hs:103, Habitica.hs:151\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming GetArriveBarrierFromEffects and Effect into Symbol or Arrive?\nSymbol: GetArriveBarrierFromEffects\nModule: Tidepool.Graph.Validate.ForkBarrier\nPackage: tidepool-core\nSignature: GetArriveBarrierFromEffects :: [Effect] -> Maybe Symbol Extract Arrive barrier from effect list.\n\nCandidates:\n  Fields: (none)\n  Inputs: GetArriveBarrierFromEffects, Effect\n  Output: Symbol, Extract, Arrive\n  References: ForkBarrier.hs:229, ForkBarrier.hs:232, ForkBarrier.hs:233, ForkBarrier.hs:234, ForkBarrier.hs:235, ForkBarrier.hs:236, ForkBarrier.hs:236\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to LSPSession?\nSymbol: getCandidatePackage\nModule: Tidepool.Control.Export\nPackage: tidepool-control-server\nSignature: getCandidatePackage :: LSPSession -> Text -> IO Text\n\nCandidates:\n  Fields: (none)\n  Inputs: LSPSession\n  Output: (none)\n  References: Export.hs:327, Export.hs:328\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I get the current UTC timestamp?\nSymbol: getCurrentTime\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: getCurrentTime :: forall (effs :: [Type -> Type]). Member Time effs => Eff effs UTCTime\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: UTCTime\n  References: Types.hs:29, Types.hs:198, Types.hs:199\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>UTCTime<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform ApiKey into Unwrap or API?\nSymbol: getApiKey\nModule: Tidepool.LLM.Types\nPackage: unknown\nSignature: getApiKey :: ApiKey -> Text Unwrap an API key to get the underlying text.\n\nCandidates:\n  Fields: (none)\n  Inputs: ApiKey\n  Output: Unwrap, API\n  References: Interpreter.hs:72, Interpreter.hs:108, Interpreter.hs:150, Types.hs:41, Types.hs:85, Types.hs:86\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>ApiKey,Unwrap,API<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming WorkspaceEdit into WorkspaceEdit?\nSymbol: fromWorkspaceEditMaybe\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromWorkspaceEditMaybe :: Maybe WorkspaceEdit -> Maybe WorkspaceEdit\n\nCandidates:\n  Fields: (none)\n  Inputs: WorkspaceEdit\n  Output: WorkspaceEdit\n  References: Interpreter.hs:364, Interpreter.hs:384, Interpreter.hs:387, Interpreter.hs:388, Interpreter.hs:389\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if I need lowercase output?\nSymbol: ucFirst\nModule: Tidepool.StructuredOutput.Prefix\nPackage: tidepool-core\nSignature: ucFirst :: String -> String Uppercase the first character of a string. ucFirst \"typeName\" = `TypeName` ucFirst \"url\" = `Url` ucFirst \"\" = \"\"\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Uppercase, TypeName, Url\n  References: Prefix.hs:24, Prefix.hs:132, Prefix.hs:133, Prefix.hs:134\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to Type and Session and Run and Session and Used and For and IO-based and StartSession and ContinueSession and ForkSession?\nSymbol: runSession\nModule: Tidepool.Effect.Session\nPackage: tidepool-core\nSignature: runSession :: forall (effs :: [Type -> Type]) a. (forall x. Session x -> Eff effs x) -> Eff (Session : effs) a -> Eff effs a Run Session effect with a pure handler. Used for testing or alternative implementations. For IO-based execution, see `runSessionIO` in tidepool-session-interpreter. let mockHandler = \\case StartSession slug _ _ _ _ -> pure mockOutput { soBranch = slug <> \"-abc123\" } ContinueSession _ _ _ _ _ _ _ -> pure mockOutput ForkSession _ _ _ _ childSlug _ _ _ -> pure mockOutput { soBranch = childSlug <> \"-def456\" } result <- runM $ runSession mockHandler myProgram\n\nCandidates:\n  Fields: (none)\n  Inputs: Type, Session, Run, Session, Used, For, IO-based, StartSession, ContinueSession, ForkSession\n  Output: (none)\n  References: Session.hs:68, Session.hs:489, Session.hs:493\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I get the API name for a tool?\nSymbol: toolName\nModule: Tidepool.Graph.Tool\nPackage: tidepool-core\nSignature: toolName :: forall t. ToolDef t => t -> Text Tool name (used in API calls). The `t` value is passed in case the tool marker carries config.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Tool, API, The\n  References: Convert.hs:73, Convert.hs:92, Convert.hs:103, Convert.hs:122, Tool.hs:169, Tool.hs:251, Tool.hs:310\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Tool,API<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform GetTasks and TaskType into Habitica or HabiticaTask?\nSymbol: GetTasks\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: GetTasks :: TaskType %1 -> Habitica [HabiticaTask]\n\nCandidates:\n  Fields: (none)\n  Inputs: GetTasks, TaskType\n  Output: Habitica, HabiticaTask\n  References: Habitica.hs:72, Habitica.hs:103, Habitica.hs:151\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetTasks,TaskType,Habitica,HabiticaTask<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When should I work with unvalidated data without JSON schema conversion?\nSymbol: emptySchema\nModule: Tidepool.Schema\nPackage: tidepool-core\nSignature: emptySchema :: SchemaType -> JSONSchema\n\nCandidates:\n  Fields: (none)\n  Inputs: SchemaType\n  Output: JSONSchema\n  References: [many references (36) - hub symbol]\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform CodeActionKind into CodeActionKind?\nSymbol: fromCodeActionKind\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromCodeActionKind :: CodeActionKind -> CodeActionKind\n\nCandidates:\n  Fields: (none)\n  Inputs: CodeActionKind\n  Output: CodeActionKind\n  References: Interpreter.hs:363, Interpreter.hs:368, Interpreter.hs:369\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>CodeActionKind<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming MemoryStore into Useful?\nSymbol: evalMemoryScoped\nModule: Tidepool.Graph.Memory\nPackage: tidepool-core\nSignature: evalMemoryScoped :: forall s (effs :: [Type -> Type]) a. (ToJSON s, FromJSON s) => Text -> s -> MemoryStore -> Eff (Memory s : effs) a -> Eff effs a Run memory effect with scoped persistence, discarding result store. Useful when you don't need the updated store (e.g., read-only access).\n\nCandidates:\n  Fields: (none)\n  Inputs: MemoryStore\n  Output: Run, Useful\n  References: Memory.hs:92, Memory.hs:459, Memory.hs:466\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if I need anonymous Habitica operations?\nSymbol: getUser\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: getUser :: forall (effs :: [Type -> Type]). Member Habitica effs => Eff effs UserInfo\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: UserInfo\n  References: Habitica.hs:11, Habitica.hs:96, Habitica.hs:97\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I find beads that block a given bead?\nSymbol: getBlocking\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: getBlocking :: forall (effs :: [Type -> Type]). Member BD effs => Text -> Eff effs [BeadInfo] Get blocking beads (beads this one is blocking).\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: BeadInfo, Get\n  References: BD.hs:37, BD.hs:381, BD.hs:382\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>BeadInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I uppercase the first character for PascalCase?\nSymbol: ucFirst\nModule: Tidepool.StructuredOutput.Prefix\nPackage: tidepool-core\nSignature: ucFirst :: String -> String Uppercase the first character of a string. ucFirst \"typeName\" = `TypeName` ucFirst \"url\" = `Url` ucFirst \"\" = \"\"\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Uppercase, TypeName, Url\n  References: Prefix.hs:24, Prefix.hs:132, Prefix.hs:133, Prefix.hs:134\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>TypeName<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I initialize an empty JSONSchema or Empty?\nSymbol: emptySchema\nModule: Tidepool.Schema\nPackage: tidepool-core\nSignature: emptySchema :: SchemaType -> JSONSchema Empty schema of given type\n\nCandidates:\n  Fields: (none)\n  Inputs: SchemaType\n  Output: JSONSchema, Empty\n  References: [many references (36) - hub symbol]\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>SchemaType,JSONSchema<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with WorktreeSpec and WorktreeError and WorktreePath and Create and WorktreeSpec and Nothing and Right and Left?\nSymbol: createWorktree\nModule: Tidepool.Effects.Worktree\nPackage: tidepool-core\nSignature: createWorktree :: forall (effs :: [Type -> Type]). Member Worktree effs => WorktreeSpec -> Eff effs (Either WorktreeError WorktreePath) Create a new worktree. result <- createWorktree (WorktreeSpec \"my-feature\" Nothing) case result of Right path -> -- path is like \" *repo* .worktrees/my-feature-abc123\" Left err -> handleError err\n\nCandidates:\n  Fields: (none)\n  Inputs: WorktreeSpec, WorktreeError, WorktreePath, Create, WorktreeSpec, Nothing, Right, Left\n  Output: (none)\n  References: Worktree.hs:72, Worktree.hs:228, Worktree.hs:232, Worktree.hs:297, Worktree.hs:308\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>WorktreeSpec,WorktreeError<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming FilePath into Socket or Setup or Unix?\nSymbol: setupSocket\nModule: Tidepool.Control.Server\nPackage: tidepool-control-server\nSignature: setupSocket :: FilePath -> IO Socket Setup Unix domain socket.\n\nCandidates:\n  Fields: (none)\n  Inputs: FilePath\n  Output: Socket, Setup, Unix\n  References: Server.hs:76, Server.hs:85, Server.hs:86\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Value into ParseDiagnostic?\nSymbol: expectedNumber\nModule: Tidepool.StructuredOutput.Error\nPackage: tidepool-core\nSignature: expectedNumber :: [Text] -> Value -> ParseDiagnostic Error for when a number was expected.\n\nCandidates:\n  Fields: (none)\n  Inputs: Value\n  Output: ParseDiagnostic, Error\n  References: Error.hs:16, Error.hs:67, Error.hs:68, Instances.hs:43, Instances.hs:73, Instances.hs:82, Instances.hs:88\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Value,ParseDiagnostic<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Type into JSONSchema?\nSymbol: typeToSchemaExp\nModule: Tidepool.Schema\nPackage: tidepool-core\nSignature: typeToSchemaExp :: Type -> Q Exp Convert a Haskell type to a JSONSchema expression\n\nCandidates:\n  Fields: (none)\n  Inputs: Type\n  Output: Exp, Convert, Haskell, JSONSchema\n  References: Schema.hs:185, Schema.hs:189, Schema.hs:190, Schema.hs:204, Schema.hs:208\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to McpConfig?\nSymbol: runMcpServer\nModule: Tidepool.MCP.Server\nPackage: unknown\nSignature: runMcpServer :: McpConfig -> IO ()\n\nCandidates:\n  Fields: (none)\n  Inputs: McpConfig\n  Output: (none)\n  References: Server.hs:11, Server.hs:54, Server.hs:55, Server.hs:11, Server.hs:54, Server.hs:55\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with QuestionHandler?\nSymbol: runQuestionUI\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: runQuestionUI :: forall (effs :: [Type -> Type]) a. LastMember IO effs => QuestionHandler -> Eff (QuestionUI : effs) a -> Eff effs a\n\nCandidates:\n  Fields: (none)\n  Inputs: QuestionHandler\n  Output: (none)\n  References: Types.hs:97, Types.hs:650, Types.hs:651\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>QuestionHandler<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming MermaidConfig and NodeInfo into Render?\nSymbol: renderNodeWithComments\nModule: Tidepool.Graph.Mermaid\nPackage: tidepool-core\nSignature: renderNodeWithComments :: MermaidConfig -> NodeInfo -> [Text] Render a node with optional structured comments.\n\nCandidates:\n  Fields: (none)\n  Inputs: MermaidConfig, NodeInfo\n  Output: Render\n  References: Mermaid.hs:161, Mermaid.hs:164, Mermaid.hs:165\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming RetryConfig into RetryResult?\nSymbol: withRetry\nModule: Tidepool.Actor.Retry\nPackage: tidepool-actor\nSignature: withRetry :: forall a. RetryConfig -> IO a -> IO (RetryResult a)\n\nCandidates:\n  Fields: (none)\n  Inputs: RetryConfig\n  Output: RetryResult\n  References: Retry.hs:16, Retry.hs:84, Retry.hs:85, Dispatch.hs:39, Dispatch.hs:158\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I format the user turn of a training example?\nSymbol: formatUserTurn\nModule: Tidepool.Training.Format\nPackage: tidepool-training-generator\nSignature: formatUserTurn :: Text -> Text -> Text -> Text -> Maybe Text -> [Text] -> Text Format user turn with LSP context. Lean format optimized for token density: - No escape tags in user turn (plain text context) - Module + Package for disambiguation - First-sentence docs only - Signature pre-cleaned (no forall, no markdown)\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Format, LSP, Lean, No, Module, Package, First-sentence, Signature\n  References: Format.hs:7, Format.hs:48, Format.hs:56, Format.hs:94\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Format,LSP<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with IORef and Message?\nSymbol: runChatHistoryWith\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: runChatHistoryWith :: forall (effs :: [Type -> Type]) a. LastMember IO effs => IORef [Message] -> Eff (ChatHistory : effs) a -> Eff effs a\n\nCandidates:\n  Fields: (none)\n  Inputs: IORef, Message\n  Output: (none)\n  References: Types.hs:528, Types.hs:530, Types.hs:531\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>IORef,Message<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I retrieve the graph entry point value?\nSymbol: getEntry\nModule: Tidepool.Effect.GraphContext\nPackage: tidepool-core\nSignature: getEntry :: forall entry (effs :: [Type -> Type]). Member (GraphContext entry) effs => Eff effs entry Read the entry value that spawned this graph. Usage requires type application to specify the entry type: entry <- getEntry @ScaffoldInput let depth = entry.siCurrentDepth This value is constant for the lifetime of the graph instance. In recursive execution, each child sees its own entry.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Read, Usage, This, In\n  References: GraphContext.hs:52, GraphContext.hs:101, GraphContext.hs:105\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Usage<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I find extends directives in a Jinja template?\nSymbol: parseTemplateExtends\nModule: Tidepool.Template.DependencyTree\nPackage: tidepool-core\nSignature: parseTemplateExtends :: Text -> [FilePath] Parse a template for {% extends \"...\" %} directives. Returns a list of extended template paths.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: FilePath, Parse, Returns\n  References: DependencyTree.hs:33, DependencyTree.hs:218, DependencyTree.hs:219, DependencyTree.hs:229\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>FilePath,Parse<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I convert JSONSchema to a JSONSchema or OneOf?\nSymbol: oneOfSchema\nModule: Tidepool.Schema\nPackage: tidepool-core\nSignature: oneOfSchema :: [JSONSchema] -> JSONSchema OneOf schema combinator (for sum types)\n\nCandidates:\n  Fields: (none)\n  Inputs: JSONSchema\n  Output: JSONSchema, OneOf\n  References: Schema.hs:20, Schema.hs:96, Schema.hs:97\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>JSONSchema<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming TextEdit into TextEdit?\nSymbol: fromTextEdit\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromTextEdit :: TextEdit -> TextEdit\n\nCandidates:\n  Fields: (none)\n  Inputs: TextEdit\n  Output: TextEdit\n  References: Interpreter.hs:393, Interpreter.hs:397, Interpreter.hs:398\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming GetFieldGotoTargetsWithPayloads and Type into Symbol or Type?\nSymbol: GetFieldGotoTargetsWithPayloads\nModule: Tidepool.Graph.Validate.RecordStructure\nPackage: tidepool-core\nSignature: GetFieldGotoTargetsWithPayloads :: Type -> [(Symbol, Type)] Get (target, payload) pairs from a field definition.\n\nCandidates:\n  Fields: (none)\n  Inputs: GetFieldGotoTargetsWithPayloads, Type\n  Output: Symbol, Type, Get\n  References: RecordStructure.hs:420, RecordStructure.hs:423, RecordStructure.hs:424, RecordStructure.hs:425\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming GetDeps into BD or BeadInfo?\nSymbol: GetDeps\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: GetDeps :: Text %1 -> BD [BeadInfo] Get beads that this bead depends on (blockers).\n\nCandidates:\n  Fields: (none)\n  Inputs: GetDeps\n  Output: BD, BeadInfo, Get\n  References: BD.hs:325, BD.hs:378\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if entry is not needed for this node?\nSymbol: getEntry\nModule: Tidepool.Effect.GraphContext\nPackage: tidepool-core\nSignature: getEntry :: forall entry (effs :: [Type -> Type]). Member (GraphContext entry) effs => Eff effs entry Read the entry value that spawned this graph. Usage requires type application to specify the entry type: entry <- getEntry @ScaffoldInput let depth = entry.siCurrentDepth This value is constant for the lifetime of the graph instance. In recursive execution, each child sees its own entry.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Read, Usage, This, In\n  References: GraphContext.hs:52, GraphContext.hs:101, GraphContext.hs:105\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming GetTasksTry and TaskType into Habitica or HabiticaError or HabiticaTask?\nSymbol: GetTasksTry\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: GetTasksTry :: TaskType %1 -> Habitica (Either HabiticaError [HabiticaTask])\n\nCandidates:\n  Fields: (none)\n  Inputs: GetTasksTry, TaskType\n  Output: Habitica, HabiticaError, HabiticaTask\n  References: Habitica.hs:80, Habitica.hs:126, Habitica.hs:171\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I send a message non-blocking to an actor's mailbox?\nSymbol: send\nModule: Tidepool.Actor.Mailbox\nPackage: tidepool-actor\nSignature: send :: forall msg. Mailbox msg -> msg -> IO () Send a message to a mailbox. Non-blocking, always succeeds (unbounded queue).\n\nCandidates:\n  Fields: (none)\n  Inputs: Mailbox\n  Output: Send, Non-blocking\n  References: Mailbox.hs:11, Mailbox.hs:36, Mailbox.hs:37, Runtime.hs:19, Runtime.hs:89, Graph.hs:98, Graph.hs:341, Graph.hs:350, Graph.hs:366\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Mailbox<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to JSONSchema?\nSymbol: isEmptyObject\nModule: Tidepool.StructuredOutput.Generic\nPackage: tidepool-core\nSignature: isEmptyObject :: JSONSchema -> Bool\n\nCandidates:\n  Fields: (none)\n  Inputs: JSONSchema\n  Output: (none)\n  References: Generic.hs:303, Generic.hs:308, Generic.hs:309\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to AsHandler?\nSymbol: runGraph\nModule: Tidepool.Graph.Interpret\nPackage: tidepool-core\nSignature: runGraph :: forall (graph :: Type -> Type) entryType (targets :: [Type]) exitType (es :: [Type -> Type]) (entryHandlerName :: Symbol) handler. (Generic (graph AsGraph), FindEntryHandler entryType (FieldsWithNamesOf graph) ~ 'Just entryHandlerName, KnownSymbol entryHandlerName, HasField entryHandlerName (graph (AsHandler es)) handler, CallHandler handler entryType es targets, DispatchGoto graph targets es exitType) => graph (AsHandler es) -> entryType -> Eff es exitType\n\nCandidates:\n  Fields: (none)\n  Inputs: AsHandler\n  Output: (none)\n  References: CLI.hs:99, CLI.hs:530, Interpret.hs:31, Interpret.hs:186, Interpret.hs:198, Interpret.hs:203, Interpret.hs:565, Interpret.hs:586, Interpret.hs:604\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if tool names are generated dynamically?\nSymbol: toolName\nModule: Tidepool.Graph.Tool\nPackage: tidepool-core\nSignature: toolName :: forall t. ToolDef t => t -> Text Tool name (used in API calls). The `t` value is passed in case the tool marker carries config.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Tool, API, The\n  References: Convert.hs:73, Convert.hs:92, Convert.hs:103, Convert.hs:122, Tool.hs:169, Tool.hs:251, Tool.hs:310\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with MarkupContent?\nSymbol: extractDocumentation\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: extractDocumentation :: (Text |? MarkupContent) -> Text\n\nCandidates:\n  Fields: (none)\n  Inputs: MarkupContent\n  Output: (none)\n  References: Interpreter.hs:408, Interpreter.hs:412, Interpreter.hs:413\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>MarkupContent<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform SchemaType into Schema?\nSymbol: typeToText\nModule: Tidepool.Schema\nPackage: tidepool-core\nSignature: typeToText :: SchemaType -> Text Convert schema type to JSON Schema type string\n\nCandidates:\n  Fields: (none)\n  Inputs: SchemaType\n  Output: Convert, JSON, Schema\n  References: Schema.hs:107, Schema.hs:126, Schema.hs:127\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>SchemaType<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming AsHandler into Run?\nSymbol: runGraphFromWithSpans\nModule: Tidepool.Graph.Interpret.Instrumented\nPackage: tidepool-core\nSignature: runGraphFromWithSpans :: forall (name :: Symbol) (graph :: Type -> Type) entryType (targets :: [Type]) exitType (es :: [Effect]) handler. (KnownSymbol name, HasField name (graph (AsHandler es)) handler, CallHandler handler entryType es targets, DispatchGotoTraced graph targets es exitType, Member Observability es) => graph (AsHandler es) -> entryType -> Eff es exitType Run a graph from a named handler with span emission. result <- runGraphFromWithSpans @\"compute\" handlers inputValue\n\nCandidates:\n  Fields: (none)\n  Inputs: AsHandler\n  Output: Run\n  References: Instrumented.hs:45, Instrumented.hs:134, Instrumented.hs:142, Instrumented.hs:153\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform GetPullRequest and Repo into GitHub or PullRequest?\nSymbol: GetPullRequest\nModule: Tidepool.Effects.GitHub\nPackage: tidepool-core\nSignature: GetPullRequest :: Repo %1 -> Int %1 -> Bool %1 -> GitHub (Maybe PullRequest)\n\nCandidates:\n  Fields: (none)\n  Inputs: GetPullRequest, Repo\n  Output: GitHub, PullRequest\n  References: GitHub.hs:306, GitHub.hs:328, GitHub.hs:359\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetPullRequest,Repo,GitHub,PullRequest<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I query the current time in an effect?\nSymbol: GetCurrentTime\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: GetCurrentTime :: Time UTCTime\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetCurrentTime, Time, UTCTime\n  References: Types.hs:196, Types.hs:199, Types.hs:203\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetCurrentTime<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When can I assume user fetch always succeeds?\nSymbol: getUserTry\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: getUserTry :: forall (effs :: [Type -> Type]). Member Habitica effs => Eff effs (Either HabiticaError UserInfo)\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: HabiticaError, UserInfo\n  References: Habitica.hs:19, Habitica.hs:119, Habitica.hs:120\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Value into ParseDiagnostic?\nSymbol: expectedString\nModule: Tidepool.StructuredOutput.Error\nPackage: tidepool-core\nSignature: expectedString :: [Text] -> Value -> ParseDiagnostic Error for when a string was expected.\n\nCandidates:\n  Fields: (none)\n  Inputs: Value\n  Output: ParseDiagnostic, Error\n  References: Error.hs:15, Error.hs:58, Error.hs:59, Instances.hs:42, Instances.hs:58, Instances.hs:64\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Value,ParseDiagnostic<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform AsHandler into HasField or GHC or Instead?\nSymbol: runGraphWith\nModule: Tidepool.Graph.Interpret\nPackage: tidepool-core\nSignature: runGraphWith :: forall (graph :: Type -> Type) entryType (targets :: [Type]) exitType (es :: [Effect]) handler. (CallHandler handler entryType es targets, DispatchGoto graph targets es exitType) => handler -> graph (AsHandler es) -> entryType -> Eff es exitType Run a graph with an explicitly provided entry handler. This avoids the `HasField` constraint that `runGraph` and `runGraphFrom` require. Use this when GHC can't derive HasField for your graph record (common when field types involve type families). -- Instead of: result <- runGraph handlers input -- Requires HasField -- Use: result <- runGraphWith handlers.v3Scaffold handlers input -- No HasField needed\n\nCandidates:\n  Fields: (none)\n  Inputs: AsHandler\n  Output: Run, This, HasField, Use, GHC, Instead, Requires, No\n  References: Interpret.hs:33, Interpret.hs:214, Interpret.hs:223\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>AsHandler<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I create an error for a missing required field?\nSymbol: missingField\nModule: Tidepool.StructuredOutput.Error\nPackage: tidepool-core\nSignature: missingField :: [Text] -> ParseDiagnostic Error for a missing required field.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: ParseDiagnostic, Error\n  References: Error.hs:18, Error.hs:85, Error.hs:86, Generic.hs:38, Generic.hs:183, Generic.hs:387\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>ParseDiagnostic<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming ScoringContext into Turn?\nSymbol: renderScoringPrompt\nModule: Tidepool.Control.Scout.Templates\nPackage: tidepool-control-server\nSignature: renderScoringPrompt :: ScoringContext -> Text Render the Turn 2 prompt for FunctionGemma. This is the user request that asks the model to rate the edge. Turn 1 (function declaration) is prepended by the interpreter.\n\nCandidates:\n  Fields: (none)\n  Inputs: ScoringContext\n  Output: Render, Turn, FunctionGemma., This\n  References: Templates.hs:18, Templates.hs:76, Templates.hs:77\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming CompletionItem into CompletionItem?\nSymbol: fromCompletionItem\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromCompletionItem :: CompletionItem -> CompletionItem\n\nCandidates:\n  Fields: (none)\n  Inputs: CompletionItem\n  Output: CompletionItem\n  References: Interpreter.hs:238, Interpreter.hs:403, Interpreter.hs:404\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform FilePath into Socket or Setup or Unix?\nSymbol: setupSocket\nModule: Tidepool.Control.Server\nPackage: tidepool-control-server\nSignature: setupSocket :: FilePath -> IO Socket Setup Unix domain socket.\n\nCandidates:\n  Fields: (none)\n  Inputs: FilePath\n  Output: Socket, Setup, Unix\n  References: Server.hs:76, Server.hs:85, Server.hs:86\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>FilePath,Socket,Setup<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Value and Value into TurnOutcome or TurnParseResult?\nSymbol: runTurn\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: runTurn :: forall output (effs :: [Type -> Type]). (Member LLM effs, StructuredOutput output, ValidStructuredOutput output) => Text -> Text -> Value -> [Value] -> Eff effs (TurnOutcome (TurnParseResult output))\n\nCandidates:\n  Fields: (none)\n  Inputs: Value, Value\n  Output: TurnOutcome, TurnParseResult\n  References: Types.hs:53, Types.hs:383, Types.hs:388, Types.hs:435, Types.hs:450, Types.hs:485, Types.hs:500, Interpret.hs:75, Interpret.hs:281\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform JSONSchema into Check?\nSymbol: isEmptyObject\nModule: Tidepool.StructuredOutput.Generic\nPackage: tidepool-core\nSignature: isEmptyObject :: JSONSchema -> Bool Check if a schema represents an empty object {}. An empty object has type TObject with no properties and no required fields.\n\nCandidates:\n  Fields: (none)\n  Inputs: JSONSchema\n  Output: Check, An, TObject\n  References: Generic.hs:303, Generic.hs:308, Generic.hs:309\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>JSONSchema<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I initialize the node-private memory store for a fresh graph execution?\nSymbol: emptyMemoryStore\nModule: Tidepool.Graph.Memory\nPackage: tidepool-core\nSignature: emptyMemoryStore :: MemoryStore\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: MemoryStore\n  References: Memory.hs:86, Memory.hs:286, Memory.hs:287\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>MemoryStore<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When should I use memory instead of input?\nSymbol: GetNodeInput\nModule: Tidepool.Effect.GraphContext\nPackage: tidepool-core\nSignature: GetNodeInput :: forall {k} (input :: k). NodeInput input input Get the input value for this node invocation.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetNodeInput, NodeInput, Get\n  References: GraphContext.hs:129, GraphContext.hs:165, GraphContext.hs:206\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform SetThinking into UI?\nSymbol: SetThinking\nModule: Tidepool.Effects.UI\nPackage: tidepool-core\nSignature: SetThinking :: Bool %1 -> UI () Set the \"thinking\" indicator state.\n\nCandidates:\n  Fields: (none)\n  Inputs: SetThinking\n  Output: UI\n  References: UI.hs:124, UI.hs:203\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>SetThinking,UI<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What makes an edge explicit instead?\nSymbol: RuntimeImplicit\nModule: Tidepool.Graph.Reify\nPackage: tidepool-core\nSignature: RuntimeImplicit :: RuntimeEdgeKind Schema \u2192 Needs (data flow)\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: RuntimeImplicit, RuntimeEdgeKind, Schema, Needs\n  References: Reify.hs:206, Reify.hs:827, Reify.hs:834, Reify.hs:852, Export.hs:288\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Stack into View?\nSymbol: peek\nModule: Data.Stack\nPackage: tidepool-core\nSignature: peek :: forall a. Stack a -> Maybe a View the top element without removing it. Returns `Nothing` if the stack is empty. The stack is not modified. ### Laws peek empty == Nothing peek (push x s) == Just x peek s == fst <$> pop s (ignores the rest) ### Time Complexity O(1)\n\nCandidates:\n  Fields: (none)\n  Inputs: Stack\n  Output: View, Returns, Nothing, The, Laws, Just, Time, Complexity, O1\n  References: Stack.hs:8, Stack.hs:36, Stack.hs:100, Stack.hs:101\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Stack<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When should I pass data through inputs instead of memory?\nSymbol: GetMem\nModule: Tidepool.Graph.Memory\nPackage: tidepool-core\nSignature: GetMem :: forall s. Memory s s Get the current memory value.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetMem, Memory, Get\n  References: Memory.hs:121, Memory.hs:135, Memory.hs:206\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform GetArriveBarrierFromEffects and Effect into Symbol or Arrive?\nSymbol: GetArriveBarrierFromEffects\nModule: Tidepool.Graph.Validate.ForkBarrier\nPackage: tidepool-core\nSignature: GetArriveBarrierFromEffects :: [Effect] -> Maybe Symbol Extract Arrive barrier from effect list.\n\nCandidates:\n  Fields: (none)\n  Inputs: GetArriveBarrierFromEffects, Effect\n  Output: Symbol, Extract, Arrive\n  References: ForkBarrier.hs:229, ForkBarrier.hs:232, ForkBarrier.hs:233, ForkBarrier.hs:234, ForkBarrier.hs:235, ForkBarrier.hs:236, ForkBarrier.hs:236\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetArriveBarrierFromEffects,Effect,Symbol,Extract<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When should I use non-blocking message polling instead of waiting?\nSymbol: receive\nModule: Tidepool.Actor.Mailbox\nPackage: tidepool-actor\nSignature: receive :: forall msg. Mailbox msg -> IO msg Receive a message from a mailbox. Blocks until a message is available.\n\nCandidates:\n  Fields: (none)\n  Inputs: Mailbox\n  Output: Receive, Blocks\n  References: Mailbox.hs:12, Mailbox.hs:42, Mailbox.hs:43, Spawn.hs:23, Spawn.hs:67\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming CreateTodo into Habitica or TodoId?\nSymbol: CreateTodo\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: CreateTodo :: Text %1 -> Habitica TodoId\n\nCandidates:\n  Fields: (none)\n  Inputs: CreateTodo\n  Output: Habitica, TodoId\n  References: Habitica.hs:69, Habitica.hs:94, Habitica.hs:142\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to MermaidConfig and GraphInfo and ExecutionPath?\nSymbol: toSequenceDiagram\nModule: Tidepool.Graph.Mermaid\nPackage: tidepool-core\nSignature: toSequenceDiagram :: MermaidConfig -> GraphInfo -> ExecutionPath -> Text\n\nCandidates:\n  Fields: (none)\n  Inputs: MermaidConfig, GraphInfo, ExecutionPath\n  Output: (none)\n  References: Mermaid.hs:39, Mermaid.hs:509, Mermaid.hs:510\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform GetFieldInput and Symbol and Type and Symbol into Type or Input?\nSymbol: GetFieldInput\nModule: Tidepool.Graph.Validate.RecordStructure\nPackage: tidepool-core\nSignature: GetFieldInput :: [(Symbol, Type)] -> Symbol -> Maybe Type Get Input type for a field by name.\n\nCandidates:\n  Fields: (none)\n  Inputs: GetFieldInput, Symbol, Type, Symbol\n  Output: Type, Get, Input\n  References: RecordStructure.hs:460, RecordStructure.hs:464, RecordStructure.hs:465, RecordStructure.hs:466, RecordStructure.hs:467, RecordStructure.hs:470\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetFieldInput,Symbol,Type<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform GetUsesEffectsFixed and Type into Effect or UsesEffects?\nSymbol: GetUsesEffectsFixed\nModule: Tidepool.Graph.Validate.ForkBarrier\nPackage: tidepool-core\nSignature: GetUsesEffectsFixed :: Type -> Maybe [Effect] Get UsesEffects with fixed kind.\n\nCandidates:\n  Fields: (none)\n  Inputs: GetUsesEffectsFixed, Type\n  Output: Effect, Get, UsesEffects\n  References: ForkBarrier.hs:223, ForkBarrier.hs:339, ForkBarrier.hs:340, ForkBarrier.hs:341, ForkBarrier.hs:342, ForkBarrier.hs:342, ForkBarrier.hs:343\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetUsesEffectsFixed,Type,Effect<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform SchemaInfo into Render?\nSymbol: renderSchemaComment\nModule: Tidepool.Graph.Mermaid\nPackage: tidepool-core\nSignature: renderSchemaComment :: Maybe SchemaInfo -> Text Render schema comment.\n\nCandidates:\n  Fields: (none)\n  Inputs: SchemaInfo\n  Output: Render\n  References: Mermaid.hs:180, Mermaid.hs:203, Mermaid.hs:204, Mermaid.hs:205\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>SchemaInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with GraphInfo?\nSymbol: toStateDiagram\nModule: Tidepool.Graph.Mermaid\nPackage: tidepool-core\nSignature: toStateDiagram :: GraphInfo -> Text\n\nCandidates:\n  Fields: (none)\n  Inputs: GraphInfo\n  Output: (none)\n  References: Mermaid.hs:35, Mermaid.hs:387, Mermaid.hs:388\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GraphInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is an LLM node for API calls?\nSymbol: RuntimeLLM\nModule: Tidepool.Graph.Reify\nPackage: tidepool-core\nSignature: RuntimeLLM :: RuntimeNodeKind Standard LLM API call\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: RuntimeLLM, RuntimeNodeKind, Standard, LLM, API\n  References: Reify.hs:197, Reify.hs:410, Reify.hs:762, Mermaid.hs:186, Mermaid.hs:245, Mermaid.hs:253, Mermaid.hs:414, Export.hs:280\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>RuntimeLLM,RuntimeNodeKind<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform AsHandler into HasField or GHC or Instead?\nSymbol: runGraphWith\nModule: Tidepool.Graph.Interpret\nPackage: tidepool-core\nSignature: runGraphWith :: forall (graph :: Type -> Type) entryType (targets :: [Type]) exitType (es :: [Effect]) handler. (CallHandler handler entryType es targets, DispatchGoto graph targets es exitType) => handler -> graph (AsHandler es) -> entryType -> Eff es exitType Run a graph with an explicitly provided entry handler. This avoids the `HasField` constraint that `runGraph` and `runGraphFrom` require. Use this when GHC can't derive HasField for your graph record (common when field types involve type families). -- Instead of: result <- runGraph handlers input -- Requires HasField -- Use: result <- runGraphWith handlers.v3Scaffold handlers input -- No HasField needed\n\nCandidates:\n  Fields: (none)\n  Inputs: AsHandler\n  Output: Run, This, HasField, Use, GHC, Instead, Requires, No\n  References: Interpret.hs:33, Interpret.hs:214, Interpret.hs:223\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>AsHandler<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I convert JSONSchema to a JSONSchema or Object?\nSymbol: objectSchema\nModule: Tidepool.Schema\nPackage: tidepool-core\nSignature: objectSchema :: [(Text, JSONSchema)] -> [Text] -> JSONSchema Object schema combinator\n\nCandidates:\n  Fields: (none)\n  Inputs: JSONSchema\n  Output: JSONSchema, Object\n  References: Generic.hs:36, Generic.hs:69, Generic.hs:267, Generic.hs:348, Schema.hs:17, Schema.hs:81, Schema.hs:82, Schema.hs:166, DecisionTools.hs:62, DecisionTools.hs:221, Types.hs:60, Types.hs:184, Types.hs:48, Types.hs:208\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>JSONSchema<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming MemoryStore into Nothing' or Left or Type?\nSymbol: getScope\nModule: Tidepool.Graph.Memory\nPackage: tidepool-core\nSignature: getScope :: forall s. FromJSON s => Text -> MemoryStore -> Either Text (Maybe s) Get a scope from the store, deserializing to the expected type. Returns 'Right Nothing' if the scope doesn't exist. Returns `Left` error if deserialization fails (type mismatch). Type safety is enforced by the `FromJSON` constraint - if the stored JSON doesn't match the expected type, parsing will fail with an error.\n\nCandidates:\n  Fields: (none)\n  Inputs: MemoryStore\n  Output: Get, Returns, Nothing', Left, Type, FromJSON, JSON\n  References: Memory.hs:89, Memory.hs:279, Memory.hs:364, Memory.hs:394, Memory.hs:399, Memory.hs:410, Memory.hs:428, Memory.hs:444\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to LSPSession?\nSymbol: runLSP\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: runLSP :: forall (effs :: [Type -> Type]) a. LastMember IO effs => LSPSession -> Eff (LSP : effs) a -> Eff effs a\n\nCandidates:\n  Fields: (none)\n  Inputs: LSPSession\n  Output: (none)\n  References: Interpreter.hs:12, Interpreter.hs:180, Interpreter.hs:181, MCP.hs:21, MCP.hs:71, Export.hs:24, Export.hs:35, Export.hs:49, Export.hs:79, Export.hs:83\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I determine the exit type of a graph?\nSymbol: GetExitType\nModule: Tidepool.Graph.Generic\nPackage: tidepool-core\nSignature: GetExitType\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetExitType\n  References: Generic.hs:107, Generic.hs:1130, Generic.hs:1131, Generic.hs:1132, Generic.hs:1132, Generic.hs:1133, Generic.hs:1133, Generic.hs:1134, Generic.hs:1135, Generic.hs:1136, Generic.hs:1136, Generic.hs:1136, Generic.hs:1137\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetExitType<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming GetLabels into BD?\nSymbol: GetLabels\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: GetLabels :: Text %1 -> BD [Text] Get labels attached to a bead.\n\nCandidates:\n  Fields: (none)\n  Inputs: GetLabels\n  Output: BD, Get\n  References: BD.hs:331, BD.hs:386\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform GetRecordEntryType and Type into Type?\nSymbol: GetRecordEntryType\nModule: Tidepool.Graph.Validate.RecordStructure\nPackage: tidepool-core\nSignature: GetRecordEntryType :: (Type -> Type) -> Type Get EntryNode type from a graph record (unwrap Maybe).\n\nCandidates:\n  Fields: (none)\n  Inputs: GetRecordEntryType, Type\n  Output: Type, Get, EntryNode, Maybe.\n  References: RecordStructure.hs:128, RecordStructure.hs:131, RecordStructure.hs:132, RecordStructure.hs:133, RecordStructure.hs:390\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetRecordEntryType,Type<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to Type and DevLog?\nSymbol: runDevLogPure\nModule: Tidepool.Effect.DevLog\nPackage: tidepool-core\nSignature: runDevLogPure :: forall (effs :: [Type -> Type]) a. Eff (DevLog : effs) a -> Eff effs a\n\nCandidates:\n  Fields: (none)\n  Inputs: Type, DevLog\n  Output: (none)\n  References: DevLog.hs:58, DevLog.hs:209, DevLog.hs:210\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming ContentBlock and Value and Value into TurnOutcome or TurnParseResult?\nSymbol: runTurnContent\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: runTurnContent :: forall output (effs :: [Type -> Type]). (Member LLM effs, StructuredOutput output, ValidStructuredOutput output) => Text -> [ContentBlock] -> Value -> [Value] -> Eff effs (TurnOutcome (TurnParseResult output))\n\nCandidates:\n  Fields: (none)\n  Inputs: ContentBlock, Value, Value\n  Output: TurnOutcome, TurnParseResult\n  References: Types.hs:54, Types.hs:389, Types.hs:391, Types.hs:396\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if you need manual schema definition without Haddock comments?\nSymbol: deriveJSONSchema\nModule: Tidepool.Schema\nPackage: tidepool-core\nSignature: deriveJSONSchema :: Name -> Q Exp Derive a JSONSchema from a record type, using Haddock comments as descriptions.\n\nCandidates:\n  Fields: (none)\n  Inputs: Name\n  Output: Exp, Derive, JSONSchema, Haddock\n  References: Schema.hs:37, Schema.hs:141, Schema.hs:142, Schema.hs:226\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I query the current Git branch name?\nSymbol: GetCurrentBranch\nModule: Tidepool.Effects.Git\nPackage: tidepool-core\nSignature: GetCurrentBranch :: Git Text Get current branch name.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetCurrentBranch, Git, Get\n  References: Git.hs:93, Git.hs:114\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetCurrentBranch,Git<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if I need to modify existing todos instead?\nSymbol: createTodo\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: createTodo :: forall (effs :: [Type -> Type]). Member Habitica effs => Text -> Eff effs TodoId\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: TodoId\n  References: Habitica.hs:10, Habitica.hs:93, Habitica.hs:94\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform GetDeps into BD or BeadInfo?\nSymbol: GetDeps\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: GetDeps :: Text %1 -> BD [BeadInfo] Get beads that this bead depends on (blockers).\n\nCandidates:\n  Fields: (none)\n  Inputs: GetDeps\n  Output: BD, BeadInfo, Get\n  References: BD.hs:325, BD.hs:378\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetDeps,BD,BeadInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I convert camelCase to snake_case?\nSymbol: camelToSnake\nModule: Tidepool.Graph.MCPReify\nPackage: tidepool-core\nSignature: camelToSnake :: ShowS\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: ShowS\n  References: MCPReify.hs:152, MCPReify.hs:162, MCPReify.hs:163\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>ShowS<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming ToolError into ToolError or Useful or ToolResult?\nSymbol: toolErrorToText\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: toolErrorToText :: ToolError -> Text Convert a ToolError to a human-readable message. Useful for compatibility with code expecting `Either Text ToolResult` .\n\nCandidates:\n  Fields: (none)\n  Inputs: ToolError\n  Output: Convert, ToolError, Useful, ToolResult\n  References: Types.hs:87, Types.hs:370, Types.hs:371\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if user context is not needed?\nSymbol: GetUser\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: GetUser :: Habitica UserInfo\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetUser, Habitica, UserInfo\n  References: Habitica.hs:70, Habitica.hs:97, Habitica.hs:145\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming MemoryStore into MemoryStore or Type?\nSymbol: setScope\nModule: Tidepool.Graph.Memory\nPackage: tidepool-core\nSignature: setScope :: forall s. ToJSON s => Text -> s -> MemoryStore -> MemoryStore Set a scope in the store, serializing the value. The value is immediately serialized to JSON. Type information is not stored - type checking happens at access time via `getScope` .\n\nCandidates:\n  Fields: (none)\n  Inputs: MemoryStore\n  Output: MemoryStore, The, JSON., Type\n  References: Memory.hs:90, Memory.hs:411, Memory.hs:417, Memory.hs:453\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform LSPSession and Value into ControlResponse?\nSymbol: handleMcpTool\nModule: Tidepool.Control.Handler.MCP\nPackage: tidepool-control-server\nSignature: handleMcpTool :: LSPSession -> Text -> Text -> Value -> IO ControlResponse\n\nCandidates:\n  Fields: (none)\n  Inputs: LSPSession, Value\n  Output: ControlResponse\n  References: MCP.hs:5, MCP.hs:27, MCP.hs:28, Handler.hs:8, Handler.hs:15\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>LSPSession,Value,ControlResponse<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with IORef and Message?\nSymbol: runChatHistoryWith\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: runChatHistoryWith :: forall (effs :: [Type -> Type]) a. LastMember IO effs => IORef [Message] -> Eff (ChatHistory : effs) a -> Eff effs a\n\nCandidates:\n  Fields: (none)\n  Inputs: IORef, Message\n  Output: (none)\n  References: Types.hs:528, Types.hs:530, Types.hs:531\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>IORef,Message<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform MemoryStore into Nothing' or Left or Type?\nSymbol: getScope\nModule: Tidepool.Graph.Memory\nPackage: tidepool-core\nSignature: getScope :: forall s. FromJSON s => Text -> MemoryStore -> Either Text (Maybe s) Get a scope from the store, deserializing to the expected type. Returns 'Right Nothing' if the scope doesn't exist. Returns `Left` error if deserialization fails (type mismatch). Type safety is enforced by the `FromJSON` constraint - if the stored JSON doesn't match the expected type, parsing will fail with an error.\n\nCandidates:\n  Fields: (none)\n  Inputs: MemoryStore\n  Output: Get, Returns, Nothing', Left, Type, FromJSON, JSON\n  References: Memory.hs:89, Memory.hs:279, Memory.hs:364, Memory.hs:394, Memory.hs:399, Memory.hs:410, Memory.hs:428, Memory.hs:444\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>MemoryStore<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming WorktreeSpec and WorktreePath into WorktreeError?\nSymbol: withWorktree\nModule: Tidepool.Effects.Worktree\nPackage: tidepool-core\nSignature: withWorktree :: forall (effs :: [Type -> Type]) a. Member Worktree effs => WorktreeSpec -> (WorktreePath -> Eff effs a) -> Eff effs (Either WorktreeError a)\n\nCandidates:\n  Fields: (none)\n  Inputs: WorktreeSpec, WorktreePath\n  Output: WorktreeError\n  References: Worktree.hs:31, Worktree.hs:79, Worktree.hs:302, Worktree.hs:307\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform GetGotoTargetsFromEffects and Effect into Symbol or Type or Goto?\nSymbol: GetGotoTargetsFromEffects\nModule: Tidepool.Graph.Validate.RecordStructure\nPackage: tidepool-core\nSignature: GetGotoTargetsFromEffects :: [Effect] -> [(Symbol, Type)] Get Goto targets from effect list.\n\nCandidates:\n  Fields: (none)\n  Inputs: GetGotoTargetsFromEffects, Effect\n  Output: Symbol, Type, Get, Goto\n  References: RecordStructure.hs:432, RecordStructure.hs:435, RecordStructure.hs:436, RecordStructure.hs:437, RecordStructure.hs:438, RecordStructure.hs:439, RecordStructure.hs:440, RecordStructure.hs:440, RecordStructure.hs:441, RecordStructure.hs:441\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetGotoTargetsFromEffects,Effect,Symbol,Type<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with LSPSession and Socket?\nSymbol: handleConnection\nModule: Tidepool.Control.Server\nPackage: tidepool-control-server\nSignature: handleConnection :: LSPSession -> Socket -> IO ()\n\nCandidates:\n  Fields: (none)\n  Inputs: LSPSession, Socket\n  Output: (none)\n  References: Server.hs:82, Server.hs:101, Server.hs:102\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>LSPSession,Socket<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I serialize a tool for Anthropic?\nSymbol: toAnthropicTool\nModule: Tidepool.Tool.Convert\nPackage: tidepool-core\nSignature: toAnthropicTool :: forall t. ToAnthropicTool t => t -> AnthropicTool\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: AnthropicTool\n  References: Convert.hs:88, Convert.hs:90, Convert.hs:91, Convert.hs:139\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>AnthropicTool<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform AsHandler into Run?\nSymbol: runGraphFromWithSpans\nModule: Tidepool.Graph.Interpret.Instrumented\nPackage: tidepool-core\nSignature: runGraphFromWithSpans :: forall (name :: Symbol) (graph :: Type -> Type) entryType (targets :: [Type]) exitType (es :: [Effect]) handler. (KnownSymbol name, HasField name (graph (AsHandler es)) handler, CallHandler handler entryType es targets, DispatchGotoTraced graph targets es exitType, Member Observability es) => graph (AsHandler es) -> entryType -> Eff es exitType Run a graph from a named handler with span emission. result <- runGraphFromWithSpans @\"compute\" handlers inputValue\n\nCandidates:\n  Fields: (none)\n  Inputs: AsHandler\n  Output: Run\n  References: Instrumented.hs:45, Instrumented.hs:134, Instrumented.hs:142, Instrumented.hs:153\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>AsHandler<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if you need numeric or custom enum formats instead of strings?\nSymbol: stringEnumSchema\nModule: Tidepool.StructuredOutput.Generic\nPackage: tidepool-core\nSignature: stringEnumSchema :: [String] -> JSONSchema Generate a string enum schema. For nullary sum types like `data Priority = Low | Medium | High` , generates `{\"type\": \"string\", \"enum\": [ Low , Medium , High ]}` instead of wasteful oneOf with tag+contents encoding.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: JSONSchema, Generate, For, Priority, Low, Medium, High\n  References: Generic.hs:319, Generic.hs:320, Generic.hs:337\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Value into ParseDiagnostic?\nSymbol: expectedObject\nModule: Tidepool.StructuredOutput.Error\nPackage: tidepool-core\nSignature: expectedObject :: [Text] -> Value -> ParseDiagnostic Error for when an object was expected.\n\nCandidates:\n  Fields: (none)\n  Inputs: Value\n  Output: ParseDiagnostic, Error\n  References: Error.hs:13, Error.hs:40, Error.hs:41, Generic.hs:38, Generic.hs:85, Generic.hs:287, Generic.hs:401, Generic.hs:402, Generic.hs:403\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Value,ParseDiagnostic<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When are blocking relationships not needed?\nSymbol: getBlocking\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: getBlocking :: forall (effs :: [Type -> Type]). Member BD effs => Text -> Eff effs [BeadInfo] Get blocking beads (beads this one is blocking).\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: BeadInfo, Get\n  References: BD.hs:37, BD.hs:381, BD.hs:382\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I parse a Text into a BaseUrl?\nSymbol: parseBaseUrl\nModule: Tidepool.LLM.Interpreter\nPackage: unknown\nSignature: parseBaseUrl :: Text -> BaseUrl\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: BaseUrl\n  References: Interpreter.hs:42, Interpreter.hs:104, Interpreter.hs:146, Interpreter.hs:185, Interpreter.hs:186\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>BaseUrl<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with RetryConfig?\nSymbol: runWithRetryOrFail\nModule: Tidepool.Actor.Dispatch\nPackage: tidepool-actor\nSignature: runWithRetryOrFail :: forall a. RetryConfig -> IO a -> IO a\n\nCandidates:\n  Fields: (none)\n  Inputs: RetryConfig\n  Output: (none)\n  References: Dispatch.hs:110, Dispatch.hs:156, Dispatch.hs:157\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>RetryConfig<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I create a JSON schema for string enumerations like Priority?\nSymbol: stringEnumSchema\nModule: Tidepool.StructuredOutput.Generic\nPackage: tidepool-core\nSignature: stringEnumSchema :: [String] -> JSONSchema Generate a string enum schema. For nullary sum types like `data Priority = Low | Medium | High` , generates `{\"type\": \"string\", \"enum\": [ Low , Medium , High ]}` instead of wasteful oneOf with tag+contents encoding.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: JSONSchema, Generate, For, Priority, Low, Medium, High\n  References: Generic.hs:319, Generic.hs:320, Generic.hs:337\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>JSONSchema<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When should I use pre-filled annotations?\nSymbol: formatModelTurnWithHole\nModule: Tidepool.Training.Format\nPackage: tidepool-training-generator\nSignature: formatModelTurnWithHole :: Text Format model turn with hole for selected symbols.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Format\n  References: Format.hs:10, Format.hs:71, Format.hs:72, Format.hs:95, Format.hs:149\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to GraphInfo?\nSymbol: toStateDiagram\nModule: Tidepool.Graph.Mermaid\nPackage: tidepool-core\nSignature: toStateDiagram :: GraphInfo -> Text\n\nCandidates:\n  Fields: (none)\n  Inputs: GraphInfo\n  Output: (none)\n  References: Mermaid.hs:35, Mermaid.hs:387, Mermaid.hs:388\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Value into ParseDiagnostic?\nSymbol: expectedArray\nModule: Tidepool.StructuredOutput.Error\nPackage: tidepool-core\nSignature: expectedArray :: [Text] -> Value -> ParseDiagnostic Error for when an array was expected.\n\nCandidates:\n  Fields: (none)\n  Inputs: Value\n  Output: ParseDiagnostic, Error\n  References: Error.hs:14, Error.hs:49, Error.hs:50, Instances.hs:45, Instances.hs:128, Instances.hs:136, Instances.hs:166\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Value,ParseDiagnostic<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming SetThinking into UI?\nSymbol: SetThinking\nModule: Tidepool.Effects.UI\nPackage: tidepool-core\nSignature: SetThinking :: Bool %1 -> UI () Set the \"thinking\" indicator state.\n\nCandidates:\n  Fields: (none)\n  Inputs: SetThinking\n  Output: UI\n  References: UI.hs:124, UI.hs:203\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform MemoryInfo into Render?\nSymbol: renderMemoryComment\nModule: Tidepool.Graph.Mermaid\nPackage: tidepool-core\nSignature: renderMemoryComment :: Maybe MemoryInfo -> Text Render memory comment.\n\nCandidates:\n  Fields: (none)\n  Inputs: MemoryInfo\n  Output: Render\n  References: Mermaid.hs:182, Mermaid.hs:218, Mermaid.hs:219, Mermaid.hs:220\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>MemoryInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When is barrier synchronization unnecessary?\nSymbol: RuntimeBarrier\nModule: Tidepool.Graph.Reify\nPackage: tidepool-core\nSignature: RuntimeBarrier :: RuntimeNodeKind Barrier node - collects parallel results\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: RuntimeBarrier, RuntimeNodeKind, Barrier\n  References: Reify.hs:201, Reify.hs:720, Mermaid.hs:190, Mermaid.hs:249, Mermaid.hs:259, Mermaid.hs:420, Export.hs:284\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Value into Ollama or Response or ScoreConfig?\nSymbol: extractSelectedFromToolCall\nModule: Tidepool.Control.Scout.Teach.Gemma\nPackage: tidepool-control-server\nSignature: extractSelectedFromToolCall :: Value -> Either Text [Text] Extract selected symbols array from Ollama tool call response. Response format: { \"message\": { \"tool_calls\": [{ \"function\": { \"arguments\": { \"selected\": [ `ScoreConfig` , `EdgeContext` ] } } }] } }\n\nCandidates:\n  Fields: (none)\n  Inputs: Value\n  Output: Extract, Ollama, Response, ScoreConfig, EdgeContext\n  References: Gemma.hs:294, Gemma.hs:309, Gemma.hs:310\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Value,Extract,Ollama<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I look up a node definition by name?\nSymbol: GetNodeDef\nModule: Tidepool.Graph.Generic\nPackage: tidepool-core\nSignature: GetNodeDef\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetNodeDef\n  References: Generic.hs:81, Generic.hs:1050, Generic.hs:1051, Interpret.hs:77, Interpret.hs:904, Interpret.hs:905, Interpret.hs:907, Interpret.hs:946, Interpret.hs:950, Interpret.hs:964, Interpret.hs:969, Interpret.hs:901, Interpret.hs:913, Interpret.hs:945, Interpret.hs:949, Interpret.hs:963, Interpret.hs:968\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetNodeDef<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When is exit type statically known?\nSymbol: GetExitType\nModule: Tidepool.Graph.Generic\nPackage: tidepool-core\nSignature: GetExitType\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetExitType\n  References: Generic.hs:107, Generic.hs:1130, Generic.hs:1131, Generic.hs:1132, Generic.hs:1132, Generic.hs:1133, Generic.hs:1133, Generic.hs:1134, Generic.hs:1135, Generic.hs:1136, Generic.hs:1136, Generic.hs:1136, Generic.hs:1137\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming ToolInfo into ToolExport?\nSymbol: toolToExport\nModule: Tidepool.Graph.Export\nPackage: tidepool-core\nSignature: toolToExport :: ToolInfo -> ToolExport\n\nCandidates:\n  Fields: (none)\n  Inputs: ToolInfo\n  Output: ToolExport\n  References: Export.hs:219, Export.hs:261, Export.hs:262\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform GetTasks and TaskType into Habitica or HabiticaTask?\nSymbol: GetTasks\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: GetTasks :: TaskType %1 -> Habitica [HabiticaTask]\n\nCandidates:\n  Fields: (none)\n  Inputs: GetTasks, TaskType\n  Output: Habitica, HabiticaTask\n  References: Habitica.hs:72, Habitica.hs:103, Habitica.hs:151\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetTasks,TaskType,Habitica,HabiticaTask<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Type and Monadic and When into Note?\nSymbol: runMemory\nModule: Tidepool.Graph.Memory\nPackage: tidepool-core\nSignature: runMemory :: forall s (effs :: [Type -> Type]) a. s -> Eff (Memory s : effs) a -> Eff effs (a, s) Monadic version for updates that need effects. When you need to compute the new value using effects, use getMem/updateMem: s <- getMem @Cache newEntries <- filterM (fmap not . isExpired) s.entries updateMem @Cache $ \\c -> c { entries = newEntries } Note: This pattern isn't atomic, but that's fine for sequential execution. For concurrent access, you'd need STM-based persistence anyway. Run memory effect with an initial value, returning final state. This is the basic interpreter using freer-simple's handleRelayS. (result, finalState) <- runMemory initialState $ do updateMem (+ 1) getMem\n\nCandidates:\n  Fields: (none)\n  Inputs: Type, Monadic, When\n  Output: Note, This, For, STM-based, Run\n  References: Memory.hs:63, Memory.hs:76, Memory.hs:204, Memory.hs:205, Memory.hs:213, Memory.hs:450, Graph.hs:101\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Type,Monadic,Note<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform MermaidConfig and NodeInfo into Render?\nSymbol: renderNodeWithComments\nModule: Tidepool.Graph.Mermaid\nPackage: tidepool-core\nSignature: renderNodeWithComments :: MermaidConfig -> NodeInfo -> [Text] Render a node with optional structured comments.\n\nCandidates:\n  Fields: (none)\n  Inputs: MermaidConfig, NodeInfo\n  Output: Render\n  References: Mermaid.hs:161, Mermaid.hs:164, Mermaid.hs:165\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>MermaidConfig,NodeInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming FilePath into DependencyTree or Build or Recursively?\nSymbol: buildDependencyTree\nModule: Tidepool.Template.DependencyTree\nPackage: tidepool-core\nSignature: buildDependencyTree :: FilePath -> IO DependencyTree Build a dependency tree starting from a root template. Recursively parses all included and extended templates to build a complete dependency graph.\n\nCandidates:\n  Fields: (none)\n  Inputs: FilePath\n  Output: DependencyTree, Build, Recursively\n  References: DependencyTree.hs:37, DependencyTree.hs:102, DependencyTree.hs:153, DependencyTree.hs:154\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform ScoringContext into Render?\nSymbol: renderPatterns\nModule: Tidepool.Control.Scout.Templates\nPackage: tidepool-control-server\nSignature: renderPatterns :: ScoringContext -> Text Render patterns section if present.\n\nCandidates:\n  Fields: (none)\n  Inputs: ScoringContext\n  Output: Render\n  References: Templates.hs:93, Templates.hs:105, Templates.hs:106\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>ScoringContext<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming ApiKey into Unwrap or API?\nSymbol: getApiKey\nModule: Tidepool.LLM.Types\nPackage: unknown\nSignature: getApiKey :: ApiKey -> Text Unwrap an API key to get the underlying text.\n\nCandidates:\n  Fields: (none)\n  Inputs: ApiKey\n  Output: Unwrap, API\n  References: Interpreter.hs:72, Interpreter.hs:108, Interpreter.hs:150, Types.hs:41, Types.hs:85, Types.hs:86\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform ToolInput into ToolOutput or Tool?\nSymbol: toolExecute\nModule: Tidepool.Graph.Tool\nPackage: tidepool-core\nSignature: toolExecute :: forall t. ToolDef t => t -> ToolInput t -> Eff (ToolEffects t) (ToolOutput t) Tool implementation. Takes the tool value (for config) and input, returns output in the tool's effect stack.\n\nCandidates:\n  Fields: (none)\n  Inputs: ToolInput\n  Output: ToolOutput, Tool, Takes\n  References: Tool.hs:180\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>ToolInput,ToolOutput,Tool<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with ServerConfig?\nSymbol: runServer\nModule: Tidepool.Control.Server\nPackage: tidepool-control-server\nSignature: runServer :: ServerConfig -> IO ()\n\nCandidates:\n  Fields: (none)\n  Inputs: ServerConfig\n  Output: (none)\n  References: Server.hs:10, Server.hs:52, Server.hs:53\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>ServerConfig<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming CabalTestSuccess into CabalResult?\nSymbol: CabalTestSuccess\nModule: Tidepool.Effects.Cabal\nPackage: tidepool-core\nSignature: CabalTestSuccess :: Text %1 -> CabalResult\n\nCandidates:\n  Fields: (none)\n  Inputs: CabalTestSuccess\n  Output: CabalResult\n  References: Cabal.hs:122, Cabal.hs:123, Cabal.hs:151\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Name into UsesEnum?\nSymbol: deriveUsesEnum\nModule: Tidepool.Schema\nPackage: tidepool-core\nSignature: deriveUsesEnum :: Name -> Q [Dec] Derive a `UsesEnum` instance for a type.\n\nCandidates:\n  Fields: (none)\n  Inputs: Name\n  Output: Dec, Derive, UsesEnum\n  References: Schema.hs:40, Schema.hs:264, Schema.hs:265\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I find uncommitted files in the working directory?\nSymbol: GetDirtyFiles\nModule: Tidepool.Effects.Git\nPackage: tidepool-core\nSignature: GetDirtyFiles :: Git [FilePath] Get list of dirty (uncommitted) files.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetDirtyFiles, Git, FilePath, Get\n  References: Git.hs:87, Git.hs:106\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetDirtyFiles,Git<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming AsHandler into Run?\nSymbol: runGraphWithSpans\nModule: Tidepool.Graph.Interpret.Instrumented\nPackage: tidepool-core\nSignature: runGraphWithSpans :: forall (graph :: Type -> Type) entryType (targets :: [Type]) exitType (es :: [Effect]) (entryHandlerName :: Symbol) handler. (Generic (graph AsGraph), FindEntryHandler entryType (FieldsWithNamesOf graph) ~ 'Just entryHandlerName, KnownSymbol entryHandlerName, HasField entryHandlerName (graph (AsHandler es)) handler, CallHandler handler entryType es targets, DispatchGotoTraced graph targets es exitType, Member Observability es) => graph (AsHandler es) -> entryType -> Eff es exitType Run a graph with automatic span emission for each node transition. Creates a root span for the graph and child spans for each handler invocation. result <- runGraphWithSpans @MyGraph handlers inputValue\n\nCandidates:\n  Fields: (none)\n  Inputs: AsHandler\n  Output: Run, Creates\n  References: Instrumented.hs:44, Instrumented.hs:121, Instrumented.hs:134\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When should I let user errors propagate?\nSymbol: GetUserTry\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: GetUserTry :: Habitica (Either HabiticaError UserInfo)\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetUserTry, Habitica, HabiticaError, UserInfo\n  References: Habitica.hs:78, Habitica.hs:120, Habitica.hs:165\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I retrieve the conversation message history?\nSymbol: getHistory\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: getHistory :: forall (effs :: [Type -> Type]). Member ChatHistory effs => Eff effs [Message]\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Message\n  References: Types.hs:45, Types.hs:516, Types.hs:517\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Message<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Repo into PullRequest?\nSymbol: getPullRequest\nModule: Tidepool.Effects.GitHub\nPackage: tidepool-core\nSignature: getPullRequest :: forall (effs :: [Type -> Type]). Member GitHub effs => Repo -> Int -> Bool -> Eff effs (Maybe PullRequest)\n\nCandidates:\n  Fields: (none)\n  Inputs: Repo\n  Output: PullRequest\n  References: GitHub.hs:27, GitHub.hs:327, GitHub.hs:328\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming LLMConfig into LLMEnv?\nSymbol: mkLLMEnv\nModule: Tidepool.LLM.Types\nPackage: unknown\nSignature: mkLLMEnv :: LLMConfig -> IO LLMEnv\n\nCandidates:\n  Fields: (none)\n  Inputs: LLMConfig\n  Output: LLMEnv\n  References: Interpreter.hs:31, Interpreter.hs:69, Types.hs:47, Types.hs:145, Types.hs:146\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with SubgraphState?\nSymbol: runSubgraph\nModule: Tidepool.Actor.Subgraph\nPackage: tidepool-actor\nSignature: runSubgraph :: forall entry result (effs :: [Type -> Type]) a. LastMember IO effs => SubgraphState entry result -> Eff (Subgraph entry result : effs) a -> Eff effs a\n\nCandidates:\n  Fields: (none)\n  Inputs: SubgraphState\n  Output: (none)\n  References: Subgraph.hs:55, Subgraph.hs:303, Subgraph.hs:309\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>SubgraphState<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform ToolInfo into ToolExport?\nSymbol: toolToExport\nModule: Tidepool.Graph.Export\nPackage: tidepool-core\nSignature: toolToExport :: ToolInfo -> ToolExport\n\nCandidates:\n  Fields: (none)\n  Inputs: ToolInfo\n  Output: ToolExport\n  References: Export.hs:219, Export.hs:261, Export.hs:262\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>ToolInfo,ToolExport<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Type into Useful?\nSymbol: evalMemory\nModule: Tidepool.Graph.Memory\nPackage: tidepool-core\nSignature: evalMemory :: forall s (effs :: [Type -> Type]) a. s -> Eff (Memory s : effs) a -> Eff effs a Run memory effect purely, returning only the result. Useful when you don't need the final state.\n\nCandidates:\n  Fields: (none)\n  Inputs: Type\n  Output: Run, Useful\n  References: Memory.hs:78, Memory.hs:212, Memory.hs:213, Memory.hs:217, Memory.hs:219, Graph.hs:102\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Type,Useful<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming SProvider and LLMProviderConfig and Value into LLMProviderResponse?\nSymbol: complete\nModule: Tidepool.Effects.LLMProvider\nPackage: tidepool-core\nSignature: complete :: forall (p :: LLMProvider) (effs :: [Type -> Type]). Member LLMComplete effs => SProvider p -> LLMProviderConfig p -> Text -> Maybe [Value] -> Eff effs (LLMProviderResponse p)\n\nCandidates:\n  Fields: (none)\n  Inputs: SProvider, LLMProviderConfig, Value\n  Output: LLMProviderResponse\n  References: LLMProvider.hs:32, LLMProvider.hs:335, LLMProvider.hs:342\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Parser and GraphEntryType and AsHandler into LLM/IO or Example or CLI\"?\nSymbol: runGraphCLIPure\nModule: Tidepool.Graph.CLI\nPackage: tidepool-core\nSignature: runGraphCLIPure :: forall (graph :: Type -> Type) (entryHandlerName :: Symbol) handler (targets :: [Type]). (Show (GraphExitType graph), ToJSON (GraphExitType graph), Generic (graph AsGraph), FindEntryHandler (GraphEntryType graph) (FieldsWithNamesOf graph) ~ 'Just entryHandlerName, KnownSymbol entryHandlerName, HasField entryHandlerName (graph (AsHandler '[])) handler, CallHandler handler (GraphEntryType graph) '[] targets, DispatchGoto graph targets '[] (GraphExitType graph)) => Text -> Parser (GraphEntryType graph) -> graph (AsHandler '[]) -> IO () Run a logic-only graph (no LLM/IO effects) as CLI. This wires a graph with empty effect stack `'[]` directly to CLI. For graphs with LLM/IO effects, use `runGraphCLI` from tidepool-platform. # Example main :: IO () main = runGraphCLIPure \"Counter graph CLI\" $(deriveCLIParser ''CounterInput) counterHandlers # Constraints The graph must: + Have `EntryNode` and `Exit` fields (detected via `GraphEntryType` and `GraphExitType` ) + Have a handler that accepts the entry type via `Needs` (found via `FindEntryHandler` ) + Use empty effect stack `'[]` (all handlers must be pure) + Exit type must have `Show` and `ToJSON` instances for output formatting\n\nCandidates:\n  Fields: (none)\n  Inputs: Parser, GraphEntryType, AsHandler\n  Output: Run, LLM/IO, CLI., This, For, Example, CLI\", Constraints, The, Have, EntryNode, Exit, GraphEntryType, GraphExitType, Needs, FindEntryHandler, Use, Show, ToJSON\n  References: CLI.hs:75, CLI.hs:513, CLI.hs:528\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Parser,GraphEntryType,LLM/IO<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform CabalClean and FilePath into Cabal or CabalResult or Clean?\nSymbol: CabalClean\nModule: Tidepool.Effects.Cabal\nPackage: tidepool-core\nSignature: CabalClean :: FilePath %1 -> Cabal CabalResult Clean build artifacts. Equivalent to `cabal clean` . Returns `CabalSuccess` or `CabalBuildFailure` .\n\nCandidates:\n  Fields: (none)\n  Inputs: CabalClean, FilePath\n  Output: Cabal, CabalResult, Clean, Equivalent, Returns, CabalSuccess, CabalBuildFailure\n  References: Cabal.hs:161, Cabal.hs:206\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>CabalClean,FilePath,Cabal,CabalResult<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming CompletionItemKind into CompletionItemKind?\nSymbol: fromCompletionItemKind\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromCompletionItemKind :: CompletionItemKind -> CompletionItemKind\n\nCandidates:\n  Fields: (none)\n  Inputs: CompletionItemKind\n  Output: CompletionItemKind\n  References: Interpreter.hs:406, Interpreter.hs:417, Interpreter.hs:418\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform CabalTestSuccess into CabalResult?\nSymbol: CabalTestSuccess\nModule: Tidepool.Effects.Cabal\nPackage: tidepool-core\nSignature: CabalTestSuccess :: Text %1 -> CabalResult\n\nCandidates:\n  Fields: (none)\n  Inputs: CabalTestSuccess\n  Output: CabalResult\n  References: Cabal.hs:122, Cabal.hs:123, Cabal.hs:151\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>CabalTestSuccess,CabalResult<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with JSONSchema?\nSymbol: isEmptyObject\nModule: Tidepool.StructuredOutput.Generic\nPackage: tidepool-core\nSignature: isEmptyObject :: JSONSchema -> Bool\n\nCandidates:\n  Fields: (none)\n  Inputs: JSONSchema\n  Output: (none)\n  References: Generic.hs:303, Generic.hs:308, Generic.hs:309\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>JSONSchema<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform NodeInfo into LLM?\nSymbol: renderNodeComments\nModule: Tidepool.Graph.Mermaid\nPackage: tidepool-core\nSignature: renderNodeComments :: NodeInfo -> [Text] Render structured comments for a node (for LLM context).\n\nCandidates:\n  Fields: (none)\n  Inputs: NodeInfo\n  Output: Render, LLM\n  References: Mermaid.hs:169, Mermaid.hs:174, Mermaid.hs:175\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>NodeInfo,LLM<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I wrap node execution in an observability span?\nSymbol: withNodeSpan\nModule: Tidepool.Graph.Interpret.Instrumented\nPackage: tidepool-core\nSignature: withNodeSpan :: forall (es :: [Type -> Type]) a. Member Observability es => Text -> Eff es a -> Eff es a Wrap a handler call with span emission for a named node. This extracts the common pattern of: 1. Start span for node 2. Execute action 3. End span Used by `DispatchGotoTraced` instances to reduce duplication. The span name follows the pattern `node: <handler-name>` .\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Wrap, This, Start, Execute, End, Used, DispatchGotoTraced, The\n  References: Instrumented.hs:47, Instrumented.hs:97, Instrumented.hs:102, Instrumented.hs:155, Instrumented.hs:205, Instrumented.hs:222\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Wrap<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I tokenize symbol names from LSP output?\nSymbol: parseSymbolTokens\nModule: Tidepool.Control.Scout.Teach.Gemma\nPackage: tidepool-control-server\nSignature: parseSymbolTokens :: Text -> [Text] Parse symbol tokens from a space/comma separated string. Handles various formats: \"ScoreConfig Rubric EdgeContext\" \"ScoreConfig, Rubric, EdgeContext\" \"ScoreConfig,Rubric,EdgeContext\"\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Parse, Handles, Rubric, EdgeContext\"\n  References: Gemma.hs:42, Gemma.hs:350, Gemma.hs:351\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Parse,Handles<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Type into GraphContext?\nSymbol: runGraphContext\nModule: Tidepool.Effect.GraphContext\nPackage: tidepool-core\nSignature: runGraphContext :: forall entry (effs :: [Type -> Type]) a. entry -> Eff (GraphContext entry : effs) a -> Eff effs a Run GraphContext effect with a fixed entry value. Typically provided by the graph runner when spawning a graph. For recursive execution, each child graph gets its own entry. -- In graph runner runGraphContext scaffoldInput $ do ... -- all handlers can now call getEntry\n\nCandidates:\n  Fields: (none)\n  Inputs: Type\n  Output: Run, GraphContext, Typically, For, In\n  References: GraphContext.hs:59, GraphContext.hs:182, GraphContext.hs:186\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Type,GraphContext<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming IORef into Memory or Each or IORef?\nSymbol: runMemoryWithIORef\nModule: Tidepool.Actor.Graph\nPackage: tidepool-actor\nSignature: runMemoryWithIORef :: forall s (effs :: [Type -> Type]) a. LastMember IO effs => IORef s -> Eff (Memory s : effs) a -> Eff effs a Run the Memory effect using an IORef. Each actor should have its own IORef, providing isolated persistent state. memRef <- newIORef initialState let interpreter = runM . runMemoryWithIORef memRef . runOtherEffects\n\nCandidates:\n  Fields: (none)\n  Inputs: IORef\n  Output: Run, Memory, IORef., Each, IORef\n  References: Graph.hs:59, Graph.hs:248, Graph.hs:254, Graph.hs:423\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming FilePath and FilePath and FilePath and FilePath into FilePath or Recursively?\nSymbol: buildTreeFrom\nModule: Tidepool.Template.DependencyTree\nPackage: tidepool-core\nSignature: buildTreeFrom :: FilePath -> Set FilePath -> Map FilePath [FilePath] -> Map FilePath [FilePath] -> IO (Map FilePath [FilePath], Map FilePath [FilePath]) Recursively build dependency maps.\n\nCandidates:\n  Fields: (none)\n  Inputs: FilePath, FilePath, FilePath, FilePath\n  Output: FilePath, Recursively\n  References: DependencyTree.hs:155, DependencyTree.hs:163, DependencyTree.hs:169, DependencyTree.hs:193\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When is tool description irrelevant?\nSymbol: toolDescription\nModule: Tidepool.Graph.Tool\nPackage: tidepool-core\nSignature: toolDescription :: forall t. ToolDef t => t -> Text Human-readable description (shown to LLM). The `t` value is passed in case the tool marker carries config.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Human-readable, LLM., The\n  References: Convert.hs:73, Convert.hs:93, Convert.hs:103, Convert.hs:123, Tool.hs:174, Tool.hs:252\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming ImageSource into ContentBlock or Build?\nSymbol: withImages\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: withImages :: Text -> [ImageSource] -> [ContentBlock] Build content blocks from text + images\n\nCandidates:\n  Fields: (none)\n  Inputs: ImageSource\n  Output: ContentBlock, Build\n  References: Types.hs:60, Types.hs:380, Types.hs:381\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if I already have a structured URL?\nSymbol: parseBaseUrl\nModule: Tidepool.LLM.Interpreter\nPackage: unknown\nSignature: parseBaseUrl :: Text -> BaseUrl\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: BaseUrl\n  References: Interpreter.hs:42, Interpreter.hs:104, Interpreter.hs:146, Interpreter.hs:185, Interpreter.hs:186\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When is sequential execution preferred?\nSymbol: RuntimeFork\nModule: Tidepool.Graph.Reify\nPackage: tidepool-core\nSignature: RuntimeFork :: RuntimeNodeKind Fork node - spawns parallel workers\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: RuntimeFork, RuntimeNodeKind, Fork\n  References: Reify.hs:200, Reify.hs:695, Mermaid.hs:189, Mermaid.hs:248, Mermaid.hs:258, Mermaid.hs:419, Export.hs:283\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform CreateWorktree and WorktreeSpec into Worktree or WorktreeError or WorktreePath?\nSymbol: CreateWorktree\nModule: Tidepool.Effects.Worktree\nPackage: tidepool-core\nSignature: CreateWorktree :: WorktreeSpec %1 -> Worktree (Either WorktreeError WorktreePath) Create a new worktree with a branch. Returns the path to the created worktree, or an error.\n\nCandidates:\n  Fields: (none)\n  Inputs: CreateWorktree, WorktreeSpec\n  Output: Worktree, WorktreeError, WorktreePath, Create, Returns\n  References: Worktree.hs:185, Worktree.hs:232\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>CreateWorktree,WorktreeSpec,Worktree,WorktreeError<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When should I use standard error types?\nSymbol: customError\nModule: Tidepool.StructuredOutput.Error\nPackage: tidepool-core\nSignature: customError :: [Text] -> Text -> ParseDiagnostic\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: ParseDiagnostic\n  References: Error.hs:20, Error.hs:109, Error.hs:110\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I format a complete training example?\nSymbol: formatSelectSymbolsExample\nModule: Tidepool.Training.Format\nPackage: tidepool-training-generator\nSignature: formatSelectSymbolsExample :: Text -> Text -> Text -> Text -> Maybe Text -> [Text] -> ByteString Format complete training example as JSONL line. Lean format: Module + Package + cleaned signature + first-sentence docs.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Format, JSONL, Lean, Module, Package\n  References: Format.hs:4, Format.hs:83, Format.hs:91, Export.hs:39, Export.hs:410, Export.hs:694\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Format,JSONL<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform JSONSchema into Value or Aeson or Schema?\nSymbol: schemaToValue\nModule: Tidepool.Schema\nPackage: tidepool-core\nSignature: schemaToValue :: JSONSchema -> Value Convert schema to Aeson Value (JSON Schema draft-07 format) Note: Anthropic API requires additionalProperties: false on all object types\n\nCandidates:\n  Fields: (none)\n  Inputs: JSONSchema\n  Output: Value, Convert, Aeson, JSON, Schema, Note, Anthropic, API\n  References: [many references (23) - hub symbol]\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>JSONSchema,Value<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I retrieve dependencies of a bead?\nSymbol: getDeps\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: getDeps :: forall (effs :: [Type -> Type]). Member BD effs => Text -> Eff effs [BeadInfo] Get dependencies (beads this one depends on).\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: BeadInfo, Get\n  References: BD.hs:36, BD.hs:377, BD.hs:378\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>BeadInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming GetTasksTry and TaskType into Habitica or HabiticaError or HabiticaTask?\nSymbol: GetTasksTry\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: GetTasksTry :: TaskType %1 -> Habitica (Either HabiticaError [HabiticaTask])\n\nCandidates:\n  Fields: (none)\n  Inputs: GetTasksTry, TaskType\n  Output: Habitica, HabiticaError, HabiticaTask\n  References: Habitica.hs:80, Habitica.hs:126, Habitica.hs:171\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When is node-level tracing overkill?\nSymbol: withNodeSpan\nModule: Tidepool.Graph.Interpret.Instrumented\nPackage: tidepool-core\nSignature: withNodeSpan :: forall (es :: [Type -> Type]) a. Member Observability es => Text -> Eff es a -> Eff es a Wrap a handler call with span emission for a named node. This extracts the common pattern of: 1. Start span for node 2. Execute action 3. End span Used by `DispatchGotoTraced` instances to reduce duplication. The span name follows the pattern `node: <handler-name>` .\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Wrap, This, Start, Execute, End, Used, DispatchGotoTraced, The\n  References: Instrumented.hs:47, Instrumented.hs:97, Instrumented.hs:102, Instrumented.hs:155, Instrumented.hs:205, Instrumented.hs:222\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming GetTasksTry and TaskType into Habitica or HabiticaError or HabiticaTask?\nSymbol: GetTasksTry\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: GetTasksTry :: TaskType %1 -> Habitica (Either HabiticaError [HabiticaTask])\n\nCandidates:\n  Fields: (none)\n  Inputs: GetTasksTry, TaskType\n  Output: Habitica, HabiticaError, HabiticaTask\n  References: Habitica.hs:80, Habitica.hs:126, Habitica.hs:171\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is a logic node for pure routing?\nSymbol: RuntimeLogic\nModule: Tidepool.Graph.Reify\nPackage: tidepool-core\nSignature: RuntimeLogic :: RuntimeNodeKind Pure routing logic\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: RuntimeLogic, RuntimeNodeKind, Pure\n  References: Reify.hs:199, Reify.hs:413, Reify.hs:790, Mermaid.hs:188, Mermaid.hs:247, Mermaid.hs:257, Mermaid.hs:418, Export.hs:282\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>RuntimeLogic,RuntimeNodeKind<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming MergeAccumulator into HList or FromPayloads?\nSymbol: getCompletedResults\nModule: Tidepool.Actor.Merge\nPackage: tidepool-actor\nSignature: getCompletedResults :: forall (sources :: [Type]) key. (ExtractMergeResults sources, Hashable key) => MergeAccumulator key -> key -> IO (Maybe (Either Text (HList (FromPayloads sources))))\n\nCandidates:\n  Fields: (none)\n  Inputs: MergeAccumulator\n  Output: HList, FromPayloads\n  References: Merge.hs:16, Merge.hs:238, Merge.hs:246, Barrier.hs:57, Barrier.hs:180\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When is entry type known at compile time?\nSymbol: GetEntryType\nModule: Tidepool.Graph.Validate.RecordStructure\nPackage: tidepool-core\nSignature: GetEntryType\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetEntryType\n  References: RecordStructure.hs:91, RecordStructure.hs:92, RecordStructure.hs:93, RecordStructure.hs:93, RecordStructure.hs:94, RecordStructure.hs:94, RecordStructure.hs:95, RecordStructure.hs:96, RecordStructure.hs:97, RecordStructure.hs:97, RecordStructure.hs:97, RecordStructure.hs:98, RecordStructure.hs:133\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform MemoryStore into MemoryStore or Type?\nSymbol: setScope\nModule: Tidepool.Graph.Memory\nPackage: tidepool-core\nSignature: setScope :: forall s. ToJSON s => Text -> s -> MemoryStore -> MemoryStore Set a scope in the store, serializing the value. The value is immediately serialized to JSON. Type information is not stored - type checking happens at access time via `getScope` .\n\nCandidates:\n  Fields: (none)\n  Inputs: MemoryStore\n  Output: MemoryStore, The, JSON., Type\n  References: Memory.hs:90, Memory.hs:411, Memory.hs:417, Memory.hs:453\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>MemoryStore<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if I need to ignore working directory state?\nSymbol: getDirtyFiles\nModule: Tidepool.Effects.Git\nPackage: tidepool-core\nSignature: getDirtyFiles :: forall (effs :: [Type -> Type]). Member Git effs => Eff effs [FilePath] Get list of dirty files.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: FilePath, Get\n  References: Git.hs:21, Git.hs:105, Git.hs:106\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Position into Position?\nSymbol: toPosition\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: toPosition :: Position -> Position\n\nCandidates:\n  Fields: (none)\n  Inputs: Position\n  Output: Position\n  References: Interpreter.hs:189, Interpreter.hs:195, Interpreter.hs:205, Interpreter.hs:219, Interpreter.hs:235, Interpreter.hs:272, Interpreter.hs:273, Interpreter.hs:280, Interpreter.hs:281\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When should I avoid triggering builds?\nSymbol: cabalBuild\nModule: Tidepool.Effects.Cabal\nPackage: tidepool-core\nSignature: cabalBuild :: forall (effs :: [Type -> Type]). Member Cabal effs => String -> Eff effs CabalResult\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: CabalResult\n  References: Cabal.hs:36, Cabal.hs:178, Cabal.hs:182\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I do to skip initializing an empty JSONSchema or Empty?\nSymbol: emptySchema\nModule: Tidepool.Schema\nPackage: tidepool-core\nSignature: emptySchema :: SchemaType -> JSONSchema Empty schema of given type\n\nCandidates:\n  Fields: (none)\n  Inputs: SchemaType\n  Output: JSONSchema, Empty\n  References: [many references (36) - hub symbol]\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Stack into Check?\nSymbol: isEmpty\nModule: Data.Stack\nPackage: tidepool-core\nSignature: isEmpty :: forall a. Stack a -> Bool Check if the stack is empty. ### Laws isEmpty empty == True isEmpty (push x s) == False ### Time Complexity O(1)\n\nCandidates:\n  Fields: (none)\n  Inputs: Stack\n  Output: Check, Laws, True, False, Time, Complexity, O1\n  References: Stack.hs:9, Stack.hs:37, Stack.hs:111, Stack.hs:112\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform CabalTest and FilePath into Cabal or CabalResult or Equivalent?\nSymbol: CabalTest\nModule: Tidepool.Effects.Cabal\nPackage: tidepool-core\nSignature: CabalTest :: FilePath %1 -> Cabal CabalResult Run tests. Equivalent to `cabal test --test-show-details=always` . Returns `CabalTestSuccess` or `CabalTestFailure` with parsed failures. Returns `CabalBuildFailure` if build fails.\n\nCandidates:\n  Fields: (none)\n  Inputs: CabalTest, FilePath\n  Output: Cabal, CabalResult, Run, Equivalent, Returns, CabalTestSuccess, CabalTestFailure, CabalBuildFailure\n  References: Cabal.hs:153, Cabal.hs:197\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>CabalTest,FilePath,Cabal,CabalResult<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform HashMap and Value into HList or FromPayloads?\nSymbol: extractMergeResults\nModule: Tidepool.Actor.Merge\nPackage: tidepool-actor\nSignature: extractMergeResults :: forall (sources :: [Type]). ExtractMergeResults sources => HashMap Text Value -> Either Text (HList (FromPayloads sources))\n\nCandidates:\n  Fields: (none)\n  Inputs: HashMap, Value\n  Output: HList, FromPayloads\n  References: Merge.hs:198, Merge.hs:201, Merge.hs:208, Merge.hs:215, Merge.hs:252\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>HashMap,Value,HList,FromPayloads<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform CompleteTry and LLMProvider. and SProvider and LLMProviderConfig and Value into LLMComplete or LLMError or LLMProviderResponse?\nSymbol: CompleteTry\nModule: Tidepool.Effects.LLMProvider\nPackage: tidepool-core\nSignature: CompleteTry :: forall (p :: LLMProvider). SProvider p %1 -> LLMProviderConfig p %1 -> Text %1 -> Maybe [Value] %1 -> LLMComplete (Either LLMError (LLMProviderResponse p))\n\nCandidates:\n  Fields: (none)\n  Inputs: CompleteTry, LLMProvider., SProvider, LLMProviderConfig, Value\n  Output: LLMComplete, LLMError, LLMProviderResponse\n  References: LLMProvider.hs:300, LLMProvider.hs:320, LLMProvider.hs:364, Interpreter.hs:255, Interpreter.hs:291, Interpreter.hs:294\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>CompleteTry,LLMProvider.,LLMComplete,LLMError<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if I only care about committed changes?\nSymbol: GetDirtyFiles\nModule: Tidepool.Effects.Git\nPackage: tidepool-core\nSignature: GetDirtyFiles :: Git [FilePath] Get list of dirty (uncommitted) files.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetDirtyFiles, Git, FilePath, Get\n  References: Git.hs:87, Git.hs:106\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming ClaudeCodeInfo into ClaudeCode?\nSymbol: renderClaudeCodeComment\nModule: Tidepool.Graph.Mermaid\nPackage: tidepool-core\nSignature: renderClaudeCodeComment :: Maybe ClaudeCodeInfo -> Text Render ClaudeCode comment.\n\nCandidates:\n  Fields: (none)\n  Inputs: ClaudeCodeInfo\n  Output: Render, ClaudeCode\n  References: Mermaid.hs:178, Mermaid.hs:223, Mermaid.hs:224, Mermaid.hs:225\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if I need flat bead structures?\nSymbol: getChildren\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: getChildren :: forall (effs :: [Type -> Type]). Member BD effs => Text -> Eff effs [BeadInfo] Get child beads (beads with this as parent).\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: BeadInfo, Get\n  References: BD.hs:39, BD.hs:389, BD.hs:390\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming AsHandler into GraphNode?\nSymbol: executeGraphNode\nModule: Tidepool.Graph.Interpret\nPackage: tidepool-core\nSignature: executeGraphNode :: forall (childGraph :: Type -> Type) (es :: [Effect]) entryType (targets :: [Type]) exitType (entryHandlerName :: Symbol) handler. (Generic (childGraph AsGraph), FindEntryHandler entryType (FieldsWithNamesOf childGraph) ~ 'Just entryHandlerName, KnownSymbol entryHandlerName, HasField entryHandlerName (childGraph (AsHandler es)) handler, CallHandler handler entryType es targets, DispatchGoto childGraph targets es exitType) => childGraph (AsHandler es) -> entryType -> Eff es exitType Execute a GraphNode by running the child graph to completion. The child graph's handlers must be provided. The input is passed to the child graph's EntryNode, and execution continues until Exit is reached. This function is a thin wrapper around `runGraph` that documents the GraphNode execution pattern. Use it in parent graph handlers when manually delegating to child graphs. -- In a parent graph handler: childResult <- executeGraphNode childHandlers input pure $ gotoChoice @\"nextNode\" childResult\n\nCandidates:\n  Fields: (none)\n  Inputs: AsHandler\n  Output: Execute, GraphNode, The, EntryNode, Exit, This, Use, In\n  References: Interpret.hs:574, Interpret.hs:586\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform MemoryStore into Nothing' or Left or Type?\nSymbol: getScope\nModule: Tidepool.Graph.Memory\nPackage: tidepool-core\nSignature: getScope :: forall s. FromJSON s => Text -> MemoryStore -> Either Text (Maybe s) Get a scope from the store, deserializing to the expected type. Returns 'Right Nothing' if the scope doesn't exist. Returns `Left` error if deserialization fails (type mismatch). Type safety is enforced by the `FromJSON` constraint - if the stored JSON doesn't match the expected type, parsing will fail with an error.\n\nCandidates:\n  Fields: (none)\n  Inputs: MemoryStore\n  Output: Get, Returns, Nothing', Left, Type, FromJSON, JSON\n  References: Memory.hs:89, Memory.hs:279, Memory.hs:364, Memory.hs:394, Memory.hs:399, Memory.hs:410, Memory.hs:428, Memory.hs:444\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>MemoryStore<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if entry is not needed for this node?\nSymbol: getEntry\nModule: Tidepool.Effect.GraphContext\nPackage: tidepool-core\nSignature: getEntry :: forall entry (effs :: [Type -> Type]). Member (GraphContext entry) effs => Eff effs entry Read the entry value that spawned this graph. Usage requires type application to specify the entry type: entry <- getEntry @ScaffoldInput let depth = entry.siCurrentDepth This value is constant for the lifetime of the graph instance. In recursive execution, each child sees its own entry.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Read, Usage, This, In\n  References: GraphContext.hs:52, GraphContext.hs:101, GraphContext.hs:105\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if I need to preserve camelCase?\nSymbol: camelToSnake\nModule: Tidepool.StructuredOutput.DecisionTools\nPackage: tidepool-core\nSignature: camelToSnake :: String -> String Convert PascalCase to snake_case. camelToSnake `ApproveRequest` = \"approve_request\"\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Convert, PascalCase, ApproveRequest\n  References: DecisionTools.hs:211, DecisionTools.hs:230, DecisionTools.hs:251, DecisionTools.hs:252\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform SymbolInformation into SymbolInformation?\nSymbol: fromSymbolInfo\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromSymbolInfo :: SymbolInformation -> SymbolInformation\n\nCandidates:\n  Fields: (none)\n  Inputs: SymbolInformation\n  Output: SymbolInformation\n  References: Interpreter.hs:448, Interpreter.hs:453, Interpreter.hs:454\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>SymbolInformation<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform ToolError into ToolError or Useful or ToolResult?\nSymbol: toolErrorToText\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: toolErrorToText :: ToolError -> Text Convert a ToolError to a human-readable message. Useful for compatibility with code expecting `Either Text ToolResult` .\n\nCandidates:\n  Fields: (none)\n  Inputs: ToolError\n  Output: Convert, ToolError, Useful, ToolResult\n  References: Types.hs:87, Types.hs:370, Types.hs:371\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>ToolError<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming JSONSchema into Extract?\nSymbol: extractSchemaFields\nModule: Tidepool.Graph.Reify\nPackage: tidepool-core\nSignature: extractSchemaFields :: JSONSchema -> [(Text, Text, Bool)] Extract fields from a JSONSchema. Returns (fieldName, fieldType, isRequired) for each property.\n\nCandidates:\n  Fields: (none)\n  Inputs: JSONSchema\n  Output: Extract, JSONSchema., Returns\n  References: Reify.hs:256, Reify.hs:257, Reify.hs:445\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to M1?\nSymbol: conName'\nModule: Tidepool.StructuredOutput.Generic\nPackage: tidepool-core\nSignature: conName' :: forall {k} (c :: Meta) (f :: k -> Type) (p :: k). Constructor c => M1 C c f p -> String\n\nCandidates:\n  Fields: (none)\n  Inputs: M1\n  Output: (none)\n  References: Generic.hs:259, Generic.hs:271, Generic.hs:280, Generic.hs:291, Generic.hs:292\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming WorkspaceSymbol into SymbolInformation?\nSymbol: fromWorkspaceSymbol\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromWorkspaceSymbol :: WorkspaceSymbol -> SymbolInformation\n\nCandidates:\n  Fields: (none)\n  Inputs: WorkspaceSymbol\n  Output: SymbolInformation\n  References: Interpreter.hs:450, Interpreter.hs:461, Interpreter.hs:462\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform AnthropicConfig and Value into AnthropicRequest or Build or Anthropic?\nSymbol: buildAnthropicRequest\nModule: Tidepool.LLM.Interpreter\nPackage: unknown\nSignature: buildAnthropicRequest :: AnthropicConfig -> Text -> Maybe [Value] -> AnthropicRequest Build Anthropic Messages API request. Tools should be in Anthropic format (with `input_schema` , not `parameters` ). Use `AnthropicTool` or `Tidepool.Tool.toolToJSON` which produce the correct format.\n\nCandidates:\n  Fields: (none)\n  Inputs: AnthropicConfig, Value\n  Output: AnthropicRequest, Build, Anthropic, Messages, API, Tools, Use, AnthropicTool, Tidepool.Tool.toolToJSON\n  References: Interpreter.hs:38, Interpreter.hs:106, Interpreter.hs:115, Interpreter.hs:116\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>AnthropicConfig,Value,AnthropicRequest,Build<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I convert Name to a Exp or Derive or JSONSchema or Haddock?\nSymbol: deriveJSONSchema\nModule: Tidepool.Schema\nPackage: tidepool-core\nSignature: deriveJSONSchema :: Name -> Q Exp Derive a JSONSchema from a record type, using Haddock comments as descriptions.\n\nCandidates:\n  Fields: (none)\n  Inputs: Name\n  Output: Exp, Derive, JSONSchema, Haddock\n  References: Schema.hs:37, Schema.hs:141, Schema.hs:142, Schema.hs:226\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Name<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to Type?\nSymbol: runState\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: runState :: forall s (effs :: [Type -> Type]) a. s -> Eff (State s : effs) a -> Eff effs (a, s)\n\nCandidates:\n  Fields: (none)\n  Inputs: Type\n  Output: (none)\n  References: Types.hs:90, Types.hs:167, Types.hs:168\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform TextEdit into TextEdit?\nSymbol: fromTextEdit\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromTextEdit :: TextEdit -> TextEdit\n\nCandidates:\n  Fields: (none)\n  Inputs: TextEdit\n  Output: TextEdit\n  References: Interpreter.hs:393, Interpreter.hs:397, Interpreter.hs:398\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>TextEdit<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I batch convert tools to Cloudflare format?\nSymbol: toolDefsToCf\nModule: Tidepool.Tool.Convert\nPackage: tidepool-core\nSignature: toolDefsToCf :: forall (f :: Type -> Type) t. (Functor f, ToCfTool t) => f t -> f CfTool Convert a collection of tools to CloudFlare AI format. tools :: [MyTool] cfTools :: [CfTool] cfTools = toolDefsToCf tools\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: CfTool, Convert, CloudFlare, AI, MyTool\n  References: Convert.hs:54, Convert.hs:148, Convert.hs:149\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>CfTool<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform LSPSession and Value into ControlResponse?\nSymbol: handleTeachTool\nModule: Tidepool.Control.Handler.MCP\nPackage: tidepool-control-server\nSignature: handleTeachTool :: LSPSession -> Text -> Value -> IO ControlResponse\n\nCandidates:\n  Fields: (none)\n  Inputs: LSPSession, Value\n  Output: ControlResponse\n  References: MCP.hs:33, MCP.hs:45, MCP.hs:46\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>LSPSession,Value,ControlResponse<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I convert  to a JSONSchema or Enum?\nSymbol: enumSchema\nModule: Tidepool.Schema\nPackage: tidepool-core\nSignature: enumSchema :: [Text] -> JSONSchema Enum schema combinator\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: JSONSchema, Enum\n  References: Schema.hs:19, Schema.hs:92, Schema.hs:93, Schema.hs:170, Instances.hs:30\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>JSONSchema<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I get repository and worktree metadata?\nSymbol: GetWorktreeInfo\nModule: Tidepool.Effects.Git\nPackage: tidepool-core\nSignature: GetWorktreeInfo :: Git (Maybe WorktreeInfo) Get worktree/repo information. Returns Nothing if not in a git repository.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetWorktreeInfo, Git, WorktreeInfo, Get, Returns, Nothing\n  References: Git.hs:84, Git.hs:102\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetWorktreeInfo,Git<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When can't automatic field schema derivation be applied?\nSymbol: deriveFieldSchema\nModule: Tidepool.Schema\nPackage: tidepool-core\nSignature: deriveFieldSchema :: Name -> Name -> Int -> VarBangType -> Q Exp Derive schema for a single field, requiring Haddock documentation.\n\nCandidates:\n  Fields: (none)\n  Inputs: Name, Name, VarBangType\n  Output: Exp, Derive, Haddock\n  References: Schema.hs:157, Schema.hs:179, Schema.hs:180\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Type and Monadic and When into Note?\nSymbol: runMemory\nModule: Tidepool.Graph.Memory\nPackage: tidepool-core\nSignature: runMemory :: forall s (effs :: [Type -> Type]) a. s -> Eff (Memory s : effs) a -> Eff effs (a, s) Monadic version for updates that need effects. When you need to compute the new value using effects, use getMem/updateMem: s <- getMem @Cache newEntries <- filterM (fmap not . isExpired) s.entries updateMem @Cache $ \\c -> c { entries = newEntries } Note: This pattern isn't atomic, but that's fine for sequential execution. For concurrent access, you'd need STM-based persistence anyway. Run memory effect with an initial value, returning final state. This is the basic interpreter using freer-simple's handleRelayS. (result, finalState) <- runMemory initialState $ do updateMem (+ 1) getMem\n\nCandidates:\n  Fields: (none)\n  Inputs: Type, Monadic, When\n  Output: Note, This, For, STM-based, Run\n  References: Memory.hs:63, Memory.hs:76, Memory.hs:204, Memory.hs:205, Memory.hs:213, Memory.hs:450, Graph.hs:101\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I fetch a bead by its ID?\nSymbol: getBead\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: getBead :: forall (effs :: [Type -> Type]). Member BD effs => Text -> Eff effs (Maybe BeadInfo) Get bead info by ID.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: BeadInfo, Get, ID.\n  References: BD.hs:35, BD.hs:373, BD.hs:374\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>BeadInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I query the current time in an effect?\nSymbol: GetCurrentTime\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: GetCurrentTime :: Time UTCTime\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetCurrentTime, Time, UTCTime\n  References: Types.hs:196, Types.hs:199, Types.hs:203\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetCurrentTime<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When should I avoid stateful computations?\nSymbol: Get\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: Get :: forall s. State s s\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Get, State\n  References: Types.hs:152, Types.hs:156, Types.hs:169\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform GetTasksTry and TaskType into Habitica or HabiticaError or HabiticaTask?\nSymbol: GetTasksTry\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: GetTasksTry :: TaskType %1 -> Habitica (Either HabiticaError [HabiticaTask])\n\nCandidates:\n  Fields: (none)\n  Inputs: GetTasksTry, TaskType\n  Output: Habitica, HabiticaError, HabiticaTask\n  References: Habitica.hs:80, Habitica.hs:126, Habitica.hs:171\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetTasksTry,TaskType,Habitica,HabiticaError<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Name into UsesEnum?\nSymbol: deriveUsesEnum\nModule: Tidepool.Schema\nPackage: tidepool-core\nSignature: deriveUsesEnum :: Name -> Q [Dec] Derive a `UsesEnum` instance for a type.\n\nCandidates:\n  Fields: (none)\n  Inputs: Name\n  Output: Dec, Derive, UsesEnum\n  References: Schema.hs:40, Schema.hs:264, Schema.hs:265\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Name<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to RetryConfig?\nSymbol: runWithRetryOrFail\nModule: Tidepool.Actor.Dispatch\nPackage: tidepool-actor\nSignature: runWithRetryOrFail :: forall a. RetryConfig -> IO a -> IO a\n\nCandidates:\n  Fields: (none)\n  Inputs: RetryConfig\n  Output: (none)\n  References: Dispatch.hs:110, Dispatch.hs:156, Dispatch.hs:157\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Command and CodeAction into CodeAction?\nSymbol: fromCommandOrAction\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromCommandOrAction :: (Command |? CodeAction) -> [CodeAction]\n\nCandidates:\n  Fields: (none)\n  Inputs: Command, CodeAction\n  Output: CodeAction\n  References: Interpreter.hs:353, Interpreter.hs:355, Interpreter.hs:356\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Type into Alias or State?\nSymbol: runMemoryPure\nModule: Tidepool.Graph.Memory\nPackage: tidepool-core\nSignature: runMemoryPure :: forall s (effs :: [Type -> Type]) a. s -> Eff (Memory s : effs) a -> Eff effs a Run memory effect with pure initial value, discarding final state. Alias for `evalMemory` for symmetry with State naming conventions.\n\nCandidates:\n  Fields: (none)\n  Inputs: Type\n  Output: Run, Alias, State\n  References: Memory.hs:77, Memory.hs:218, Memory.hs:219\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to GraphInfo?\nSymbol: toMermaid\nModule: Tidepool.Graph.Mermaid\nPackage: tidepool-core\nSignature: toMermaid :: GraphInfo -> Text\n\nCandidates:\n  Fields: (none)\n  Inputs: GraphInfo\n  Output: (none)\n  References: Mermaid.hs:29, Mermaid.hs:89, Mermaid.hs:90, Mermaid.hs:98, Mermaid.hs:124, Graph.hs:163\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with FilePath and LSPSession and Start and LSP and HLS and Spawning and FIXES and Capability?\nSymbol: withLSPSession\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: withLSPSession :: forall a. FilePath -> (LSPSession -> IO a) -> IO a Start an LSP session with HLS and run an action. lsp-test handles: - Spawning HLS process - rootUri configuration (FIXES the empty workspaceFolders bug) - initialize/initialized handshake - Capability negotiation withLSPSession \" *path* to/project\" $ session -> do result <- runLSP session myLSPAction pure result\n\nCandidates:\n  Fields: (none)\n  Inputs: FilePath, LSPSession, Start, LSP, HLS, Spawning, FIXES, Capability\n  Output: (none)\n  References: Server.hs:31, Server.hs:72, Interpreter.hs:9, Interpreter.hs:85, Interpreter.hs:89\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>FilePath,LSPSession<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When is hover content unparseable?\nSymbol: parseHoverContent\nModule: Tidepool.Control.Scout.Teach\nPackage: tidepool-control-server\nSignature: parseHoverContent :: Text -> (Text, Maybe Text) Parse hover content into signature and doc comment. Hover content typically has format: \\`\\`\\`haskell signature :: Type \\`\\`\\` Documentation comment here\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Parse, Hover, Type, Documentation\n  References: Teach.hs:322, Teach.hs:341, Teach.hs:342\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming GetPullRequest and Repo into GitHub or PullRequest?\nSymbol: GetPullRequest\nModule: Tidepool.Effects.GitHub\nPackage: tidepool-core\nSignature: GetPullRequest :: Repo %1 -> Int %1 -> Bool %1 -> GitHub (Maybe PullRequest)\n\nCandidates:\n  Fields: (none)\n  Inputs: GetPullRequest, Repo\n  Output: GitHub, PullRequest\n  References: GitHub.hs:306, GitHub.hs:328, GitHub.hs:359\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming CompletionItemKind into CompletionItemKind?\nSymbol: fromCompletionItemKind\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromCompletionItemKind :: CompletionItemKind -> CompletionItemKind\n\nCandidates:\n  Fields: (none)\n  Inputs: CompletionItemKind\n  Output: CompletionItemKind\n  References: Interpreter.hs:406, Interpreter.hs:417, Interpreter.hs:418\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming CodeActionKind into CodeActionKind?\nSymbol: fromCodeActionKind\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromCodeActionKind :: CodeActionKind -> CodeActionKind\n\nCandidates:\n  Fields: (none)\n  Inputs: CodeActionKind\n  Output: CodeActionKind\n  References: Interpreter.hs:363, Interpreter.hs:368, Interpreter.hs:369\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I access the barrier for worker synchronization?\nSymbol: GetWorkerArriveBarrier\nModule: Tidepool.Graph.Validate.ForkBarrier\nPackage: tidepool-core\nSignature: GetWorkerArriveBarrier\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetWorkerArriveBarrier\n  References: ForkBarrier.hs:48, ForkBarrier.hs:217, ForkBarrier.hs:220, ForkBarrier.hs:221, ForkBarrier.hs:222\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetWorkerArriveBarrier<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform TemplateInfo into Render?\nSymbol: renderTemplateComment\nModule: Tidepool.Graph.Mermaid\nPackage: tidepool-core\nSignature: renderTemplateComment :: Maybe TemplateInfo -> Text Render template comment.\n\nCandidates:\n  Fields: (none)\n  Inputs: TemplateInfo\n  Output: Render\n  References: Mermaid.hs:179, Mermaid.hs:193, Mermaid.hs:194, Mermaid.hs:195\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>TemplateInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I retrieve Habitica user information?\nSymbol: GetUser\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: GetUser :: Habitica UserInfo\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetUser, Habitica, UserInfo\n  References: Habitica.hs:70, Habitica.hs:97, Habitica.hs:145\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetUser,Habitica<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When should todo creation be fire-and-forget?\nSymbol: createTodoTry\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: createTodoTry :: forall (effs :: [Type -> Type]). Member Habitica effs => Text -> Eff effs (Either HabiticaError TodoId)\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: HabiticaError, TodoId\n  References: Habitica.hs:18, Habitica.hs:116, Habitica.hs:117\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Value into Value or Parse or Expected?\nSymbol: parseArriveMessage\nModule: Tidepool.Actor.Graph\nPackage: tidepool-actor\nSignature: parseArriveMessage :: Value -> Either String (Text, Text, Value) Parse an arrive message from a worker. Expected format: { \"barrier\": \"hJoin\", \"source\": \"hTests\", \"payload\": {...} } For MVP, source is optional - if missing, extracted from barrier name. This works when barrier names match source node names, which is common. TODO: Require source in message or track provenance at router level.\n\nCandidates:\n  Fields: (none)\n  Inputs: Value\n  Output: Value, Parse, Expected, For, MVP, This, TODO, Require\n  References: Graph.hs:327, Graph.hs:558, Graph.hs:559\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Value,Parse<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to Parser?\nSymbol: runGraphCLIWith\nModule: Tidepool.Graph.CLI\nPackage: tidepool-core\nSignature: runGraphCLIWith :: forall output input. (Show output, ToJSON output) => Text -> Parser input -> (input -> IO output) -> IO ()\n\nCandidates:\n  Fields: (none)\n  Inputs: Parser\n  Output: (none)\n  References: CLI.hs:74, CLI.hs:474, CLI.hs:480, CLI.hs:529\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I use if I need to actively process all events?\nSymbol: noDispatcher\nModule: .Tidepool\nPackage: tidepool-core\nSignature: noDispatcher :: forall s evt. AgentDispatcher s evt\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: AgentDispatcher\n  References: Tidepool.hs:37, Tidepool.hs:84, Tidepool.hs:125, Tidepool.hs:141, Tidepool.hs:142\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Type into Alias or State?\nSymbol: runMemoryPure\nModule: Tidepool.Graph.Memory\nPackage: tidepool-core\nSignature: runMemoryPure :: forall s (effs :: [Type -> Type]) a. s -> Eff (Memory s : effs) a -> Eff effs a Run memory effect with pure initial value, discarding final state. Alias for `evalMemory` for symmetry with State naming conventions.\n\nCandidates:\n  Fields: (none)\n  Inputs: Type\n  Output: Run, Alias, State\n  References: Memory.hs:77, Memory.hs:218, Memory.hs:219\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is a fork node for spawning parallel workers?\nSymbol: RuntimeFork\nModule: Tidepool.Graph.Reify\nPackage: tidepool-core\nSignature: RuntimeFork :: RuntimeNodeKind Fork node - spawns parallel workers\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: RuntimeFork, RuntimeNodeKind, Fork\n  References: Reify.hs:200, Reify.hs:695, Mermaid.hs:189, Mermaid.hs:248, Mermaid.hs:258, Mermaid.hs:419, Export.hs:283\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>RuntimeFork,RuntimeNodeKind<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming CodeActionKind into CodeActionKind?\nSymbol: fromCodeActionKind\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromCodeActionKind :: CodeActionKind -> CodeActionKind\n\nCandidates:\n  Fields: (none)\n  Inputs: CodeActionKind\n  Output: CodeActionKind\n  References: Interpreter.hs:363, Interpreter.hs:368, Interpreter.hs:369\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform ClaudeCodeInfo into ClaudeCode?\nSymbol: renderClaudeCodeComment\nModule: Tidepool.Graph.Mermaid\nPackage: tidepool-core\nSignature: renderClaudeCodeComment :: Maybe ClaudeCodeInfo -> Text Render ClaudeCode comment.\n\nCandidates:\n  Fields: (none)\n  Inputs: ClaudeCodeInfo\n  Output: Render, ClaudeCode\n  References: Mermaid.hs:178, Mermaid.hs:223, Mermaid.hs:224, Mermaid.hs:225\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>ClaudeCodeInfo,ClaudeCode<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to MermaidConfig and GraphInfo?\nSymbol: toMermaidWithConfig\nModule: Tidepool.Graph.Mermaid\nPackage: tidepool-core\nSignature: toMermaidWithConfig :: MermaidConfig -> GraphInfo -> Text\n\nCandidates:\n  Fields: (none)\n  Inputs: MermaidConfig, GraphInfo\n  Output: (none)\n  References: Mermaid.hs:30, Mermaid.hs:90, Mermaid.hs:136, Mermaid.hs:143, Mermaid.hs:144, Graph.hs:164\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to QuestionHandler?\nSymbol: runQuestionUI\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: runQuestionUI :: forall (effs :: [Type -> Type]) a. LastMember IO effs => QuestionHandler -> Eff (QuestionUI : effs) a -> Eff effs a\n\nCandidates:\n  Fields: (none)\n  Inputs: QuestionHandler\n  Output: (none)\n  References: Types.hs:97, Types.hs:650, Types.hs:651\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform GetDeps into BD or BeadInfo?\nSymbol: GetDeps\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: GetDeps :: Text %1 -> BD [BeadInfo] Get beads that this bead depends on (blockers).\n\nCandidates:\n  Fields: (none)\n  Inputs: GetDeps\n  Output: BD, BeadInfo, Get\n  References: BD.hs:325, BD.hs:378\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetDeps,BD,BeadInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform MemoryStore into Useful?\nSymbol: evalMemoryScoped\nModule: Tidepool.Graph.Memory\nPackage: tidepool-core\nSignature: evalMemoryScoped :: forall s (effs :: [Type -> Type]) a. (ToJSON s, FromJSON s) => Text -> s -> MemoryStore -> Eff (Memory s : effs) a -> Eff effs a Run memory effect with scoped persistence, discarding result store. Useful when you don't need the updated store (e.g., read-only access).\n\nCandidates:\n  Fields: (none)\n  Inputs: MemoryStore\n  Output: Run, Useful\n  References: Memory.hs:92, Memory.hs:459, Memory.hs:466\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>MemoryStore,Useful<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform CandidateGroups into Format?\nSymbol: formatSelectSymbolsExampleGrouped\nModule: Tidepool.Training.Format\nPackage: tidepool-training-generator\nSignature: formatSelectSymbolsExampleGrouped :: Text -> Text -> Text -> Text -> CandidateGroups -> ByteString Format complete training example with grouped candidates (v2).\n\nCandidates:\n  Fields: (none)\n  Inputs: CandidateGroups\n  Output: Format\n  References: Format.hs:5, Format.hs:138, Format.hs:145, Export.hs:39, Export.hs:476\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>CandidateGroups,Format<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming ScoringContext into Render?\nSymbol: renderConstraints\nModule: Tidepool.Control.Scout.Templates\nPackage: tidepool-control-server\nSignature: renderConstraints :: ScoringContext -> Text Render constraints section if present.\n\nCandidates:\n  Fields: (none)\n  Inputs: ScoringContext\n  Output: Render\n  References: Templates.hs:94, Templates.hs:111, Templates.hs:112\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Repo into PullRequest?\nSymbol: getPullRequest\nModule: Tidepool.Effects.GitHub\nPackage: tidepool-core\nSignature: getPullRequest :: forall (effs :: [Type -> Type]). Member GitHub effs => Repo -> Int -> Bool -> Eff effs (Maybe PullRequest)\n\nCandidates:\n  Fields: (none)\n  Inputs: Repo\n  Output: PullRequest\n  References: GitHub.hs:27, GitHub.hs:327, GitHub.hs:328\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to Value and Scope and Router and ActorId and Actor?\nSymbol: withActorSystem\nModule: Tidepool.Actor.Runtime\nPackage: tidepool-actor\nSignature: withActorSystem :: forall result. FromJSON result => Value -> (Scope -> Router -> IO (Map ActorId Actor)) -> IO result\n\nCandidates:\n  Fields: (none)\n  Inputs: Value, Scope, Router, ActorId, Actor\n  Output: (none)\n  References: Runtime.hs:6, Runtime.hs:50, Runtime.hs:57\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform LSPSession and ControlMessage into ControlResponse?\nSymbol: handleMessage\nModule: Tidepool.Control.Handler\nPackage: tidepool-control-server\nSignature: handleMessage :: LSPSession -> ControlMessage -> IO ControlResponse\n\nCandidates:\n  Fields: (none)\n  Inputs: LSPSession, ControlMessage\n  Output: ControlResponse\n  References: Server.hs:29, Server.hs:124, Handler.hs:3, Handler.hs:12, Handler.hs:13\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>LSPSession,ControlMessage,ControlResponse<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming BaseUrl into Unwrap?\nSymbol: getBaseUrl\nModule: Tidepool.LLM.Types\nPackage: unknown\nSignature: getBaseUrl :: BaseUrl -> Text Unwrap a base URL to get the underlying text.\n\nCandidates:\n  Fields: (none)\n  Inputs: BaseUrl\n  Output: Unwrap, URL\n  References: Interpreter.hs:73, Interpreter.hs:104, Interpreter.hs:146, Types.hs:43, Types.hs:95, Types.hs:96\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming EffectSemantics into EffectSemantics?\nSymbol: semanticsToText\nModule: Tidepool.Effect.Metadata\nPackage: tidepool-core\nSignature: semanticsToText :: EffectSemantics -> Text Convert EffectSemantics to Text for codegen.\n\nCandidates:\n  Fields: (none)\n  Inputs: EffectSemantics\n  Output: Convert, EffectSemantics\n  References: Metadata.hs:29, Metadata.hs:114, Metadata.hs:115, Metadata.hs:116\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to Type?\nSymbol: runGraphContext\nModule: Tidepool.Effect.GraphContext\nPackage: tidepool-core\nSignature: runGraphContext :: forall entry (effs :: [Type -> Type]) a. entry -> Eff (GraphContext entry : effs) a -> Eff effs a\n\nCandidates:\n  Fields: (none)\n  Inputs: Type\n  Output: (none)\n  References: GraphContext.hs:59, GraphContext.hs:182, GraphContext.hs:186\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with IORef?\nSymbol: runMemoryWithIORef\nModule: Tidepool.Actor.Graph\nPackage: tidepool-actor\nSignature: runMemoryWithIORef :: forall s (effs :: [Type -> Type]) a. LastMember IO effs => IORef s -> Eff (Memory s : effs) a -> Eff effs a\n\nCandidates:\n  Fields: (none)\n  Inputs: IORef\n  Output: (none)\n  References: Graph.hs:59, Graph.hs:248, Graph.hs:254, Graph.hs:423\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>IORef<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Extract and Haskell and This and DETERMINISTIC and LLM and Parses and Handles and Examples and ScoreConfig and ScoreEdgeOutput and Double\" and ScoreConfig and ScoreEdgeOutput into Bar\" or Bar?\nSymbol: extractCandidates\nModule: Tidepool.Control.Scout.Teach.Gemma\nPackage: tidepool-control-server\nSignature: extractCandidates :: Text -> [Text] Extract candidate symbols from a Haskell type signature. This is DETERMINISTIC - no LLM needed. Parses the signature and extracts uppercase identifiers, filtering common types. Handles markdown-formatted hover content by extracting just the code block. Examples: @ extractCandidates \"compositeScore :: ScoreConfig -> ScoreEdgeOutput -> Double\" == [ `ScoreConfig` , `ScoreEdgeOutput` ] extractCandidates \"foo :: Int -> Text -> Maybe Bar\" == [ `Bar` ] -- Int, Text, Maybe filtered out @\n\nCandidates:\n  Fields: (none)\n  Inputs: Extract, Haskell, This, DETERMINISTIC, LLM, Parses, Handles, Examples, ScoreConfig, ScoreEdgeOutput, Double\", ScoreConfig, ScoreEdgeOutput\n  Output: Bar\", Bar\n  References: Export.hs:32, Export.hs:265, Export.hs:406, Export.hs:690, Gemma.hs:35, Gemma.hs:93, Gemma.hs:124, Gemma.hs:125, Teach.hs:59, Teach.hs:234\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Extract,Haskell,Bar\",Bar<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I fetch a bead by its ID?\nSymbol: getBead\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: getBead :: forall (effs :: [Type -> Type]). Member BD effs => Text -> Eff effs (Maybe BeadInfo) Get bead info by ID.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: BeadInfo, Get, ID.\n  References: BD.hs:35, BD.hs:373, BD.hs:374\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>BeadInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When should I pass data through inputs instead of memory?\nSymbol: GetMem\nModule: Tidepool.Actor.Graph\nPackage: tidepool-actor\nSignature: GetMem :: forall s. Memory s s\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetMem, Memory\n  References: Graph.hs:229, Graph.hs:234, Graph.hs:255\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming ToolInput into ToolOutput or Tool?\nSymbol: toolExecute\nModule: Tidepool.Graph.Tool\nPackage: tidepool-core\nSignature: toolExecute :: forall t. ToolDef t => t -> ToolInput t -> Eff (ToolEffects t) (ToolOutput t) Tool implementation. Takes the tool value (for config) and input, returns output in the tool's effect stack.\n\nCandidates:\n  Fields: (none)\n  Inputs: ToolInput\n  Output: ToolOutput, Tool, Takes\n  References: Tool.hs:180\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming LocationLink into Location?\nSymbol: fromLocationLink\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromLocationLink :: LocationLink -> Location\n\nCandidates:\n  Fields: (none)\n  Inputs: LocationLink\n  Output: Location\n  References: Interpreter.hs:343, Interpreter.hs:345, Interpreter.hs:346\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming MemoryStore and MemoryStore and Run and This and Loads and Runs and Saves and If and Use and ExploreMem into ExploreMem?\nSymbol: runMemoryScoped\nModule: Tidepool.Graph.Memory\nPackage: tidepool-core\nSignature: runMemoryScoped :: forall s (effs :: [Type -> Type]) a. (ToJSON s, FromJSON s) => Text -> s -> MemoryStore -> Eff (Memory s : effs) a -> Eff effs (a, MemoryStore) Run memory effect with scoped persistence. This interpreter: 1. Loads initial state from the store (or uses default if scope missing) 2. Runs the action 3. Saves final state back to the store If deserialization fails (e.g., schema mismatch after code changes), the default value is used. Use `getScope` directly if you need to detect errors. (result, finalStore) <- runMemoryScoped \"explore\" defaultState store $ do updateMem `ExploreMem $ \\m -> m { visited = newUrl : m.visited } getMem ` ExploreMem\n\nCandidates:\n  Fields: (none)\n  Inputs: MemoryStore, MemoryStore, Run, This, Loads, Runs, Saves, If, Use, ExploreMem\n  Output: ExploreMem\n  References: Memory.hs:91, Memory.hs:435, Memory.hs:442, Memory.hs:467\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Command and CodeAction into CodeAction?\nSymbol: fromCodeActionsResult\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromCodeActionsResult :: [Command |? CodeAction] -> [CodeAction]\n\nCandidates:\n  Fields: (none)\n  Inputs: Command, CodeAction\n  Output: CodeAction\n  References: Interpreter.hs:215, Interpreter.hs:352, Interpreter.hs:353\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Command,CodeAction<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming AsHandler into HasField or GHC or Instead?\nSymbol: runGraphWith\nModule: Tidepool.Graph.Interpret\nPackage: tidepool-core\nSignature: runGraphWith :: forall (graph :: Type -> Type) entryType (targets :: [Type]) exitType (es :: [Effect]) handler. (CallHandler handler entryType es targets, DispatchGoto graph targets es exitType) => handler -> graph (AsHandler es) -> entryType -> Eff es exitType Run a graph with an explicitly provided entry handler. This avoids the `HasField` constraint that `runGraph` and `runGraphFrom` require. Use this when GHC can't derive HasField for your graph record (common when field types involve type families). -- Instead of: result <- runGraph handlers input -- Requires HasField -- Use: result <- runGraphWith handlers.v3Scaffold handlers input -- No HasField needed\n\nCandidates:\n  Fields: (none)\n  Inputs: AsHandler\n  Output: Run, This, HasField, Use, GHC, Instead, Requires, No\n  References: Interpret.hs:33, Interpret.hs:214, Interpret.hs:223\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming TaskType into HabiticaError or HabiticaTask?\nSymbol: getTasksTry\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: getTasksTry :: forall (effs :: [Type -> Type]). Member Habitica effs => TaskType -> Eff effs (Either HabiticaError [HabiticaTask])\n\nCandidates:\n  Fields: (none)\n  Inputs: TaskType\n  Output: HabiticaError, HabiticaTask\n  References: Habitica.hs:21, Habitica.hs:125, Habitica.hs:126\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with ParseDiagnostic?\nSymbol: formatDiagnostic\nModule: Tidepool.StructuredOutput.Class\nPackage: tidepool-core\nSignature: formatDiagnostic :: ParseDiagnostic -> Text\n\nCandidates:\n  Fields: (none)\n  Inputs: ParseDiagnostic\n  Output: (none)\n  References: Class.hs:30, Class.hs:99, Class.hs:100, Types.hs:125, Types.hs:408, Error.hs:10, Error.hs:32, Schema.hs:49, Schema.hs:71, Interpret.hs:86, Interpret.hs:491, Interpret.hs:494, Instances.hs:41, Instances.hs:206, StructuredOutput.hs:69, StructuredOutput.hs:112\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>ParseDiagnostic<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming CabalBuildFailure into CabalResult?\nSymbol: CabalBuildFailure\nModule: Tidepool.Effects.Cabal\nPackage: tidepool-core\nSignature: CabalBuildFailure :: Int %1 -> Text %1 -> Text %1 -> CabalResult\n\nCandidates:\n  Fields: (none)\n  Inputs: CabalBuildFailure\n  Output: CabalResult\n  References: Cabal.hs:106, Cabal.hs:107, Cabal.hs:109, Cabal.hs:111, Cabal.hs:143, Cabal.hs:152, Cabal.hs:160\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I create a new Habitica todo item?\nSymbol: createTodo\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: createTodo :: forall (effs :: [Type -> Type]). Member Habitica effs => Text -> Eff effs TodoId\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: TodoId\n  References: Habitica.hs:10, Habitica.hs:93, Habitica.hs:94\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>TodoId<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming TypedTemplate and SourcePos and TypedTemplate and SourcePos and SessionOperation and ClaudeCodeResult and SessionId and GotoChoice into GotoChoice or ClaudeCodeLLMHandler or Type?\nSymbol: executeClaudeCodeHandler\nModule: Tidepool.Graph.Interpret\nPackage: tidepool-core\nSignature: executeClaudeCodeHandler :: forall (model :: ModelChoice) needs schema (targets :: [Type]) (es :: [Type -> Type]) tpl. (Member Session es, ClaudeCodeSchema schema, GingerContext tpl, SingModelChoice model, ConvertTransitionHint targets) => Maybe (TypedTemplate tpl SourcePos) -> TypedTemplate tpl SourcePos -> (needs -> Eff es (tpl, SessionOperation)) -> ((ClaudeCodeResult schema, SessionId) -> Eff es (GotoChoice targets)) -> needs -> Eff es (GotoChoice targets) Execute a ClaudeCodeLLMHandler, returning a GotoChoice. Similar to `executeLLMHandler` , but uses the Session effect to spawn a dockerized Claude Code session via mantle. This function: 1. Calls the before-handler to build template context AND session strategy 2. Renders the user template (system template appended to prompt) 3. Detects if schema is a sum type \u2192 generates decision tools 4. Executes the appropriate Session operation (start *continue* fork) 5. Parses output from tool calls (sum types) or structured output (others) 6. Implements nag logic if sum type but no tool call (max 5 retries) 7. Calls the after-handler with output AND session ID for routing # Type Parameters + `model` - The ModelChoice from ClaudeCode annotation (type-level) + `needs` - The input type from Input annotation + `schema` - The LLM output schema type + `targets` - The transition targets from UsesEffects + `es` - The effect stack (must include Session) + `tpl` - The template context type # Session Management The before handler returns a `SessionOperation` alongside the template context: + 'StartFresh slug' - Create a new session with the given slug + 'ContinueFrom sid' - Resume an existing session (preserves conversation history) + 'ForkFrom parentSid childSlug' - Create a read-only fork from parent session The after handler receives both the parsed output and the session ID that was used/created, enabling downstream handlers to register sessions for later reuse. # Sum Type Handling (Decision Tools) For sum types with data (detected via `ClaudeCodeSchema` ), this function: 1. Generates MCP decision tools where each tool = one constructor 2. Passes tools to the session; Claude Code calls one to \"select\" a branch 3. Parses the tool call back to the Haskell sum type 4. If Claude doesn't call a tool, nags with a retry prompt (max 5 retries) This works around Anthropic's lack of oneOf support in structured output.\n\nCandidates:\n  Fields: (none)\n  Inputs: TypedTemplate, SourcePos, TypedTemplate, SourcePos, SessionOperation, ClaudeCodeResult, SessionId, GotoChoice\n  Output: GotoChoice, Execute, ClaudeCodeLLMHandler, GotoChoice., Similar, Session, Claude, Code, This, Calls, AND, Renders, Detects, Executes, Parses, Implements, ID, Type, Parameters, The, ModelChoice, ClaudeCode, Input, LLM, UsesEffects, Management, SessionOperation, Create, Resume, Sum, Handling, Decision, Tools, For, ClaudeCodeSchema, Generates, MCP, Passes, Haskell, If, Anthropic's\n  References: Interpret.hs:40, Interpret.hs:340, Interpret.hs:354, Interpret.hs:553\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to SpanKind and SpanAttribute?\nSymbol: withSpan\nModule: Tidepool.Effects.Observability\nPackage: tidepool-core\nSignature: withSpan :: forall (effs :: [Type -> Type]) a. Member Observability effs => Text -> SpanKind -> [SpanAttribute] -> Eff effs a -> Eff effs a\n\nCandidates:\n  Fields: (none)\n  Inputs: SpanKind, SpanAttribute\n  Output: (none)\n  References: Observability.hs:18, Observability.hs:164, Observability.hs:189, Observability.hs:219, Observability.hs:226\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I do to block sending  as a response?\nSymbol: parseSelectionResponse\nModule: Tidepool.Control.Scout.Teach.Gemma\nPackage: tidepool-control-server\nSignature: parseSelectionResponse :: ByteString -> Either Text [Text] Parse Ollama response for symbol selection (array format).\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Parse, Ollama\n  References: Gemma.hs:243, Gemma.hs:287, Gemma.hs:288\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When should I start fresh without history?\nSymbol: getHistory\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: getHistory :: forall (effs :: [Type -> Type]). Member ChatHistory effs => Eff effs [Message]\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Message\n  References: Types.hs:45, Types.hs:516, Types.hs:517\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if node identity is not relevant?\nSymbol: GetNodeName\nModule: Tidepool.Graph.Generic.Core\nPackage: tidepool-core\nSignature: GetNodeName\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetNodeName\n  References: Core.hs:30, Core.hs:218, Core.hs:219, Core.hs:220\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform LSPSymbol into Format or TODO or Replace?\nSymbol: formatSelectionPrompt\nModule: Tidepool.Control.Scout.Teach.Gemma\nPackage: tidepool-control-server\nSignature: formatSelectionPrompt :: Text -> LSPSymbol -> [Text] -> Text Format the selection prompt. TODO: Replace with proper FunctionGemma token format once training data is ready. For now, training data format in training-generator/Format.hs is the source of truth.\n\nCandidates:\n  Fields: (none)\n  Inputs: LSPSymbol\n  Output: Format, TODO, Replace, FunctionGemma, For\n  References: Gemma.hs:219, Gemma.hs:254, Gemma.hs:255\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>LSPSymbol,Format,TODO<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When should I avoid using node-private memory?\nSymbol: GetMemory\nModule: Tidepool.Graph.Edges\nPackage: tidepool-core\nSignature: GetMemory\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetMemory\n  References: Edges.hs:21, Edges.hs:207, Edges.hs:208, Edges.hs:209, Edges.hs:210, Edges.hs:210, Edges.hs:211, Reify.hs:94, Reify.hs:753, Reify.hs:775, Reify.hs:784, Reify.hs:800, Reify.hs:749, Reify.hs:758, Reify.hs:783, Reify.hs:788, Graph.hs:191\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if user context is not needed?\nSymbol: GetUser\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: GetUser :: Habitica UserInfo\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetUser, Habitica, UserInfo\n  References: Habitica.hs:70, Habitica.hs:97, Habitica.hs:145\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming GetIssue and Repo into GitHub or Issue?\nSymbol: GetIssue\nModule: Tidepool.Effects.GitHub\nPackage: tidepool-core\nSignature: GetIssue :: Repo %1 -> Int %1 -> Bool %1 -> GitHub (Maybe Issue)\n\nCandidates:\n  Fields: (none)\n  Inputs: GetIssue, Repo\n  Output: GitHub, Issue\n  References: GitHub.hs:300, GitHub.hs:322, GitHub.hs:351\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Value into ParseDiagnostic?\nSymbol: expectedBool\nModule: Tidepool.StructuredOutput.Error\nPackage: tidepool-core\nSignature: expectedBool :: [Text] -> Value -> ParseDiagnostic Error for when a boolean was expected.\n\nCandidates:\n  Fields: (none)\n  Inputs: Value\n  Output: ParseDiagnostic, Error\n  References: Error.hs:17, Error.hs:76, Error.hs:77, Instances.hs:44, Instances.hs:94\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Value,ParseDiagnostic<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming OutputFormat into Format?\nSymbol: formatOutput\nModule: Tidepool.Graph.CLI\nPackage: tidepool-core\nSignature: formatOutput :: forall a. (Show a, ToJSON a) => OutputFormat -> a -> Text Format output value according to the chosen format.\n\nCandidates:\n  Fields: (none)\n  Inputs: OutputFormat\n  Output: Format\n  References: CLI.hs:71, CLI.hs:451, CLI.hs:452, CLI.hs:453, CLI.hs:488\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if conversation history is not needed?\nSymbol: GetHistory\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: GetHistory :: ChatHistory [Message]\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetHistory, ChatHistory, Message\n  References: Types.hs:512, Types.hs:517, Types.hs:532\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform GetTasksTry and TaskType into Habitica or HabiticaError or HabiticaTask?\nSymbol: GetTasksTry\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: GetTasksTry :: TaskType %1 -> Habitica (Either HabiticaError [HabiticaTask])\n\nCandidates:\n  Fields: (none)\n  Inputs: GetTasksTry, TaskType\n  Output: Habitica, HabiticaError, HabiticaTask\n  References: Habitica.hs:80, Habitica.hs:126, Habitica.hs:171\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetTasksTry,TaskType,Habitica,HabiticaError<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When should todo creation be fire-and-forget?\nSymbol: createTodoTry\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: createTodoTry :: forall (effs :: [Type -> Type]). Member Habitica effs => Text -> Eff effs (Either HabiticaError TodoId)\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: HabiticaError, TodoId\n  References: Habitica.hs:18, Habitica.hs:116, Habitica.hs:117\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with TemplateDependency?\nSymbol: renderDepTree\nModule: Tidepool.Graph.Docs\nPackage: tidepool-core\nSignature: renderDepTree :: TemplateDependency -> Text\n\nCandidates:\n  Fields: (none)\n  Inputs: TemplateDependency\n  Output: (none)\n  References: Docs.hs:36, Docs.hs:70, Docs.hs:71, Docs.hs:145, Graph.hs:124\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>TemplateDependency<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming NodeInfo into Render?\nSymbol: renderTransitionsComment\nModule: Tidepool.Graph.Mermaid\nPackage: tidepool-core\nSignature: renderTransitionsComment :: NodeInfo -> Text Render transitions comment.\n\nCandidates:\n  Fields: (none)\n  Inputs: NodeInfo\n  Output: Render\n  References: Mermaid.hs:183, Mermaid.hs:228, Mermaid.hs:229\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is the Cabal build effect constructor?\nSymbol: CabalBuild\nModule: Tidepool.Effects.Cabal\nPackage: tidepool-core\nSignature: CabalBuild\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: CabalBuild\n  References: Cabal.hs:144, Cabal.hs:182\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>CabalBuild<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform HookInput into ControlResponse?\nSymbol: handleHook\nModule: Tidepool.Control.Handler.Hook\nPackage: tidepool-control-server\nSignature: handleHook :: HookInput -> IO ControlResponse\n\nCandidates:\n  Fields: (none)\n  Inputs: HookInput\n  Output: ControlResponse\n  References: Hook.hs:6, Hook.hs:19, Hook.hs:20, Handler.hs:7, Handler.hs:14\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>HookInput,ControlResponse<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming JSONSchema into Check?\nSymbol: allNullary\nModule: Tidepool.StructuredOutput.Generic\nPackage: tidepool-core\nSignature: allNullary :: [(String, JSONSchema)] -> Bool Check if all variants have empty contents (nullary constructors). For example, `data Priority = Low | Medium | High` has all nullary constructors.\n\nCandidates:\n  Fields: (none)\n  Inputs: JSONSchema\n  Output: Check, For, Priority, Low, Medium, High\n  References: Generic.hs:302, Generic.hs:303, Generic.hs:336, Generic.hs:360, Generic.hs:376, Generic.hs:397\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming AsHandler into HasField or GHC or Instead?\nSymbol: runGraphWith\nModule: Tidepool.Graph.Interpret\nPackage: tidepool-core\nSignature: runGraphWith :: forall (graph :: Type -> Type) entryType (targets :: [Type]) exitType (es :: [Effect]) handler. (CallHandler handler entryType es targets, DispatchGoto graph targets es exitType) => handler -> graph (AsHandler es) -> entryType -> Eff es exitType Run a graph with an explicitly provided entry handler. This avoids the `HasField` constraint that `runGraph` and `runGraphFrom` require. Use this when GHC can't derive HasField for your graph record (common when field types involve type families). -- Instead of: result <- runGraph handlers input -- Requires HasField -- Use: result <- runGraphWith handlers.v3Scaffold handlers input -- No HasField needed\n\nCandidates:\n  Fields: (none)\n  Inputs: AsHandler\n  Output: Run, This, HasField, Use, GHC, Instead, Requires, No\n  References: Interpret.hs:33, Interpret.hs:214, Interpret.hs:223\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming JSONSchema into JSONSchema?\nSymbol: describeField\nModule: Tidepool.Schema\nPackage: tidepool-core\nSignature: describeField :: Text -> Text -> JSONSchema -> JSONSchema Add description to schema\n\nCandidates:\n  Fields: (none)\n  Inputs: JSONSchema\n  Output: JSONSchema, Add\n  References: Schema.hs:21, Schema.hs:100, Schema.hs:101, Schema.hs:186\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I extract signature and docs from hover content?\nSymbol: parseHoverContent\nModule: Tidepool.Control.Scout.Teach\nPackage: tidepool-control-server\nSignature: parseHoverContent :: Text -> (Text, Maybe Text) Parse hover content into signature and doc comment. Hover content typically has format: \\`\\`\\`haskell signature :: Type \\`\\`\\` Documentation comment here\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Parse, Hover, Type, Documentation\n  References: Teach.hs:322, Teach.hs:341, Teach.hs:342\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Parse,Hover<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming HashMap and Value into HList or FromPayloads?\nSymbol: extractMergeResults\nModule: Tidepool.Actor.Merge\nPackage: tidepool-actor\nSignature: extractMergeResults :: forall (sources :: [Type]). ExtractMergeResults sources => HashMap Text Value -> Either Text (HList (FromPayloads sources))\n\nCandidates:\n  Fields: (none)\n  Inputs: HashMap, Value\n  Output: HList, FromPayloads\n  References: Merge.hs:198, Merge.hs:201, Merge.hs:208, Merge.hs:215, Merge.hs:252\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is a barrier node in parallel graph execution?\nSymbol: RuntimeBarrier\nModule: Tidepool.Graph.Reify\nPackage: tidepool-core\nSignature: RuntimeBarrier :: RuntimeNodeKind Barrier node - collects parallel results\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: RuntimeBarrier, RuntimeNodeKind, Barrier\n  References: Reify.hs:201, Reify.hs:720, Mermaid.hs:190, Mermaid.hs:249, Mermaid.hs:259, Mermaid.hs:420, Export.hs:284\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>RuntimeBarrier,RuntimeNodeKind<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform HandlerBuilder and Value into Each or Messages or Node?\nSymbol: runGraphAsActors\nModule: Tidepool.Actor.Graph\nPackage: tidepool-actor\nSignature: runGraphAsActors :: forall result. FromJSON result => Map Text HandlerBuilder -> Value -> IO result Run a graph as an actor system. Each entry in the handler map becomes one actor. Each handler builder is run once when its actor spawns, allowing per-actor state initialization. Messages flow between actors via the router. The system terminates when a handler routes to \"exit\", returning the exit payload. # Node Names + `\"entry\"` - Entry point (receives initial input) + `\"exit\"` - Exit handler (returns result) + Other names map directly to graph node names # Example handlers :: Map Text HandlerBuilder handlers = Map.fromList [ (\"entry\", pureHandler entryHandler) , (\"processor\", effHandlerWithMem 0 processorHandler) -- has its own Int memory , (\"logger\", effHandlerWithMem [] logHandler) -- has its own [Text] memory ] result <- runGraphAsActors handlers (toJSON (Message \"hello\"))\n\nCandidates:\n  Fields: (none)\n  Inputs: HandlerBuilder, Value\n  Output: Run, Each, Messages, The, Node, Names, Entry, Exit, Other, Example, HandlerBuilder, Map.fromList, Message\n  References: Graph.hs:36, Graph.hs:296, Graph.hs:302, Graph.hs:450, Graph.hs:451\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>HandlerBuilder,Value,Each<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to ParseDiagnostic?\nSymbol: formatDiagnostic\nModule: Tidepool.StructuredOutput.Class\nPackage: tidepool-core\nSignature: formatDiagnostic :: ParseDiagnostic -> Text\n\nCandidates:\n  Fields: (none)\n  Inputs: ParseDiagnostic\n  Output: (none)\n  References: Class.hs:30, Class.hs:99, Class.hs:100, Types.hs:125, Types.hs:408, Error.hs:10, Error.hs:32, Schema.hs:49, Schema.hs:71, Interpret.hs:86, Interpret.hs:491, Interpret.hs:494, Instances.hs:41, Instances.hs:206, StructuredOutput.hs:69, StructuredOutput.hs:112\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I convert camelCase to snake_case?\nSymbol: camelToSnake\nModule: Tidepool.StructuredOutput.DecisionTools\nPackage: tidepool-core\nSignature: camelToSnake :: String -> String Convert PascalCase to snake_case. camelToSnake `ApproveRequest` = \"approve_request\"\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Convert, PascalCase, ApproveRequest\n  References: DecisionTools.hs:211, DecisionTools.hs:230, DecisionTools.hs:251, DecisionTools.hs:252\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>PascalCase<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with LLMEnv?\nSymbol: runLLMComplete\nModule: Tidepool.LLM.Interpreter\nPackage: unknown\nSignature: runLLMComplete :: forall (effs :: [Type -> Type]) a. LastMember IO effs => LLMEnv -> Eff (LLMComplete : effs) a -> Eff effs a\n\nCandidates:\n  Fields: (none)\n  Inputs: LLMEnv\n  Output: (none)\n  References: Interpreter.hs:26, Interpreter.hs:275, Interpreter.hs:276\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>LLMEnv<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I list files with uncommitted changes?\nSymbol: getDirtyFiles\nModule: Tidepool.Effects.Git\nPackage: tidepool-core\nSignature: getDirtyFiles :: forall (effs :: [Type -> Type]). Member Git effs => Eff effs [FilePath] Get list of dirty files.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: FilePath, Get\n  References: Git.hs:21, Git.hs:105, Git.hs:106\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>FilePath<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to TemplateDependency and Render and Output?\nSymbol: renderDepTreeCompact\nModule: Tidepool.Graph.Docs\nPackage: tidepool-core\nSignature: renderDepTreeCompact :: TemplateDependency -> Text Render a compact single-line representation. Output example: `main.jinja -> header.jinja, footer.jinja`\n\nCandidates:\n  Fields: (none)\n  Inputs: TemplateDependency, Render, Output\n  Output: (none)\n  References: Docs.hs:37, Docs.hs:105, Docs.hs:106, Graph.hs:125\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I do to block sending responses to clients?\nSymbol: sendResponse\nModule: Tidepool.Control.Server\nPackage: tidepool-control-server\nSignature: sendResponse :: Socket -> ControlResponse -> IO ()\n\nCandidates:\n  Fields: (none)\n  Inputs: Socket, ControlResponse\n  Output: (none)\n  References: Server.hs:120, Server.hs:126, Server.hs:131, Server.hs:148, Server.hs:149\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform GotoChoice into Value?\nSymbol: extractChoice\nModule: Tidepool.Actor.Graph\nPackage: tidepool-actor\nSignature: extractChoice :: forall (targets :: [Type]). ExtractChoice targets => GotoChoice targets -> (Text, Value)\n\nCandidates:\n  Fields: (none)\n  Inputs: GotoChoice\n  Output: Value\n  References: [many references (21) - hub symbol]\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GotoChoice,Value<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to MarkupContent?\nSymbol: extractDocumentation\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: extractDocumentation :: (Text |? MarkupContent) -> Text\n\nCandidates:\n  Fields: (none)\n  Inputs: MarkupContent\n  Output: (none)\n  References: Interpreter.hs:408, Interpreter.hs:412, Interpreter.hs:413\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I run a subgraph recursively with state threading?\nSymbol: withRecursiveGraph\nModule: Tidepool.Actor.Subgraph\nPackage: tidepool-actor\nSignature: withRecursiveGraph :: forall entry result a. Maybe Int -> (SubgraphState entry result -> ((ChildId -> entry -> IO result) -> IO ()) -> IO a) -> IO a Run a computation with a recursive subgraph, handling all wiring automatically. **This is the recommended API for DSL users.** The callback receives: 1. `SubgraphState` - pass this to your effect interpreter 2. A `wire` function - call this with your graph runner BEFORE running result [withRecursiveGraph @Spec @V2Result $ \\subgraphState wire -](-) do let interpret = runV2Effects subgraphState ... handlers <- buildHandlerMap interpret -- Wire the recursion (MUST happen before running!) -- Runner receives ChildId for linking child nodes to parent wire $ \\childId childSpec -> runGraphAsActors handlers (toJSON childSpec) -- Now run - children will recursively spawn correctly runGraphAsActors handlers (toJSON rootSpec) ## Why This Pattern? Graph execution has a chicken-and-egg problem: 1. The interpreter needs SubgraphState 2. SubgraphState needs the graph runner 3. The graph runner needs handlers 4. Handlers need the interpreter (step 1!) This function breaks the cycle using deferred binding. The internal IORef is completely hidden - you just call `wire` with your runner. ## Scope-Based Cancellation The function creates a ki scope that wraps the entire computation. All children spawned via `spawnSelf` run within this scope. When the callback returns (success or exception), the scope exits and ki automatically cancels any still-running children.\n\nCandidates:\n  Fields: (none)\n  Inputs: SubgraphState, ChildId, Run, This, API, DSL, The, SubgraphState, BEFORE, Wire, MUST, Runner, ChildId\n  Output: Now, Why, This, Pattern?, Graph, The, SubgraphState, Handlers, IORef, Scope-Based, Cancellation, All, When\n  References: Subgraph.hs:52, Subgraph.hs:171, Subgraph.hs:264, Subgraph.hs:271\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>SubgraphState,ChildId,Now,Why<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with AsHandler?\nSymbol: runGraphFrom\nModule: Tidepool.Graph.Interpret\nPackage: tidepool-core\nSignature: runGraphFrom :: forall (name :: Symbol) (graph :: Type -> Type) entryType (targets :: [Type]) exitType (es :: [Effect]) handler. (KnownSymbol name, HasField name (graph (AsHandler es)) handler, CallHandler handler entryType es targets, DispatchGoto graph targets es exitType) => graph (AsHandler es) -> entryType -> Eff es exitType\n\nCandidates:\n  Fields: (none)\n  Inputs: AsHandler\n  Output: (none)\n  References: Interpret.hs:32, Interpret.hs:153, Interpret.hs:163, Interpret.hs:198, Interpret.hs:203\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>AsHandler<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When should I convert tools individually?\nSymbol: toolDefsToAnthropic\nModule: Tidepool.Tool.Convert\nPackage: tidepool-core\nSignature: toolDefsToAnthropic :: forall (f :: Type -> Type) t. (Functor f, ToAnthropicTool t) => f t -> f AnthropicTool\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: AnthropicTool\n  References: Convert.hs:53, Convert.hs:138, Convert.hs:139\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform TaskType into HabiticaTask?\nSymbol: getTasks\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: getTasks :: forall (effs :: [Type -> Type]). Member Habitica effs => TaskType -> Eff effs [HabiticaTask]\n\nCandidates:\n  Fields: (none)\n  Inputs: TaskType\n  Output: HabiticaTask\n  References: Habitica.hs:13, Habitica.hs:102, Habitica.hs:103\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>TaskType,HabiticaTask<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming CreateBeadInput into Example or TypeBug?\nSymbol: createBead\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: createBead :: forall (effs :: [Type -> Type]). Member BD effs => CreateBeadInput -> Eff effs Text Create a new bead, returns the generated ID. Example: newId <- createBead $ defaultCreateInput { cbiTitle = \"Fix bug in login\" , cbiType = TypeBug , cbiPriority = 1 , cbiLabels = [\"urgent\", \"auth\"] }\n\nCandidates:\n  Fields: (none)\n  Inputs: CreateBeadInput\n  Output: Create, ID., Example, TypeBug\n  References: BD.hs:44, BD.hs:417, BD.hs:418\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with AsHandler?\nSymbol: runGraph\nModule: Tidepool.Graph.Interpret\nPackage: tidepool-core\nSignature: runGraph :: forall (graph :: Type -> Type) entryType (targets :: [Type]) exitType (es :: [Type -> Type]) (entryHandlerName :: Symbol) handler. (Generic (graph AsGraph), FindEntryHandler entryType (FieldsWithNamesOf graph) ~ 'Just entryHandlerName, KnownSymbol entryHandlerName, HasField entryHandlerName (graph (AsHandler es)) handler, CallHandler handler entryType es targets, DispatchGoto graph targets es exitType) => graph (AsHandler es) -> entryType -> Eff es exitType\n\nCandidates:\n  Fields: (none)\n  Inputs: AsHandler\n  Output: (none)\n  References: CLI.hs:99, CLI.hs:530, Interpret.hs:31, Interpret.hs:186, Interpret.hs:198, Interpret.hs:203, Interpret.hs:565, Interpret.hs:586, Interpret.hs:604\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>AsHandler<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with FilePath and CabalResult and Run and CabalTestSuccess and CabalTestFailure and CabalBuildFailure?\nSymbol: cabalTest\nModule: Tidepool.Effects.Cabal\nPackage: tidepool-core\nSignature: cabalTest :: forall (effs :: [Type -> Type]). Member Cabal effs => FilePath -> Eff effs CabalResult Run tests with detailed output. result <- cabalTest \" *path* to/project\" case result of CabalTestSuccess output -> logSuccess output CabalTestFailure failures _ -> fixImplementation failures CabalBuildFailure _ stderr _ -> fixCompilation stderr\n\nCandidates:\n  Fields: (none)\n  Inputs: FilePath, CabalResult, Run, CabalTestSuccess, CabalTestFailure, CabalBuildFailure\n  Output: (none)\n  References: Cabal.hs:37, Cabal.hs:193, Cabal.hs:197\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>FilePath,CabalResult<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform MermaidConfig and NodeInfo into Render?\nSymbol: renderNodeWithComments\nModule: Tidepool.Graph.Mermaid\nPackage: tidepool-core\nSignature: renderNodeWithComments :: MermaidConfig -> NodeInfo -> [Text] Render a node with optional structured comments.\n\nCandidates:\n  Fields: (none)\n  Inputs: MermaidConfig, NodeInfo\n  Output: Render\n  References: Mermaid.hs:161, Mermaid.hs:164, Mermaid.hs:165\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>MermaidConfig,NodeInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming CabalClean and FilePath into Cabal or CabalResult or Clean?\nSymbol: CabalClean\nModule: Tidepool.Effects.Cabal\nPackage: tidepool-core\nSignature: CabalClean :: FilePath %1 -> Cabal CabalResult Clean build artifacts. Equivalent to `cabal clean` . Returns `CabalSuccess` or `CabalBuildFailure` .\n\nCandidates:\n  Fields: (none)\n  Inputs: CabalClean, FilePath\n  Output: Cabal, CabalResult, Clean, Equivalent, Returns, CabalSuccess, CabalBuildFailure\n  References: Cabal.hs:161, Cabal.hs:206\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I get the name of the current node?\nSymbol: GetNodeName\nModule: Tidepool.Graph.Generic.Core\nPackage: tidepool-core\nSignature: GetNodeName\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetNodeName\n  References: Core.hs:30, Core.hs:218, Core.hs:219, Core.hs:220\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetNodeName<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming ToolInfo into Render?\nSymbol: renderToolsComment\nModule: Tidepool.Graph.Mermaid\nPackage: tidepool-core\nSignature: renderToolsComment :: [ToolInfo] -> Text Render tools comment.\n\nCandidates:\n  Fields: (none)\n  Inputs: ToolInfo\n  Output: Render\n  References: Mermaid.hs:181, Mermaid.hs:213, Mermaid.hs:214, Mermaid.hs:215\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Read and Usage and In and True and False and FailureResult and This and Memory and OLD into NEW or Direct or NodeInput?\nSymbol: getNodeInput\nModule: Tidepool.Effect.GraphContext\nPackage: tidepool-core\nSignature: getNodeInput :: forall input (effs :: [Type -> Type]). Member (NodeInput input) effs => Eff effs input Read the current node's input value. Usage requires type application to specify the input type: -- In implAfter originalInput <- getNodeInput @ImplInput case originalInput.iiAttemptCount < 5 of True -> pure $ gotoSelf originalInput { iiAttemptCount = originalInput.iiAttemptCount + 1 } False -> pure $ gotoExit FailureResult This replaces the pattern of storing input in Memory: -- OLD: Memory round-trip implBefore input = do updateMem @ImplMem $ \\m -> m { imOriginalInput = Just input } ... implAfter (exit, sid) = do mem <- getMem @ImplMem let originalInput = fromMaybe (error \"impossible\") mem.imOriginalInput ... -- NEW: Direct via NodeInput implAfter (exit, sid) = do originalInput <- getNodeInput @ImplInput ...\n\nCandidates:\n  Fields: (none)\n  Inputs: Read, Usage, In, True, False, FailureResult, This, Memory, OLD\n  Output: Just, NEW, Direct, NodeInput\n  References: GraphContext.hs:56, GraphContext.hs:161, GraphContext.hs:165\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Usage,NEW<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What are the different types of runtime graph edges?\nSymbol: RuntimeEdgeKind\nModule: Tidepool.Graph.Reify\nPackage: tidepool-core\nSignature: RuntimeEdgeKind\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: RuntimeEdgeKind\n  References: Reify.hs:32, Reify.hs:191, Reify.hs:205, Reify.hs:191, Reify.hs:193, Reify.hs:193, Reify.hs:208, Reify.hs:208, Graph.hs:141, Export.hs:40, Export.hs:287, Export.hs:229, Export.hs:288\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>RuntimeEdgeKind<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform GetBead into BD or BeadInfo?\nSymbol: GetBead\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: GetBead :: Text %1 -> BD (Maybe BeadInfo) Get full bead info by ID.\n\nCandidates:\n  Fields: (none)\n  Inputs: GetBead\n  Output: BD, BeadInfo, Get, ID.\n  References: BD.hs:322, BD.hs:374\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetBead,BD,BeadInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform TaskType into HabiticaError or HabiticaTask?\nSymbol: getTasksTry\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: getTasksTry :: forall (effs :: [Type -> Type]). Member Habitica effs => TaskType -> Eff effs (Either HabiticaError [HabiticaTask])\n\nCandidates:\n  Fields: (none)\n  Inputs: TaskType\n  Output: HabiticaError, HabiticaTask\n  References: Habitica.hs:21, Habitica.hs:125, Habitica.hs:126\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>TaskType,HabiticaError,HabiticaTask<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming CandidateGroups into Format?\nSymbol: formatUserTurnGrouped\nModule: Tidepool.Training.Format\nPackage: tidepool-training-generator\nSignature: formatUserTurnGrouped :: Text -> Text -> Text -> Text -> CandidateGroups -> Text Format user turn with grouped candidates (v2 format).\n\nCandidates:\n  Fields: (none)\n  Inputs: CandidateGroups\n  Output: Format\n  References: Format.hs:8, Format.hs:117, Format.hs:124, Format.hs:148\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming SymbolKind into SymbolKind?\nSymbol: fromSymbolKind\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromSymbolKind :: SymbolKind -> SymbolKind\n\nCandidates:\n  Fields: (none)\n  Inputs: SymbolKind\n  Output: SymbolKind\n  References: Interpreter.hs:456, Interpreter.hs:464, Interpreter.hs:477, Interpreter.hs:478\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform CreateBeadInput into Example or TypeBug?\nSymbol: createBead\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: createBead :: forall (effs :: [Type -> Type]). Member BD effs => CreateBeadInput -> Eff effs Text Create a new bead, returns the generated ID. Example: newId <- createBead $ defaultCreateInput { cbiTitle = \"Fix bug in login\" , cbiType = TypeBug , cbiPriority = 1 , cbiLabels = [\"urgent\", \"auth\"] }\n\nCandidates:\n  Fields: (none)\n  Inputs: CreateBeadInput\n  Output: Create, ID., Example, TypeBug\n  References: BD.hs:44, BD.hs:417, BD.hs:418\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>CreateBeadInput,ID.<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I get the current UTC timestamp?\nSymbol: getCurrentTime\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: getCurrentTime :: forall (effs :: [Type -> Type]). Member Time effs => Eff effs UTCTime\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: UTCTime\n  References: Types.hs:29, Types.hs:198, Types.hs:199\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>UTCTime<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if automatic instance derivation is not possible?\nSymbol: deriveHasJSONSchema\nModule: Tidepool.Schema\nPackage: tidepool-core\nSignature: deriveHasJSONSchema :: Name -> Q [Dec] Derive a `HasJSONSchema` instance for a record type.\n\nCandidates:\n  Fields: (none)\n  Inputs: Name\n  Output: Dec, Derive, HasJSONSchema\n  References: Schema.hs:38, Schema.hs:224, Schema.hs:225\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform AsHandler into Run?\nSymbol: runGraphWithSpans\nModule: Tidepool.Graph.Interpret.Instrumented\nPackage: tidepool-core\nSignature: runGraphWithSpans :: forall (graph :: Type -> Type) entryType (targets :: [Type]) exitType (es :: [Effect]) (entryHandlerName :: Symbol) handler. (Generic (graph AsGraph), FindEntryHandler entryType (FieldsWithNamesOf graph) ~ 'Just entryHandlerName, KnownSymbol entryHandlerName, HasField entryHandlerName (graph (AsHandler es)) handler, CallHandler handler entryType es targets, DispatchGotoTraced graph targets es exitType, Member Observability es) => graph (AsHandler es) -> entryType -> Eff es exitType Run a graph with automatic span emission for each node transition. Creates a root span for the graph and child spans for each handler invocation. result <- runGraphWithSpans @MyGraph handlers inputValue\n\nCandidates:\n  Fields: (none)\n  Inputs: AsHandler\n  Output: Run, Creates\n  References: Instrumented.hs:44, Instrumented.hs:121, Instrumented.hs:134\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>AsHandler<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming CreateTodoTry into Habitica or HabiticaError or TodoId?\nSymbol: CreateTodoTry\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: CreateTodoTry :: Text %1 -> Habitica (Either HabiticaError TodoId)\n\nCandidates:\n  Fields: (none)\n  Inputs: CreateTodoTry\n  Output: Habitica, HabiticaError, TodoId\n  References: Habitica.hs:77, Habitica.hs:117, Habitica.hs:162\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I safely fetch user info with error handling?\nSymbol: getUserTry\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: getUserTry :: forall (effs :: [Type -> Type]). Member Habitica effs => Eff effs (Either HabiticaError UserInfo)\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: HabiticaError, UserInfo\n  References: Habitica.hs:19, Habitica.hs:119, Habitica.hs:120\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>HabiticaError,UserInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform ToolUseId into ToolResultId?\nSymbol: toolUseToResultId\nModule: Tidepool.Anthropic.Types\nPackage: tidepool-core\nSignature: toolUseToResultId :: ToolUseId -> ToolResultId\n\nCandidates:\n  Fields: (none)\n  Inputs: ToolUseId\n  Output: ToolResultId\n  References: Types.hs:22, Types.hs:72, Types.hs:73\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>ToolUseId,ToolResultId<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I convert a tool to Cloudflare Workers format?\nSymbol: ToCfTool\nModule: Tidepool.Tool.Convert\nPackage: tidepool-core\nSignature: $p1ToCfTool :: forall t. ToCfTool t => ToolDef t\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: ToolDef\n  References: Convert.hs:117, Convert.hs:121\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>ToolDef<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform TypedTemplate and SourcePos and TypedTemplate and SourcePos and SessionOperation and ClaudeCodeResult and SessionId and GotoChoice into GotoChoice or ClaudeCodeLLMHandler or Type?\nSymbol: executeClaudeCodeHandler\nModule: Tidepool.Graph.Interpret\nPackage: tidepool-core\nSignature: executeClaudeCodeHandler :: forall (model :: ModelChoice) needs schema (targets :: [Type]) (es :: [Type -> Type]) tpl. (Member Session es, ClaudeCodeSchema schema, GingerContext tpl, SingModelChoice model, ConvertTransitionHint targets) => Maybe (TypedTemplate tpl SourcePos) -> TypedTemplate tpl SourcePos -> (needs -> Eff es (tpl, SessionOperation)) -> ((ClaudeCodeResult schema, SessionId) -> Eff es (GotoChoice targets)) -> needs -> Eff es (GotoChoice targets) Execute a ClaudeCodeLLMHandler, returning a GotoChoice. Similar to `executeLLMHandler` , but uses the Session effect to spawn a dockerized Claude Code session via mantle. This function: 1. Calls the before-handler to build template context AND session strategy 2. Renders the user template (system template appended to prompt) 3. Detects if schema is a sum type \u2192 generates decision tools 4. Executes the appropriate Session operation (start *continue* fork) 5. Parses output from tool calls (sum types) or structured output (others) 6. Implements nag logic if sum type but no tool call (max 5 retries) 7. Calls the after-handler with output AND session ID for routing # Type Parameters + `model` - The ModelChoice from ClaudeCode annotation (type-level) + `needs` - The input type from Input annotation + `schema` - The LLM output schema type + `targets` - The transition targets from UsesEffects + `es` - The effect stack (must include Session) + `tpl` - The template context type # Session Management The before handler returns a `SessionOperation` alongside the template context: + 'StartFresh slug' - Create a new session with the given slug + 'ContinueFrom sid' - Resume an existing session (preserves conversation history) + 'ForkFrom parentSid childSlug' - Create a read-only fork from parent session The after handler receives both the parsed output and the session ID that was used/created, enabling downstream handlers to register sessions for later reuse. # Sum Type Handling (Decision Tools) For sum types with data (detected via `ClaudeCodeSchema` ), this function: 1. Generates MCP decision tools where each tool = one constructor 2. Passes tools to the session; Claude Code calls one to \"select\" a branch 3. Parses the tool call back to the Haskell sum type 4. If Claude doesn't call a tool, nags with a retry prompt (max 5 retries) This works around Anthropic's lack of oneOf support in structured output.\n\nCandidates:\n  Fields: (none)\n  Inputs: TypedTemplate, SourcePos, TypedTemplate, SourcePos, SessionOperation, ClaudeCodeResult, SessionId, GotoChoice\n  Output: GotoChoice, Execute, ClaudeCodeLLMHandler, GotoChoice., Similar, Session, Claude, Code, This, Calls, AND, Renders, Detects, Executes, Parses, Implements, ID, Type, Parameters, The, ModelChoice, ClaudeCode, Input, LLM, UsesEffects, Management, SessionOperation, Create, Resume, Sum, Handling, Decision, Tools, For, ClaudeCodeSchema, Generates, MCP, Passes, Haskell, If, Anthropic's\n  References: Interpret.hs:40, Interpret.hs:340, Interpret.hs:354, Interpret.hs:553\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>TypedTemplate,SourcePos,GotoChoice<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform NodeInfo into LLM?\nSymbol: renderNodeComments\nModule: Tidepool.Graph.Mermaid\nPackage: tidepool-core\nSignature: renderNodeComments :: NodeInfo -> [Text] Render structured comments for a node (for LLM context).\n\nCandidates:\n  Fields: (none)\n  Inputs: NodeInfo\n  Output: Render, LLM\n  References: Mermaid.hs:169, Mermaid.hs:174, Mermaid.hs:175\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>NodeInfo,LLM<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I access the input value for this node?\nSymbol: GetNodeInput\nModule: Tidepool.Effect.GraphContext\nPackage: tidepool-core\nSignature: GetNodeInput :: forall {k} (input :: k). NodeInput input input Get the input value for this node invocation.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetNodeInput, NodeInput, Get\n  References: GraphContext.hs:129, GraphContext.hs:165, GraphContext.hs:206\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetNodeInput,NodeInput<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When should I ignore the graph entry value?\nSymbol: GetEntry\nModule: Tidepool.Effect.GraphContext\nPackage: tidepool-core\nSignature: GetEntry :: forall {k} (entry :: k). GraphContext entry entry Get the entry value that spawned this graph.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetEntry, GraphContext, Get\n  References: GraphContext.hs:87, GraphContext.hs:105, GraphContext.hs:187\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Location and LocationUriOnly into Location?\nSymbol: extractLocationFromWS\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: extractLocationFromWS :: (Location |? LocationUriOnly) -> Location\n\nCandidates:\n  Fields: (none)\n  Inputs: Location, LocationUriOnly\n  Output: Location\n  References: Interpreter.hs:465, Interpreter.hs:469, Interpreter.hs:470\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Location,LocationUriOnly<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming LSPSession and Session into Execute?\nSymbol: executeSession\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: executeSession :: forall a. LSPSession -> Session a -> IO a Execute a Session action via the session handle. Sends the action to the worker, waits for response with timeout.\n\nCandidates:\n  Fields: (none)\n  Inputs: LSPSession, Session\n  Output: Execute, Session, Sends\n  References: Interpreter.hs:158, Interpreter.hs:159, Interpreter.hs:187, Interpreter.hs:194, Interpreter.hs:203, Interpreter.hs:210, Interpreter.hs:217, Interpreter.hs:233, Interpreter.hs:240\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I get a human-readable tool description?\nSymbol: toolDescription\nModule: Tidepool.Graph.Tool\nPackage: tidepool-core\nSignature: toolDescription :: forall t. ToolDef t => t -> Text Human-readable description (shown to LLM). The `t` value is passed in case the tool marker carries config.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Human-readable, LLM., The\n  References: Convert.hs:73, Convert.hs:93, Convert.hs:103, Convert.hs:123, Tool.hs:174, Tool.hs:252\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Human-readable,LLM.<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When should I use memory instead of input?\nSymbol: GetNodeInput\nModule: Tidepool.Effect.GraphContext\nPackage: tidepool-core\nSignature: GetNodeInput :: forall {k} (input :: k). NodeInput input input Get the input value for this node invocation.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetNodeInput, NodeInput, Get\n  References: GraphContext.hs:129, GraphContext.hs:165, GraphContext.hs:206\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming LSPSession and Value into ControlResponse?\nSymbol: handleMcpTool\nModule: Tidepool.Control.Handler.MCP\nPackage: tidepool-control-server\nSignature: handleMcpTool :: LSPSession -> Text -> Text -> Value -> IO ControlResponse\n\nCandidates:\n  Fields: (none)\n  Inputs: LSPSession, Value\n  Output: ControlResponse\n  References: MCP.hs:5, MCP.hs:27, MCP.hs:28, Handler.hs:8, Handler.hs:15\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Stack into Check?\nSymbol: isEmpty\nModule: Data.Stack\nPackage: tidepool-core\nSignature: isEmpty :: forall a. Stack a -> Bool Check if the stack is empty. ### Laws isEmpty empty == True isEmpty (push x s) == False ### Time Complexity O(1)\n\nCandidates:\n  Fields: (none)\n  Inputs: Stack\n  Output: Check, Laws, True, False, Time, Complexity, O1\n  References: Stack.hs:9, Stack.hs:37, Stack.hs:111, Stack.hs:112\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Stack<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I read the current state value?\nSymbol: Get\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: Get :: forall s. State s s\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Get, State\n  References: Types.hs:152, Types.hs:156, Types.hs:169\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>State<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform CompletionItem into CompletionItem?\nSymbol: fromCompletionItem\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromCompletionItem :: CompletionItem -> CompletionItem\n\nCandidates:\n  Fields: (none)\n  Inputs: CompletionItem\n  Output: CompletionItem\n  References: Interpreter.hs:238, Interpreter.hs:403, Interpreter.hs:404\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>CompletionItem<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform OpenAIConfig and Value into OpenAIRequest or Build or OpenAI?\nSymbol: buildOpenAIRequest\nModule: Tidepool.LLM.Interpreter\nPackage: unknown\nSignature: buildOpenAIRequest :: OpenAIConfig -> Text -> Maybe [Value] -> OpenAIRequest Build OpenAI Chat Completions API request. **Tools format** : Tools should be in OpenAI function format: { \"type\": \"function\", \"function\": { \"name\": \"...\", \"description\": \"...\", \"parameters\": {...} } } Use `CfTool` from `Tidepool.Tool.Wire` or the `ToCfTool` typeclass to produce correctly formatted tools. Do NOT pass Anthropic-format tools here.\n\nCandidates:\n  Fields: (none)\n  Inputs: OpenAIConfig, Value\n  Output: OpenAIRequest, Build, OpenAI, Chat, Completions, API, Tools, Use, CfTool, Tidepool.Tool.Wire, ToCfTool, Do, NOT, Anthropic-format\n  References: Interpreter.hs:39, Interpreter.hs:148, Interpreter.hs:163, Interpreter.hs:164\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>OpenAIConfig,Value,OpenAIRequest,Build<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Repo into Issue?\nSymbol: getIssue\nModule: Tidepool.Effects.GitHub\nPackage: tidepool-core\nSignature: getIssue :: forall (effs :: [Type -> Type]). Member GitHub effs => Repo -> Int -> Bool -> Eff effs (Maybe Issue)\n\nCandidates:\n  Fields: (none)\n  Inputs: Repo\n  Output: Issue\n  References: GitHub.hs:25, GitHub.hs:321, GitHub.hs:322\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if I need branch-agnostic operations?\nSymbol: GetCurrentBranch\nModule: Tidepool.Effects.Git\nPackage: tidepool-core\nSignature: GetCurrentBranch :: Git Text Get current branch name.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetCurrentBranch, Git, Get\n  References: Git.hs:93, Git.hs:114\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with MergeAccumulator and HList and FromPayloads and Get and HList. and Returns and Nothing and From and Just and Left and Just and Right and HNil?\nSymbol: getCompletedResults\nModule: Tidepool.Actor.Merge\nPackage: tidepool-actor\nSignature: getCompletedResults :: forall (sources :: [Type]) key. (ExtractMergeResults sources, Hashable key) => MergeAccumulator key -> key -> IO (Maybe (Either Text (HList (FromPayloads sources)))) Get the completed results for a correlation key as a typed HList. Returns `Nothing` if the key doesn't exist or isn't complete. Returns 'Left err' if parsing fails for any result. Returns 'Right hlist' with the typed results in source order. acc <- newMergeAccumulator `'[From \"a\" Int, From \"b\" String] -- ... add results ... result <- getCompletedResults ` '[From \"a\" Int, From \"b\" String] acc key case result of Nothing -> putStrLn \"Not complete yet\" Just (Left err) -> putStrLn $ \"Parse error: \" <> err Just (Right (a ::: b ::: HNil)) -> print (a, b)\n\nCandidates:\n  Fields: (none)\n  Inputs: MergeAccumulator, HList, FromPayloads, Get, HList., Returns, Nothing, From, Just, Left, Just, Right, HNil\n  Output: (none)\n  References: Merge.hs:16, Merge.hs:238, Merge.hs:246, Barrier.hs:57, Barrier.hs:180\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>MergeAccumulator,HList<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform LLMConfig into LLMEnv?\nSymbol: mkLLMEnv\nModule: Tidepool.LLM.Types\nPackage: unknown\nSignature: mkLLMEnv :: LLMConfig -> IO LLMEnv\n\nCandidates:\n  Fields: (none)\n  Inputs: LLMConfig\n  Output: LLMEnv\n  References: Interpreter.hs:31, Interpreter.hs:69, Types.hs:47, Types.hs:145, Types.hs:146\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>LLMConfig,LLMEnv<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Value into ParseDiagnostic or Generic?\nSymbol: typeMismatch\nModule: Tidepool.StructuredOutput.Error\nPackage: tidepool-core\nSignature: typeMismatch :: [Text] -> Text -> Value -> ParseDiagnostic Generic type mismatch error.\n\nCandidates:\n  Fields: (none)\n  Inputs: Value\n  Output: ParseDiagnostic, Generic\n  References: Error.hs:19, Error.hs:99, Error.hs:100, Generic.hs:38, Generic.hs:377, Generic.hs:385, Generic.hs:386, Generic.hs:400, Instances.hs:46, Instances.hs:72, Instances.hs:81, Instances.hs:145, Instances.hs:161\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming AnthropicConfig and Value into AnthropicRequest or Build or Anthropic?\nSymbol: buildAnthropicRequest\nModule: Tidepool.LLM.Interpreter\nPackage: unknown\nSignature: buildAnthropicRequest :: AnthropicConfig -> Text -> Maybe [Value] -> AnthropicRequest Build Anthropic Messages API request. Tools should be in Anthropic format (with `input_schema` , not `parameters` ). Use `AnthropicTool` or `Tidepool.Tool.toolToJSON` which produce the correct format.\n\nCandidates:\n  Fields: (none)\n  Inputs: AnthropicConfig, Value\n  Output: AnthropicRequest, Build, Anthropic, Messages, API, Tools, Use, AnthropicTool, Tidepool.Tool.toolToJSON\n  References: Interpreter.hs:38, Interpreter.hs:106, Interpreter.hs:115, Interpreter.hs:116\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform JSONSchema into Extract?\nSymbol: extractSchemaFields\nModule: Tidepool.Graph.Reify\nPackage: tidepool-core\nSignature: extractSchemaFields :: JSONSchema -> [(Text, Text, Bool)] Extract fields from a JSONSchema. Returns (fieldName, fieldType, isRequired) for each property.\n\nCandidates:\n  Fields: (none)\n  Inputs: JSONSchema\n  Output: Extract, JSONSchema., Returns\n  References: Reify.hs:256, Reify.hs:257, Reify.hs:445\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>JSONSchema,Extract,JSONSchema.<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform ToolInfo into Render?\nSymbol: renderToolsComment\nModule: Tidepool.Graph.Mermaid\nPackage: tidepool-core\nSignature: renderToolsComment :: [ToolInfo] -> Text Render tools comment.\n\nCandidates:\n  Fields: (none)\n  Inputs: ToolInfo\n  Output: Render\n  References: Mermaid.hs:181, Mermaid.hs:213, Mermaid.hs:214, Mermaid.hs:215\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>ToolInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming MemoryStore and MemoryStore and Run and This and Loads and Runs and Saves and If and Use and ExploreMem into ExploreMem?\nSymbol: runMemoryScoped\nModule: Tidepool.Graph.Memory\nPackage: tidepool-core\nSignature: runMemoryScoped :: forall s (effs :: [Type -> Type]) a. (ToJSON s, FromJSON s) => Text -> s -> MemoryStore -> Eff (Memory s : effs) a -> Eff effs (a, MemoryStore) Run memory effect with scoped persistence. This interpreter: 1. Loads initial state from the store (or uses default if scope missing) 2. Runs the action 3. Saves final state back to the store If deserialization fails (e.g., schema mismatch after code changes), the default value is used. Use `getScope` directly if you need to detect errors. (result, finalStore) <- runMemoryScoped \"explore\" defaultState store $ do updateMem `ExploreMem $ \\m -> m { visited = newUrl : m.visited } getMem ` ExploreMem\n\nCandidates:\n  Fields: (none)\n  Inputs: MemoryStore, MemoryStore, Run, This, Loads, Runs, Saves, If, Use, ExploreMem\n  Output: ExploreMem\n  References: Memory.hs:91, Memory.hs:435, Memory.hs:442, Memory.hs:467\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming CreateBead and CreateBeadInput into BD?\nSymbol: CreateBead\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: CreateBead :: CreateBeadInput %1 -> BD Text Create a new bead, returns the generated ID.\n\nCandidates:\n  Fields: (none)\n  Inputs: CreateBead, CreateBeadInput\n  Output: BD, Create, ID.\n  References: BD.hs:344, BD.hs:418\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform ContentBlock and Value and Value into TurnOutcome or TurnParseResult?\nSymbol: runTurnContent\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: runTurnContent :: forall output (effs :: [Type -> Type]). (Member LLM effs, StructuredOutput output, ValidStructuredOutput output) => Text -> [ContentBlock] -> Value -> [Value] -> Eff effs (TurnOutcome (TurnParseResult output))\n\nCandidates:\n  Fields: (none)\n  Inputs: ContentBlock, Value, Value\n  Output: TurnOutcome, TurnParseResult\n  References: Types.hs:54, Types.hs:389, Types.hs:391, Types.hs:396\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>ContentBlock,Value,TurnOutcome,TurnParseResult<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Type and TeachGemma into Mock or Simply or Useful?\nSymbol: runTeachGemmaMock\nModule: Tidepool.Control.Scout.Teach.Gemma\nPackage: tidepool-control-server\nSignature: runTeachGemmaMock :: forall (effs :: [Type -> Type]) a. Eff (TeachGemma : effs) a -> Eff effs a Mock interpreter for testing. Simply returns all candidates (no filtering). Useful for testing the exploration loop without Gemma dependency.\n\nCandidates:\n  Fields: (none)\n  Inputs: Type, TeachGemma\n  Output: Mock, Simply, Useful, Gemma\n  References: Gemma.hs:39, Gemma.hs:371, Gemma.hs:372\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Type,TeachGemma,Mock,Simply<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform CreateTodoTry into Habitica or HabiticaError or TodoId?\nSymbol: CreateTodoTry\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: CreateTodoTry :: Text %1 -> Habitica (Either HabiticaError TodoId)\n\nCandidates:\n  Fields: (none)\n  Inputs: CreateTodoTry\n  Output: Habitica, HabiticaError, TodoId\n  References: Habitica.hs:77, Habitica.hs:117, Habitica.hs:162\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>CreateTodoTry,Habitica,HabiticaError<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I query the current Git branch name?\nSymbol: GetCurrentBranch\nModule: Tidepool.Effects.Git\nPackage: tidepool-core\nSignature: GetCurrentBranch :: Git Text Get current branch name.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetCurrentBranch, Git, Get\n  References: Git.hs:93, Git.hs:114\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetCurrentBranch,Git<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform GetRecentCommits into Git?\nSymbol: GetRecentCommits\nModule: Tidepool.Effects.Git\nPackage: tidepool-core\nSignature: GetRecentCommits :: Int %1 -> Git [Text] Get recent commit subjects.\n\nCandidates:\n  Fields: (none)\n  Inputs: GetRecentCommits\n  Output: Git, Get\n  References: Git.hs:90, Git.hs:110\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetRecentCommits,Git<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I read the current memory state for this node?\nSymbol: GetMem\nModule: Tidepool.Graph.Memory\nPackage: tidepool-core\nSignature: GetMem :: forall s. Memory s s Get the current memory value.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetMem, Memory, Get\n  References: Memory.hs:121, Memory.hs:135, Memory.hs:206\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetMem,Memory<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if I need to preserve camelCase?\nSymbol: camelToSnake\nModule: Tidepool.Effect.Session\nPackage: tidepool-core\nSignature: camelToSnake :: ShowS\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: ShowS\n  References: Session.hs:193, Session.hs:222, Session.hs:247, Session.hs:271, Session.hs:292, Session.hs:293\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Command and CodeAction into CodeAction?\nSymbol: fromCodeActionsResult\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromCodeActionsResult :: [Command |? CodeAction] -> [CodeAction]\n\nCandidates:\n  Fields: (none)\n  Inputs: Command, CodeAction\n  Output: CodeAction\n  References: Interpreter.hs:215, Interpreter.hs:352, Interpreter.hs:353\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When is dynamic node lookup unnecessary?\nSymbol: GetNodeDef\nModule: Tidepool.Graph.Generic\nPackage: tidepool-core\nSignature: GetNodeDef\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetNodeDef\n  References: Generic.hs:81, Generic.hs:1050, Generic.hs:1051, Interpret.hs:77, Interpret.hs:904, Interpret.hs:905, Interpret.hs:907, Interpret.hs:946, Interpret.hs:950, Interpret.hs:964, Interpret.hs:969, Interpret.hs:901, Interpret.hs:913, Interpret.hs:945, Interpret.hs:949, Interpret.hs:963, Interpret.hs:968\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I retrieve worktree configuration?\nSymbol: getWorktreeInfo\nModule: Tidepool.Effects.Git\nPackage: tidepool-core\nSignature: getWorktreeInfo :: forall (effs :: [Type -> Type]). Member Git effs => Eff effs (Maybe WorktreeInfo) Get worktree/repo information.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: WorktreeInfo, Get\n  References: Git.hs:20, Git.hs:101, Git.hs:102\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>WorktreeInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When should I avoid creating a bead update record with no field modifications?\nSymbol: emptyUpdateInput\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: emptyUpdateInput :: UpdateBeadInput\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: UpdateBeadInput\n  References: BD.hs:57, BD.hs:302, BD.hs:303\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform CompletionItemKind into CompletionItemKind?\nSymbol: fromCompletionItemKind\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromCompletionItemKind :: CompletionItemKind -> CompletionItemKind\n\nCandidates:\n  Fields: (none)\n  Inputs: CompletionItemKind\n  Output: CompletionItemKind\n  References: Interpreter.hs:406, Interpreter.hs:417, Interpreter.hs:418\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>CompletionItemKind<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform GetPullRequest and Repo into GitHub or PullRequest?\nSymbol: GetPullRequest\nModule: Tidepool.Effects.GitHub\nPackage: tidepool-core\nSignature: GetPullRequest :: Repo %1 -> Int %1 -> Bool %1 -> GitHub (Maybe PullRequest)\n\nCandidates:\n  Fields: (none)\n  Inputs: GetPullRequest, Repo\n  Output: GitHub, PullRequest\n  References: GitHub.hs:306, GitHub.hs:328, GitHub.hs:359\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetPullRequest,Repo,GitHub,PullRequest<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if user turn format differs?\nSymbol: formatUserTurn\nModule: Tidepool.Training.Format\nPackage: tidepool-training-generator\nSignature: formatUserTurn :: Text -> Text -> Text -> Text -> Maybe Text -> [Text] -> Text Format user turn with LSP context. Lean format optimized for token density: - No escape tags in user turn (plain text context) - Module + Package for disambiguation - First-sentence docs only - Signature pre-cleaned (no forall, no markdown)\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Format, LSP, Lean, No, Module, Package, First-sentence, Signature\n  References: Format.hs:7, Format.hs:48, Format.hs:56, Format.hs:94\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming GetLabels into BD?\nSymbol: GetLabels\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: GetLabels :: Text %1 -> BD [Text] Get labels attached to a bead.\n\nCandidates:\n  Fields: (none)\n  Inputs: GetLabels\n  Output: BD, Get\n  References: BD.hs:331, BD.hs:386\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform LocationLink into Location?\nSymbol: fromLocationLink\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromLocationLink :: LocationLink -> Location\n\nCandidates:\n  Fields: (none)\n  Inputs: LocationLink\n  Output: Location\n  References: Interpreter.hs:343, Interpreter.hs:345, Interpreter.hs:346\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>LocationLink,Location<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming GetChildren into BD or BeadInfo?\nSymbol: GetChildren\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: GetChildren :: Text %1 -> BD [BeadInfo] Get child beads (beads with this as parent).\n\nCandidates:\n  Fields: (none)\n  Inputs: GetChildren\n  Output: BD, BeadInfo, Get\n  References: BD.hs:334, BD.hs:390\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I fetch the current Habitica user profile?\nSymbol: getUser\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: getUser :: forall (effs :: [Type -> Type]). Member Habitica effs => Eff effs UserInfo\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: UserInfo\n  References: Habitica.hs:11, Habitica.hs:96, Habitica.hs:97\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>UserInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I retrieve the conversation message history?\nSymbol: getHistory\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: getHistory :: forall (effs :: [Type -> Type]). Member ChatHistory effs => Eff effs [Message]\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Message\n  References: Types.hs:45, Types.hs:516, Types.hs:517\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Message<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When can I assume user fetch always succeeds?\nSymbol: getUserTry\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: getUserTry :: forall (effs :: [Type -> Type]). Member Habitica effs => Eff effs (Either HabiticaError UserInfo)\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: HabiticaError, UserInfo\n  References: Habitica.hs:19, Habitica.hs:119, Habitica.hs:120\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I create a dispatcher that silently ignores all events?\nSymbol: noDispatcher\nModule: .Tidepool\nPackage: tidepool-core\nSignature: noDispatcher :: forall s evt. AgentDispatcher s evt\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: AgentDispatcher\n  References: Tidepool.hs:37, Tidepool.hs:84, Tidepool.hs:125, Tidepool.hs:141, Tidepool.hs:142\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>AgentDispatcher<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Stack into Stack?\nSymbol: push\nModule: Data.Stack\nPackage: tidepool-core\nSignature: push :: forall a. a -> Stack a -> Stack a Push an element onto the top of the stack. The pushed element becomes the first element to be popped. Stack size increases by one. ### Law pop (push x s) == Just (x, s) ### Time Complexity O(1)\n\nCandidates:\n  Fields: (none)\n  Inputs: Stack\n  Output: Stack, Push, The, Law, Just, Time, Complexity, O1\n  References: Stack.hs:6, Stack.hs:34, Stack.hs:70, Stack.hs:71\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform MergeAccumulator into HList or FromPayloads?\nSymbol: getCompletedResults\nModule: Tidepool.Actor.Merge\nPackage: tidepool-actor\nSignature: getCompletedResults :: forall (sources :: [Type]) key. (ExtractMergeResults sources, Hashable key) => MergeAccumulator key -> key -> IO (Maybe (Either Text (HList (FromPayloads sources))))\n\nCandidates:\n  Fields: (none)\n  Inputs: MergeAccumulator\n  Output: HList, FromPayloads\n  References: Merge.hs:16, Merge.hs:238, Merge.hs:246, Barrier.hs:57, Barrier.hs:180\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>MergeAccumulator,HList,FromPayloads<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When should I avoid querying repo state?\nSymbol: GetWorktreeInfo\nModule: Tidepool.Effects.Git\nPackage: tidepool-core\nSignature: GetWorktreeInfo :: Git (Maybe WorktreeInfo) Get worktree/repo information. Returns Nothing if not in a git repository.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetWorktreeInfo, Git, WorktreeInfo, Get, Returns, Nothing\n  References: Git.hs:84, Git.hs:102\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming GetBlocking into BD or BeadInfo?\nSymbol: GetBlocking\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: GetBlocking :: Text %1 -> BD [BeadInfo] Get beads that this bead is blocking.\n\nCandidates:\n  Fields: (none)\n  Inputs: GetBlocking\n  Output: BD, BeadInfo, Get\n  References: BD.hs:328, BD.hs:382\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming GotoChoice into Value?\nSymbol: extractChoice\nModule: Tidepool.Actor.Graph\nPackage: tidepool-actor\nSignature: extractChoice :: forall (targets :: [Type]). ExtractChoice targets => GotoChoice targets -> (Text, Value)\n\nCandidates:\n  Fields: (none)\n  Inputs: GotoChoice\n  Output: Value\n  References: [many references (21) - hub symbol]\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What does an explicit runtime edge represent?\nSymbol: RuntimeExplicit\nModule: Tidepool.Graph.Reify\nPackage: tidepool-core\nSignature: RuntimeExplicit\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: RuntimeExplicit\n  References: Reify.hs:207, Reify.hs:863, Reify.hs:874, Export.hs:289\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>RuntimeExplicit<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform MemoryStore and MemoryStore and Run and This and Loads and Runs and Saves and If and Use and ExploreMem into ExploreMem?\nSymbol: runMemoryScoped\nModule: Tidepool.Graph.Memory\nPackage: tidepool-core\nSignature: runMemoryScoped :: forall s (effs :: [Type -> Type]) a. (ToJSON s, FromJSON s) => Text -> s -> MemoryStore -> Eff (Memory s : effs) a -> Eff effs (a, MemoryStore) Run memory effect with scoped persistence. This interpreter: 1. Loads initial state from the store (or uses default if scope missing) 2. Runs the action 3. Saves final state back to the store If deserialization fails (e.g., schema mismatch after code changes), the default value is used. Use `getScope` directly if you need to detect errors. (result, finalStore) <- runMemoryScoped \"explore\" defaultState store $ do updateMem `ExploreMem $ \\m -> m { visited = newUrl : m.visited } getMem ` ExploreMem\n\nCandidates:\n  Fields: (none)\n  Inputs: MemoryStore, MemoryStore, Run, This, Loads, Runs, Saves, If, Use, ExploreMem\n  Output: ExploreMem\n  References: Memory.hs:91, Memory.hs:435, Memory.hs:442, Memory.hs:467\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>MemoryStore,ExploreMem<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming MemoryInfo into Render?\nSymbol: renderMemoryComment\nModule: Tidepool.Graph.Mermaid\nPackage: tidepool-core\nSignature: renderMemoryComment :: Maybe MemoryInfo -> Text Render memory comment.\n\nCandidates:\n  Fields: (none)\n  Inputs: MemoryInfo\n  Output: Render\n  References: Mermaid.hs:182, Mermaid.hs:218, Mermaid.hs:219, Mermaid.hs:220\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to SubgraphState?\nSymbol: runSubgraph\nModule: Tidepool.Actor.Subgraph\nPackage: tidepool-actor\nSignature: runSubgraph :: forall entry result (effs :: [Type -> Type]) a. LastMember IO effs => SubgraphState entry result -> Eff (Subgraph entry result : effs) a -> Eff effs a\n\nCandidates:\n  Fields: (none)\n  Inputs: SubgraphState\n  Output: (none)\n  References: Subgraph.hs:55, Subgraph.hs:303, Subgraph.hs:309\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to SProvider and LLMProviderConfig and Value and LLMError and LLMProviderResponse and Call and LLM and Use and SAnthropic and Left and LLMRateLimited and SAnthropic and Left and Right?\nSymbol: completeTry\nModule: Tidepool.Effects.LLMProvider\nPackage: tidepool-core\nSignature: completeTry :: forall (p :: LLMProvider) (effs :: [Type -> Type]). Member LLMComplete effs => SProvider p -> LLMProviderConfig p -> Text -> Maybe [Value] -> Eff effs (Either LLMError (LLMProviderResponse p)) Call an LLM with provider-specific config, returning errors as `Either` . Use this when you want to handle errors gracefully: result <- completeTry SAnthropic config msg tools case result of Left LLMRateLimited -> do liftIO $ threadDelay 1000000 completeTry SAnthropic config msg tools -- retry Left err -> logError $ \"LLM failed: \" <> show err Right response -> processResponse response\n\nCandidates:\n  Fields: (none)\n  Inputs: SProvider, LLMProviderConfig, Value, LLMError, LLMProviderResponse, Call, LLM, Use, SAnthropic, Left, LLMRateLimited, SAnthropic, Left, Right\n  Output: (none)\n  References: LLMProvider.hs:33, LLMProvider.hs:270, LLMProvider.hs:334, LLMProvider.hs:357, LLMProvider.hs:364\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Evaluate into GHCi or GHCiError or Evaluate?\nSymbol: Evaluate\nModule: Tidepool.Effect.GHCi\nPackage: tidepool-core\nSignature: Evaluate :: Text %1 -> GHCi (Either GHCiError Text) Evaluate an expression (for pure expressions). Returns the result or error.\n\nCandidates:\n  Fields: (none)\n  Inputs: Evaluate\n  Output: GHCi, GHCiError, Evaluate, Returns\n  References: GHCi.hs:217, GHCi.hs:270, GHCi.hs:319\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with Parser?\nSymbol: runGraphCLIWith\nModule: Tidepool.Graph.CLI\nPackage: tidepool-core\nSignature: runGraphCLIWith :: forall output input. (Show output, ToJSON output) => Text -> Parser input -> (input -> IO output) -> IO ()\n\nCandidates:\n  Fields: (none)\n  Inputs: Parser\n  Output: (none)\n  References: CLI.hs:74, CLI.hs:474, CLI.hs:480, CLI.hs:529\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Parser<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming ScoringContext into Render?\nSymbol: renderPatterns\nModule: Tidepool.Control.Scout.Templates\nPackage: tidepool-control-server\nSignature: renderPatterns :: ScoringContext -> Text Render patterns section if present.\n\nCandidates:\n  Fields: (none)\n  Inputs: ScoringContext\n  Output: Render\n  References: Templates.hs:93, Templates.hs:105, Templates.hs:106\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I list files with uncommitted changes?\nSymbol: getDirtyFiles\nModule: Tidepool.Effects.Git\nPackage: tidepool-core\nSignature: getDirtyFiles :: forall (effs :: [Type -> Type]). Member Git effs => Eff effs [FilePath] Get list of dirty files.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: FilePath, Get\n  References: Git.hs:21, Git.hs:105, Git.hs:106\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>FilePath<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I create a custom parse error diagnostic?\nSymbol: customError\nModule: Tidepool.StructuredOutput.Error\nPackage: tidepool-core\nSignature: customError :: [Text] -> Text -> ParseDiagnostic\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: ParseDiagnostic\n  References: Error.hs:20, Error.hs:109, Error.hs:110\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>ParseDiagnostic<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming EffectCategory into EffectCategory?\nSymbol: categoryToText\nModule: Tidepool.Effect.Metadata\nPackage: tidepool-core\nSignature: categoryToText :: EffectCategory -> Text Convert EffectCategory to Text for codegen.\n\nCandidates:\n  Fields: (none)\n  Inputs: EffectCategory\n  Output: Convert, EffectCategory\n  References: Metadata.hs:28, Metadata.hs:109, Metadata.hs:110, Metadata.hs:111\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform EdgeType into PatternMatchSite?\nSymbol: extractPatterns\nModule: Tidepool.Control.Scout.EdgeTypes\nPackage: tidepool-control-server\nSignature: extractPatterns :: EdgeType -> Text -> Maybe [Text] Extract pattern cases from snippet for PatternMatchSite edges.\n\nCandidates:\n  Fields: (none)\n  Inputs: EdgeType\n  Output: Extract, PatternMatchSite\n  References: EdgeTypes.hs:150, EdgeTypes.hs:174, EdgeTypes.hs:175, EdgeTypes.hs:179\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>EdgeType,Extract,PatternMatchSite<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with AsHandler?\nSymbol: runGraphFromWithSpans\nModule: Tidepool.Graph.Interpret.Instrumented\nPackage: tidepool-core\nSignature: runGraphFromWithSpans :: forall (name :: Symbol) (graph :: Type -> Type) entryType (targets :: [Type]) exitType (es :: [Type -> Type]) handler. (KnownSymbol name, HasField name (graph (AsHandler es)) handler, CallHandler handler entryType es targets, DispatchGotoTraced graph targets es exitType, Member Observability es) => graph (AsHandler es) -> entryType -> Eff es exitType\n\nCandidates:\n  Fields: (none)\n  Inputs: AsHandler\n  Output: (none)\n  References: Instrumented.hs:45, Instrumented.hs:134, Instrumented.hs:142, Instrumented.hs:153\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>AsHandler<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming GetArriveBarrierFromMaybeEffects and Effect into Symbol or Arrive?\nSymbol: GetArriveBarrierFromMaybeEffects\nModule: Tidepool.Graph.Validate.ForkBarrier\nPackage: tidepool-core\nSignature: GetArriveBarrierFromMaybeEffects :: Maybe [Effect] -> Maybe Symbol Extract Arrive barrier from Maybe effect list.\n\nCandidates:\n  Fields: (none)\n  Inputs: GetArriveBarrierFromMaybeEffects, Effect\n  Output: Symbol, Extract, Arrive\n  References: ForkBarrier.hs:223, ForkBarrier.hs:226, ForkBarrier.hs:227, ForkBarrier.hs:228, ForkBarrier.hs:229\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to LLMEnv?\nSymbol: runLLMComplete\nModule: Tidepool.LLM.Interpreter\nPackage: unknown\nSignature: runLLMComplete :: forall (effs :: [Type -> Type]) a. LastMember IO effs => LLMEnv -> Eff (LLMComplete : effs) a -> Eff effs a\n\nCandidates:\n  Fields: (none)\n  Inputs: LLMEnv\n  Output: (none)\n  References: Interpreter.hs:26, Interpreter.hs:275, Interpreter.hs:276\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I get child beads of a parent?\nSymbol: getChildren\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: getChildren :: forall (effs :: [Type -> Type]). Member BD effs => Text -> Eff effs [BeadInfo] Get child beads (beads with this as parent).\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: BeadInfo, Get\n  References: BD.hs:39, BD.hs:389, BD.hs:390\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>BeadInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I convert Name to a Dec or Derive or HasJSONSchema?\nSymbol: deriveHasJSONSchema\nModule: Tidepool.Schema\nPackage: tidepool-core\nSignature: deriveHasJSONSchema :: Name -> Q [Dec] Derive a `HasJSONSchema` instance for a record type.\n\nCandidates:\n  Fields: (none)\n  Inputs: Name\n  Output: Dec, Derive, HasJSONSchema\n  References: Schema.hs:38, Schema.hs:224, Schema.hs:225\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Name<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with LSPSession?\nSymbol: runLSP\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: runLSP :: forall (effs :: [Type -> Type]) a. LastMember IO effs => LSPSession -> Eff (LSP : effs) a -> Eff effs a\n\nCandidates:\n  Fields: (none)\n  Inputs: LSPSession\n  Output: (none)\n  References: Interpreter.hs:12, Interpreter.hs:180, Interpreter.hs:181, MCP.hs:21, MCP.hs:71, Export.hs:24, Export.hs:35, Export.hs:49, Export.hs:79, Export.hs:83\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>LSPSession<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform GetBlocking into BD or BeadInfo?\nSymbol: GetBlocking\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: GetBlocking :: Text %1 -> BD [BeadInfo] Get beads that this bead is blocking.\n\nCandidates:\n  Fields: (none)\n  Inputs: GetBlocking\n  Output: BD, BeadInfo, Get\n  References: BD.hs:328, BD.hs:382\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetBlocking,BD,BeadInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform CreateTodo into Habitica or TodoId?\nSymbol: CreateTodo\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: CreateTodo :: Text %1 -> Habitica TodoId\n\nCandidates:\n  Fields: (none)\n  Inputs: CreateTodo\n  Output: Habitica, TodoId\n  References: Habitica.hs:69, Habitica.hs:94, Habitica.hs:142\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>CreateTodo,Habitica,TodoId<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming TemplateTreeConfig and DependencyTree into Render?\nSymbol: renderDependencyTree\nModule: Tidepool.Template.DependencyTree\nPackage: tidepool-core\nSignature: renderDependencyTree :: TemplateTreeConfig -> DependencyTree -> Text Render a dependency tree to Mermaid syntax.\n\nCandidates:\n  Fields: (none)\n  Inputs: TemplateTreeConfig, DependencyTree\n  Output: Render, Mermaid\n  References: DependencyTree.hs:103, DependencyTree.hs:106, DependencyTree.hs:107\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Range into Range?\nSymbol: toRange\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: toRange :: Range -> Range\n\nCandidates:\n  Fields: (none)\n  Inputs: Range\n  Output: Range\n  References: Interpreter.hs:212, Interpreter.hs:278, Interpreter.hs:279\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Value into Ollama or Response or ScoreConfig?\nSymbol: extractSelectedFromToolCall\nModule: Tidepool.Control.Scout.Teach.Gemma\nPackage: tidepool-control-server\nSignature: extractSelectedFromToolCall :: Value -> Either Text [Text] Extract selected symbols array from Ollama tool call response. Response format: { \"message\": { \"tool_calls\": [{ \"function\": { \"arguments\": { \"selected\": [ `ScoreConfig` , `EdgeContext` ] } } }] } }\n\nCandidates:\n  Fields: (none)\n  Inputs: Value\n  Output: Extract, Ollama, Response, ScoreConfig, EdgeContext\n  References: Gemma.hs:294, Gemma.hs:309, Gemma.hs:310\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform RunTurnOp and ContentBlock and Value and Value into LLM or TurnOutcome or TurnResult?\nSymbol: RunTurnOp\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: RunTurnOp :: Text %1 -> [ContentBlock] %1 -> Value %1 -> [Value] %1 -> LLM (TurnOutcome (TurnResult Value))\n\nCandidates:\n  Fields: (none)\n  Inputs: RunTurnOp, ContentBlock, Value, Value\n  Output: LLM, TurnOutcome, TurnResult, Value\n  References: Types.hs:211, Types.hs:397\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>RunTurnOp,ContentBlock,LLM,TurnOutcome<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming CreateBeadInput and BeadType and DependencyType into CreateBeadInput?\nSymbol: CreateBeadInput\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: CreateBeadInput :: Text %1 -> Maybe Text %1 -> BeadType %1 -> Int %1 -> Maybe Text %1 -> [Text] %1 -> Maybe Text %1 -> [(Text, DependencyType)] %1 -> CreateBeadInput\n\nCandidates:\n  Fields: (none)\n  Inputs: CreateBeadInput, BeadType, DependencyType\n  Output: CreateBeadInput\n  References: BD.hs:263, BD.hs:264, BD.hs:265, BD.hs:266, BD.hs:267, BD.hs:268, BD.hs:269, BD.hs:270, BD.hs:271, BD.hs:277\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with Parser and GraphEntryType and AsHandler?\nSymbol: runGraphCLIPure\nModule: Tidepool.Graph.CLI\nPackage: tidepool-core\nSignature: runGraphCLIPure :: forall (graph :: Type -> Type) (entryHandlerName :: Symbol) handler (targets :: [Type]). (Show (GraphExitType graph), ToJSON (GraphExitType graph), Generic (graph AsGraph), FindEntryHandler (GraphEntryType graph) (FieldsWithNamesOf graph) ~ 'Just entryHandlerName, KnownSymbol entryHandlerName, HasField entryHandlerName (graph (AsHandler '[])) handler, CallHandler handler (GraphEntryType graph) '[] targets, DispatchGoto graph targets '[] (GraphExitType graph)) => Text -> Parser (GraphEntryType graph) -> graph (AsHandler '[]) -> IO ()\n\nCandidates:\n  Fields: (none)\n  Inputs: Parser, GraphEntryType, AsHandler\n  Output: (none)\n  References: CLI.hs:75, CLI.hs:513, CLI.hs:528\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Parser,GraphEntryType<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When should I ignore the graph entry value?\nSymbol: GetEntry\nModule: Tidepool.Effect.GraphContext\nPackage: tidepool-core\nSignature: GetEntry :: forall {k} (entry :: k). GraphContext entry entry Get the entry value that spawned this graph.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetEntry, GraphContext, Get\n  References: GraphContext.hs:87, GraphContext.hs:105, GraphContext.hs:187\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Location and LocationUriOnly into Location?\nSymbol: extractLocationFromWS\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: extractLocationFromWS :: (Location |? LocationUriOnly) -> Location\n\nCandidates:\n  Fields: (none)\n  Inputs: Location, LocationUriOnly\n  Output: Location\n  References: Interpreter.hs:465, Interpreter.hs:469, Interpreter.hs:470\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if you don't have pre-registered field schemas available?\nSymbol: GetFieldSchema\nModule: Tidepool.Graph.Validate.RecordStructure\nPackage: tidepool-core\nSignature: GetFieldSchema :: [(Symbol, Type)] -> Symbol -> Maybe Type Get Schema type for a field by name.\n\nCandidates:\n  Fields: (none)\n  Inputs: GetFieldSchema, Symbol, Type, Symbol\n  Output: Type, Get, Schema\n  References: RecordStructure.hs:226, RecordStructure.hs:229, RecordStructure.hs:230, RecordStructure.hs:231, RecordStructure.hs:232, RecordStructure.hs:235\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform FilePath into DependencyTree or Build or Recursively?\nSymbol: buildDependencyTree\nModule: Tidepool.Template.DependencyTree\nPackage: tidepool-core\nSignature: buildDependencyTree :: FilePath -> IO DependencyTree Build a dependency tree starting from a root template. Recursively parses all included and extended templates to build a complete dependency graph.\n\nCandidates:\n  Fields: (none)\n  Inputs: FilePath\n  Output: DependencyTree, Build, Recursively\n  References: DependencyTree.hs:37, DependencyTree.hs:102, DependencyTree.hs:153, DependencyTree.hs:154\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>FilePath,DependencyTree,Build<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform TaskType into HabiticaError or HabiticaTask?\nSymbol: getTasksTry\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: getTasksTry :: forall (effs :: [Type -> Type]). Member Habitica effs => TaskType -> Eff effs (Either HabiticaError [HabiticaTask])\n\nCandidates:\n  Fields: (none)\n  Inputs: TaskType\n  Output: HabiticaError, HabiticaTask\n  References: Habitica.hs:21, Habitica.hs:125, Habitica.hs:126\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>TaskType,HabiticaError,HabiticaTask<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming CandidateGroups into Format?\nSymbol: formatSelectSymbolsExampleGrouped\nModule: Tidepool.Training.Format\nPackage: tidepool-training-generator\nSignature: formatSelectSymbolsExampleGrouped :: Text -> Text -> Text -> Text -> CandidateGroups -> ByteString Format complete training example with grouped candidates (v2).\n\nCandidates:\n  Fields: (none)\n  Inputs: CandidateGroups\n  Output: Format\n  References: Format.hs:5, Format.hs:138, Format.hs:145, Export.hs:39, Export.hs:476\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Value into ParseDiagnostic?\nSymbol: expectedNumber\nModule: Tidepool.StructuredOutput.Error\nPackage: tidepool-core\nSignature: expectedNumber :: [Text] -> Value -> ParseDiagnostic Error for when a number was expected.\n\nCandidates:\n  Fields: (none)\n  Inputs: Value\n  Output: ParseDiagnostic, Error\n  References: Error.hs:16, Error.hs:67, Error.hs:68, Instances.hs:43, Instances.hs:73, Instances.hs:82, Instances.hs:88\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming GetBlocking into BD or BeadInfo?\nSymbol: GetBlocking\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: GetBlocking :: Text %1 -> BD [BeadInfo] Get beads that this bead is blocking.\n\nCandidates:\n  Fields: (none)\n  Inputs: GetBlocking\n  Output: BD, BeadInfo, Get\n  References: BD.hs:328, BD.hs:382\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I read the current memory state for this node?\nSymbol: GetMem\nModule: Tidepool.Actor.Graph\nPackage: tidepool-actor\nSignature: GetMem :: forall s. Memory s s\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetMem, Memory\n  References: Graph.hs:229, Graph.hs:234, Graph.hs:255\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetMem,Memory<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Position into Position?\nSymbol: toPosition\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: toPosition :: Position -> Position\n\nCandidates:\n  Fields: (none)\n  Inputs: Position\n  Output: Position\n  References: Interpreter.hs:189, Interpreter.hs:195, Interpreter.hs:205, Interpreter.hs:219, Interpreter.hs:235, Interpreter.hs:272, Interpreter.hs:273, Interpreter.hs:280, Interpreter.hs:281\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Position<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to IORef and Message?\nSymbol: runChatHistoryWith\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: runChatHistoryWith :: forall (effs :: [Type -> Type]) a. LastMember IO effs => IORef [Message] -> Eff (ChatHistory : effs) a -> Eff effs a\n\nCandidates:\n  Fields: (none)\n  Inputs: IORef, Message\n  Output: (none)\n  References: Types.hs:528, Types.hs:530, Types.hs:531\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Repo and Label into IssueUrl?\nSymbol: createIssue\nModule: Tidepool.Effects.GitHub\nPackage: tidepool-core\nSignature: createIssue :: forall (effs :: [Type -> Type]). Member GitHub effs => Repo -> Text -> Text -> [Label] -> Eff effs IssueUrl\n\nCandidates:\n  Fields: (none)\n  Inputs: Repo, Label\n  Output: IssueUrl\n  References: GitHub.hs:24, GitHub.hs:318, GitHub.hs:319\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform AsHandler into Run?\nSymbol: runGraphWithSpans\nModule: Tidepool.Graph.Interpret.Instrumented\nPackage: tidepool-core\nSignature: runGraphWithSpans :: forall (graph :: Type -> Type) entryType (targets :: [Type]) exitType (es :: [Effect]) (entryHandlerName :: Symbol) handler. (Generic (graph AsGraph), FindEntryHandler entryType (FieldsWithNamesOf graph) ~ 'Just entryHandlerName, KnownSymbol entryHandlerName, HasField entryHandlerName (graph (AsHandler es)) handler, CallHandler handler entryType es targets, DispatchGotoTraced graph targets es exitType, Member Observability es) => graph (AsHandler es) -> entryType -> Eff es exitType Run a graph with automatic span emission for each node transition. Creates a root span for the graph and child spans for each handler invocation. result <- runGraphWithSpans @MyGraph handlers inputValue\n\nCandidates:\n  Fields: (none)\n  Inputs: AsHandler\n  Output: Run, Creates\n  References: Instrumented.hs:44, Instrumented.hs:121, Instrumented.hs:134\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>AsHandler<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Repo into PullRequest?\nSymbol: getPullRequest\nModule: Tidepool.Effects.GitHub\nPackage: tidepool-core\nSignature: getPullRequest :: forall (effs :: [Type -> Type]). Member GitHub effs => Repo -> Int -> Bool -> Eff effs (Maybe PullRequest)\n\nCandidates:\n  Fields: (none)\n  Inputs: Repo\n  Output: PullRequest\n  References: GitHub.hs:27, GitHub.hs:327, GitHub.hs:328\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Repo,PullRequest<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Repo into Issue?\nSymbol: getIssue\nModule: Tidepool.Effects.GitHub\nPackage: tidepool-core\nSignature: getIssue :: forall (effs :: [Type -> Type]). Member GitHub effs => Repo -> Int -> Bool -> Eff effs (Maybe Issue)\n\nCandidates:\n  Fields: (none)\n  Inputs: Repo\n  Output: Issue\n  References: GitHub.hs:25, GitHub.hs:321, GitHub.hs:322\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Repo,Issue<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Repo into Issue?\nSymbol: getIssue\nModule: Tidepool.Effects.GitHub\nPackage: tidepool-core\nSignature: getIssue :: forall (effs :: [Type -> Type]). Member GitHub effs => Repo -> Int -> Bool -> Eff effs (Maybe Issue)\n\nCandidates:\n  Fields: (none)\n  Inputs: Repo\n  Output: Issue\n  References: GitHub.hs:25, GitHub.hs:321, GitHub.hs:322\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When do I need side effects in routing?\nSymbol: RuntimeLogic\nModule: Tidepool.Graph.Reify\nPackage: tidepool-core\nSignature: RuntimeLogic :: RuntimeNodeKind Pure routing logic\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: RuntimeLogic, RuntimeNodeKind, Pure\n  References: Reify.hs:199, Reify.hs:413, Reify.hs:790, Mermaid.hs:188, Mermaid.hs:247, Mermaid.hs:257, Mermaid.hs:418, Export.hs:282\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I convert Name and Name and VarBangType to a Exp or Derive or Haddock?\nSymbol: deriveFieldSchema\nModule: Tidepool.Schema\nPackage: tidepool-core\nSignature: deriveFieldSchema :: Name -> Name -> Int -> VarBangType -> Q Exp Derive schema for a single field, requiring Haddock documentation.\n\nCandidates:\n  Fields: (none)\n  Inputs: Name, Name, VarBangType\n  Output: Exp, Derive, Haddock\n  References: Schema.hs:157, Schema.hs:179, Schema.hs:180\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Name<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What are the default options for tool calls?\nSymbol: toolCallOptions\nModule: Tidepool.Effect.Session\nPackage: tidepool-core\nSignature: toolCallOptions :: Options\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Options\n  References: Session.hs:264, Session.hs:267, Session.hs:269, Session.hs:270\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Options<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Stack into Stack?\nSymbol: push\nModule: Data.Stack\nPackage: tidepool-core\nSignature: push :: forall a. a -> Stack a -> Stack a Push an element onto the top of the stack. The pushed element becomes the first element to be popped. Stack size increases by one. ### Law pop (push x s) == Just (x, s) ### Time Complexity O(1)\n\nCandidates:\n  Fields: (none)\n  Inputs: Stack\n  Output: Stack, Push, The, Law, Just, Time, Complexity, O1\n  References: Stack.hs:6, Stack.hs:34, Stack.hs:70, Stack.hs:71\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Stack<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Read and Usage and In and True and False and FailureResult and This and Memory and OLD into NEW or Direct or NodeInput?\nSymbol: getNodeInput\nModule: Tidepool.Effect.GraphContext\nPackage: tidepool-core\nSignature: getNodeInput :: forall input (effs :: [Type -> Type]). Member (NodeInput input) effs => Eff effs input Read the current node's input value. Usage requires type application to specify the input type: -- In implAfter originalInput <- getNodeInput @ImplInput case originalInput.iiAttemptCount < 5 of True -> pure $ gotoSelf originalInput { iiAttemptCount = originalInput.iiAttemptCount + 1 } False -> pure $ gotoExit FailureResult This replaces the pattern of storing input in Memory: -- OLD: Memory round-trip implBefore input = do updateMem @ImplMem $ \\m -> m { imOriginalInput = Just input } ... implAfter (exit, sid) = do mem <- getMem @ImplMem let originalInput = fromMaybe (error \"impossible\") mem.imOriginalInput ... -- NEW: Direct via NodeInput implAfter (exit, sid) = do originalInput <- getNodeInput @ImplInput ...\n\nCandidates:\n  Fields: (none)\n  Inputs: Read, Usage, In, True, False, FailureResult, This, Memory, OLD\n  Output: Just, NEW, Direct, NodeInput\n  References: GraphContext.hs:56, GraphContext.hs:161, GraphContext.hs:165\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Usage,NEW<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with MermaidConfig and GraphInfo?\nSymbol: toMermaidWithConfig\nModule: Tidepool.Graph.Mermaid\nPackage: tidepool-core\nSignature: toMermaidWithConfig :: MermaidConfig -> GraphInfo -> Text\n\nCandidates:\n  Fields: (none)\n  Inputs: MermaidConfig, GraphInfo\n  Output: (none)\n  References: Mermaid.hs:30, Mermaid.hs:90, Mermaid.hs:136, Mermaid.hs:143, Mermaid.hs:144, Graph.hs:164\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>MermaidConfig,GraphInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I access past messages in a chat context?\nSymbol: GetHistory\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: GetHistory :: ChatHistory [Message]\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetHistory, ChatHistory, Message\n  References: Types.hs:512, Types.hs:517, Types.hs:532\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetHistory,ChatHistory<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I initialize an empty stack data structure?\nSymbol: empty\nModule: Data.Stack\nPackage: tidepool-core\nSignature: empty :: forall a. Stack a\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Stack\n  References: Stack.hs:32, Stack.hs:57, Stack.hs:58\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Stack<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming TeachQuery and SymbolKey and LSPSymbol into TeachingDoc or Build or Groups?\nSymbol: buildTeachingDoc\nModule: Tidepool.Control.Scout.Teach\nPackage: tidepool-control-server\nSignature: buildTeachingDoc :: TeachQuery -> Map SymbolKey (Int, LSPSymbol) -> TeachingDoc Build a teaching document from the exploration graph. Groups by BFS depth: - Depth 0: Core (seed symbols) - Depth 1-2: Prerequisites - Depth 3+: Support\n\nCandidates:\n  Fields: (none)\n  Inputs: TeachQuery, SymbolKey, LSPSymbol\n  Output: TeachingDoc, Build, Groups, BFS, Depth, Core, Prerequisites, Support\n  References: Teach.hs:130, Teach.hs:366, Teach.hs:367\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform EdgeType into TypeReference?\nSymbol: extractTypeName\nModule: Tidepool.Control.Scout.EdgeTypes\nPackage: tidepool-control-server\nSignature: extractTypeName :: EdgeType -> Text -> Maybe Text Extract type name from hover for TypeReference edges.\n\nCandidates:\n  Fields: (none)\n  Inputs: EdgeType\n  Output: Extract, TypeReference\n  References: EdgeTypes.hs:148, EdgeTypes.hs:155, EdgeTypes.hs:156, EdgeTypes.hs:163\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>EdgeType,Extract,TypeReference<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Name into UsesOneOf?\nSymbol: deriveUsesOneOf\nModule: Tidepool.Schema\nPackage: tidepool-core\nSignature: deriveUsesOneOf :: Name -> Q [Dec] Derive a `UsesOneOf` instance for a type.\n\nCandidates:\n  Fields: (none)\n  Inputs: Name\n  Output: Dec, Derive, UsesOneOf\n  References: Schema.hs:39, Schema.hs:255, Schema.hs:256\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Name<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform ContentBlock and Value and Value into TurnOutcome or TurnParseResult?\nSymbol: runTurnContent\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: runTurnContent :: forall output (effs :: [Type -> Type]). (Member LLM effs, StructuredOutput output, ValidStructuredOutput output) => Text -> [ContentBlock] -> Value -> [Value] -> Eff effs (TurnOutcome (TurnParseResult output))\n\nCandidates:\n  Fields: (none)\n  Inputs: ContentBlock, Value, Value\n  Output: TurnOutcome, TurnParseResult\n  References: Types.hs:54, Types.hs:389, Types.hs:391, Types.hs:396\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>ContentBlock,Value,TurnOutcome,TurnParseResult<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming CompleteTry and LLMProvider. and SProvider and LLMProviderConfig and Value into LLMComplete or LLMError or LLMProviderResponse?\nSymbol: CompleteTry\nModule: Tidepool.Effects.LLMProvider\nPackage: tidepool-core\nSignature: CompleteTry :: forall (p :: LLMProvider). SProvider p %1 -> LLMProviderConfig p %1 -> Text %1 -> Maybe [Value] %1 -> LLMComplete (Either LLMError (LLMProviderResponse p))\n\nCandidates:\n  Fields: (none)\n  Inputs: CompleteTry, LLMProvider., SProvider, LLMProviderConfig, Value\n  Output: LLMComplete, LLMError, LLMProviderResponse\n  References: LLMProvider.hs:300, LLMProvider.hs:320, LLMProvider.hs:364, Interpreter.hs:255, Interpreter.hs:291, Interpreter.hs:294\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform ScoringContext into Render?\nSymbol: renderTypeInfo\nModule: Tidepool.Control.Scout.Templates\nPackage: tidepool-control-server\nSignature: renderTypeInfo :: ScoringContext -> Text Render type info section if present.\n\nCandidates:\n  Fields: (none)\n  Inputs: ScoringContext\n  Output: Render\n  References: Templates.hs:92, Templates.hs:99, Templates.hs:100\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>ScoringContext<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Value into ParseDiagnostic?\nSymbol: expectedObject\nModule: Tidepool.StructuredOutput.Error\nPackage: tidepool-core\nSignature: expectedObject :: [Text] -> Value -> ParseDiagnostic Error for when an object was expected.\n\nCandidates:\n  Fields: (none)\n  Inputs: Value\n  Output: ParseDiagnostic, Error\n  References: Error.hs:13, Error.hs:40, Error.hs:41, Generic.hs:38, Generic.hs:85, Generic.hs:287, Generic.hs:401, Generic.hs:402, Generic.hs:403\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming SymbolInformation into SymbolInformation?\nSymbol: fromSymbolInfo\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromSymbolInfo :: SymbolInformation -> SymbolInformation\n\nCandidates:\n  Fields: (none)\n  Inputs: SymbolInformation\n  Output: SymbolInformation\n  References: Interpreter.hs:448, Interpreter.hs:453, Interpreter.hs:454\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Evaluate into GHCi or GHCiError or Evaluate?\nSymbol: Evaluate\nModule: Tidepool.Effect.GHCi\nPackage: tidepool-core\nSignature: Evaluate :: Text %1 -> GHCi (Either GHCiError Text) Evaluate an expression (for pure expressions). Returns the result or error.\n\nCandidates:\n  Fields: (none)\n  Inputs: Evaluate\n  Output: GHCi, GHCiError, Evaluate, Returns\n  References: GHCi.hs:217, GHCi.hs:270, GHCi.hs:319\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Evaluate,GHCi,GHCiError<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming AsHandler into Run?\nSymbol: runGraphFromWithSpans\nModule: Tidepool.Graph.Interpret.Instrumented\nPackage: tidepool-core\nSignature: runGraphFromWithSpans :: forall (name :: Symbol) (graph :: Type -> Type) entryType (targets :: [Type]) exitType (es :: [Effect]) handler. (KnownSymbol name, HasField name (graph (AsHandler es)) handler, CallHandler handler entryType es targets, DispatchGotoTraced graph targets es exitType, Member Observability es) => graph (AsHandler es) -> entryType -> Eff es exitType Run a graph from a named handler with span emission. result <- runGraphFromWithSpans @\"compute\" handlers inputValue\n\nCandidates:\n  Fields: (none)\n  Inputs: AsHandler\n  Output: Run\n  References: Instrumented.hs:45, Instrumented.hs:134, Instrumented.hs:142, Instrumented.hs:153\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform CreateIssue and Repo and Label into GitHub or IssueUrl?\nSymbol: CreateIssue\nModule: Tidepool.Effects.GitHub\nPackage: tidepool-core\nSignature: CreateIssue :: Repo %1 -> Text %1 -> Text %1 -> [Label] %1 -> GitHub IssueUrl\n\nCandidates:\n  Fields: (none)\n  Inputs: CreateIssue, Repo, Label\n  Output: GitHub, IssueUrl\n  References: GitHub.hs:297, GitHub.hs:319, GitHub.hs:347\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>CreateIssue,Repo,GitHub,IssueUrl<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform FilePath into CabalResult or Clean or Useful?\nSymbol: cabalClean\nModule: Tidepool.Effects.Cabal\nPackage: tidepool-core\nSignature: cabalClean :: forall (effs :: [Type -> Type]). Member Cabal effs => FilePath -> Eff effs CabalResult Clean build artifacts. Useful before a fresh build or to reclaim disk space.\n\nCandidates:\n  Fields: (none)\n  Inputs: FilePath\n  Output: CabalResult, Clean, Useful\n  References: Cabal.hs:38, Cabal.hs:202, Cabal.hs:206\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>FilePath,CabalResult,Clean<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform CreateBead and CreateBeadInput into BD?\nSymbol: CreateBead\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: CreateBead :: CreateBeadInput %1 -> BD Text Create a new bead, returns the generated ID.\n\nCandidates:\n  Fields: (none)\n  Inputs: CreateBead, CreateBeadInput\n  Output: BD, Create, ID.\n  References: BD.hs:344, BD.hs:418\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>CreateBead,CreateBeadInput,BD<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform CreateTodoTry into Habitica or HabiticaError or TodoId?\nSymbol: CreateTodoTry\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: CreateTodoTry :: Text %1 -> Habitica (Either HabiticaError TodoId)\n\nCandidates:\n  Fields: (none)\n  Inputs: CreateTodoTry\n  Output: Habitica, HabiticaError, TodoId\n  References: Habitica.hs:77, Habitica.hs:117, Habitica.hs:162\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>CreateTodoTry,Habitica,HabiticaError<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I create context for edge scoring?\nSymbol: mkEdgeContext\nModule: Tidepool.Control.Scout.EdgeTypes\nPackage: tidepool-control-server\nSignature: mkEdgeContext :: Text -> Text -> Text -> Int -> Maybe Text -> EdgeContext\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: EdgeContext\n  References: EdgeTypes.hs:17, EdgeTypes.hs:131, EdgeTypes.hs:138\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>EdgeContext<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Repo into PullRequest?\nSymbol: getPullRequest\nModule: Tidepool.Effects.GitHub\nPackage: tidepool-core\nSignature: getPullRequest :: forall (effs :: [Type -> Type]). Member GitHub effs => Repo -> Int -> Bool -> Eff effs (Maybe PullRequest)\n\nCandidates:\n  Fields: (none)\n  Inputs: Repo\n  Output: PullRequest\n  References: GitHub.hs:27, GitHub.hs:327, GitHub.hs:328\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Repo,PullRequest<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform GetLabels into BD?\nSymbol: GetLabels\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: GetLabels :: Text %1 -> BD [Text] Get labels attached to a bead.\n\nCandidates:\n  Fields: (none)\n  Inputs: GetLabels\n  Output: BD, Get\n  References: BD.hs:331, BD.hs:386\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetLabels,BD<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform TaskType into HabiticaTask?\nSymbol: getTasks\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: getTasks :: forall (effs :: [Type -> Type]). Member Habitica effs => TaskType -> Eff effs [HabiticaTask]\n\nCandidates:\n  Fields: (none)\n  Inputs: TaskType\n  Output: HabiticaTask\n  References: Habitica.hs:13, Habitica.hs:102, Habitica.hs:103\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>TaskType,HabiticaTask<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I evaluate Haskell code in a GHCi session?\nSymbol: evaluate\nModule: Tidepool.Effect.GHCi\nPackage: tidepool-core\nSignature: evaluate :: forall (effs :: [Type -> Type]). (Member GHCi effs, NativeOnly) => Text -> Eff effs (Either GHCiError Text) Evaluate an expression and return the result. evaluate \"1 + 1\" -- Right \"2\"\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GHCiError, Evaluate, Right\n  References: GHCi.hs:75, GHCi.hs:269, GHCi.hs:270\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GHCiError,Evaluate<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if I need to preserve case?\nSymbol: lcFirst\nModule: Tidepool.StructuredOutput.Prefix\nPackage: tidepool-core\nSignature: lcFirst :: String -> String Lowercase the first character of a string. lcFirst `TypeName` = \"typeName\" lcFirst `URL` = \"uRL\" lcFirst \"\" = \"\"\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Lowercase, TypeName, URL\n  References: Prefix.hs:23, Prefix.hs:48, Prefix.hs:61, Prefix.hs:71, Prefix.hs:120, Prefix.hs:121, Prefix.hs:122\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When is Cloudflare format not needed?\nSymbol: ToCfTool\nModule: Tidepool.Tool.Convert\nPackage: tidepool-core\nSignature: $p1ToCfTool :: forall t. ToCfTool t => ToolDef t\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: ToolDef\n  References: Convert.hs:117, Convert.hs:121\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I safely fetch user info with error handling?\nSymbol: getUserTry\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: getUserTry :: forall (effs :: [Type -> Type]). Member Habitica effs => Eff effs (Either HabiticaError UserInfo)\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: HabiticaError, UserInfo\n  References: Habitica.hs:19, Habitica.hs:119, Habitica.hs:120\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>HabiticaError,UserInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming JSONSchema into Value or Aeson or Schema?\nSymbol: schemaToValue\nModule: Tidepool.Schema\nPackage: tidepool-core\nSignature: schemaToValue :: JSONSchema -> Value Convert schema to Aeson Value (JSON Schema draft-07 format) Note: Anthropic API requires additionalProperties: false on all object types\n\nCandidates:\n  Fields: (none)\n  Inputs: JSONSchema\n  Output: Value, Convert, Aeson, JSON, Schema, Note, Anthropic, API\n  References: [many references (23) - hub symbol]\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I get child beads of a parent?\nSymbol: getChildren\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: getChildren :: forall (effs :: [Type -> Type]). Member BD effs => Text -> Eff effs [BeadInfo] Get child beads (beads with this as parent).\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: BeadInfo, Get\n  References: BD.hs:39, BD.hs:389, BD.hs:390\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>BeadInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if I need synchronous subgraph execution?\nSymbol: getPending\nModule: Tidepool.Effect.Subgraph\nPackage: tidepool-core\nSignature: getPending :: forall entry result (effs :: [Type -> Type]). Member (Subgraph entry result) effs => Eff effs [ChildHandle]\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: ChildHandle\n  References: Subgraph.hs:64, Subgraph.hs:96, Subgraph.hs:44, Subgraph.hs:139, Subgraph.hs:143\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform TemplateTreeConfig and DependencyTree into Render?\nSymbol: renderDependencyTree\nModule: Tidepool.Template.DependencyTree\nPackage: tidepool-core\nSignature: renderDependencyTree :: TemplateTreeConfig -> DependencyTree -> Text Render a dependency tree to Mermaid syntax.\n\nCandidates:\n  Fields: (none)\n  Inputs: TemplateTreeConfig, DependencyTree\n  Output: Render, Mermaid\n  References: DependencyTree.hs:103, DependencyTree.hs:106, DependencyTree.hs:107\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>TemplateTreeConfig,DependencyTree,Mermaid<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Value into Value?\nSymbol: parseArriveWithSource\nModule: Tidepool.Actor.Barrier\nPackage: tidepool-actor\nSignature: parseArriveWithSource :: Value -> Either String (Text, Value)\n\nCandidates:\n  Fields: (none)\n  Inputs: Value\n  Output: Value\n  References: Barrier.hs:166, Barrier.hs:198, Barrier.hs:199\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I list valid spawn targets from this node?\nSymbol: GetSpawnTargetNames\nModule: Tidepool.Graph.Validate.ForkBarrier\nPackage: tidepool-core\nSignature: GetSpawnTargetNames\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetSpawnTargetNames\n  References: ForkBarrier.hs:47, ForkBarrier.hs:187, ForkBarrier.hs:188, ForkBarrier.hs:189, ForkBarrier.hs:190, ForkBarrier.hs:190, ForkBarrier.hs:191, ForkBarrier.hs:191\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetSpawnTargetNames<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming GetRecentCommits into Git?\nSymbol: GetRecentCommits\nModule: Tidepool.Effects.Git\nPackage: tidepool-core\nSignature: GetRecentCommits :: Int %1 -> Git [Text] Get recent commit subjects.\n\nCandidates:\n  Fields: (none)\n  Inputs: GetRecentCommits\n  Output: Git, Get\n  References: Git.hs:90, Git.hs:110\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I query user info with explicit error handling?\nSymbol: GetUserTry\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: GetUserTry :: Habitica (Either HabiticaError UserInfo)\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetUserTry, Habitica, HabiticaError, UserInfo\n  References: Habitica.hs:78, Habitica.hs:120, Habitica.hs:165\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetUserTry,Habitica<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Extract and Haskell and This and DETERMINISTIC and LLM and Parses and Handles and Examples and ScoreConfig and ScoreEdgeOutput and Double\" and ScoreConfig and ScoreEdgeOutput into Bar\" or Bar?\nSymbol: extractCandidates\nModule: Tidepool.Control.Scout.Teach.Gemma\nPackage: tidepool-control-server\nSignature: extractCandidates :: Text -> [Text] Extract candidate symbols from a Haskell type signature. This is DETERMINISTIC - no LLM needed. Parses the signature and extracts uppercase identifiers, filtering common types. Handles markdown-formatted hover content by extracting just the code block. Examples: @ extractCandidates \"compositeScore :: ScoreConfig -> ScoreEdgeOutput -> Double\" == [ `ScoreConfig` , `ScoreEdgeOutput` ] extractCandidates \"foo :: Int -> Text -> Maybe Bar\" == [ `Bar` ] -- Int, Text, Maybe filtered out @\n\nCandidates:\n  Fields: (none)\n  Inputs: Extract, Haskell, This, DETERMINISTIC, LLM, Parses, Handles, Examples, ScoreConfig, ScoreEdgeOutput, Double\", ScoreConfig, ScoreEdgeOutput\n  Output: Bar\", Bar\n  References: Export.hs:32, Export.hs:265, Export.hs:406, Export.hs:690, Gemma.hs:35, Gemma.hs:93, Gemma.hs:124, Gemma.hs:125, Teach.hs:59, Teach.hs:234\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform ApiKey into Unwrap or API?\nSymbol: getApiKey\nModule: Tidepool.LLM.Types\nPackage: unknown\nSignature: getApiKey :: ApiKey -> Text Unwrap an API key to get the underlying text.\n\nCandidates:\n  Fields: (none)\n  Inputs: ApiKey\n  Output: Unwrap, API\n  References: Interpreter.hs:72, Interpreter.hs:108, Interpreter.hs:150, Types.hs:41, Types.hs:85, Types.hs:86\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>ApiKey,Unwrap,API<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to Parser and GraphEntryType and AsHandler?\nSymbol: runGraphCLIPure\nModule: Tidepool.Graph.CLI\nPackage: tidepool-core\nSignature: runGraphCLIPure :: forall (graph :: Type -> Type) (entryHandlerName :: Symbol) handler (targets :: [Type]). (Show (GraphExitType graph), ToJSON (GraphExitType graph), Generic (graph AsGraph), FindEntryHandler (GraphEntryType graph) (FieldsWithNamesOf graph) ~ 'Just entryHandlerName, KnownSymbol entryHandlerName, HasField entryHandlerName (graph (AsHandler '[])) handler, CallHandler handler (GraphEntryType graph) '[] targets, DispatchGoto graph targets '[] (GraphExitType graph)) => Text -> Parser (GraphEntryType graph) -> graph (AsHandler '[]) -> IO ()\n\nCandidates:\n  Fields: (none)\n  Inputs: Parser, GraphEntryType, AsHandler\n  Output: (none)\n  References: CLI.hs:75, CLI.hs:513, CLI.hs:528\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Range into Range?\nSymbol: fromRange\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromRange :: Range -> Range\n\nCandidates:\n  Fields: (none)\n  Inputs: Range\n  Output: Range\n  References: Interpreter.hs:295, Interpreter.hs:296, Interpreter.hs:304, Interpreter.hs:312, Interpreter.hs:348, Interpreter.hs:399\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Range<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform GetIssue and Repo into GitHub or Issue?\nSymbol: GetIssue\nModule: Tidepool.Effects.GitHub\nPackage: tidepool-core\nSignature: GetIssue :: Repo %1 -> Int %1 -> Bool %1 -> GitHub (Maybe Issue)\n\nCandidates:\n  Fields: (none)\n  Inputs: GetIssue, Repo\n  Output: GitHub, Issue\n  References: GitHub.hs:300, GitHub.hs:322, GitHub.hs:351\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetIssue,Repo,GitHub,Issue<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming WorkspaceEdit into WorkspaceEdit?\nSymbol: fromWorkspaceEditResult\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromWorkspaceEditResult :: WorkspaceEdit -> WorkspaceEdit\n\nCandidates:\n  Fields: (none)\n  Inputs: WorkspaceEdit\n  Output: WorkspaceEdit\n  References: Interpreter.hs:229, Interpreter.hs:383, Interpreter.hs:384\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming ToolUseId into ToolResultId?\nSymbol: toolUseToResultId\nModule: Tidepool.Anthropic.Types\nPackage: tidepool-core\nSignature: toolUseToResultId :: ToolUseId -> ToolResultId\n\nCandidates:\n  Fields: (none)\n  Inputs: ToolUseId\n  Output: ToolResultId\n  References: Types.hs:22, Types.hs:72, Types.hs:73\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When is Cabal not the right build tool?\nSymbol: CabalBuild\nModule: Tidepool.Effects.Cabal\nPackage: tidepool-core\nSignature: CabalBuild\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: CabalBuild\n  References: Cabal.hs:144, Cabal.hs:182\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to HandlerBuilder and Value?\nSymbol: runGraphAsActors\nModule: Tidepool.Actor.Graph\nPackage: tidepool-actor\nSignature: runGraphAsActors :: forall result. FromJSON result => Map Text HandlerBuilder -> Value -> IO result\n\nCandidates:\n  Fields: (none)\n  Inputs: HandlerBuilder, Value\n  Output: (none)\n  References: Graph.hs:36, Graph.hs:296, Graph.hs:302, Graph.hs:450, Graph.hs:451\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming MemoryStore into Useful?\nSymbol: evalMemoryScoped\nModule: Tidepool.Graph.Memory\nPackage: tidepool-core\nSignature: evalMemoryScoped :: forall s (effs :: [Type -> Type]) a. (ToJSON s, FromJSON s) => Text -> s -> MemoryStore -> Eff (Memory s : effs) a -> Eff effs a Run memory effect with scoped persistence, discarding result store. Useful when you don't need the updated store (e.g., read-only access).\n\nCandidates:\n  Fields: (none)\n  Inputs: MemoryStore\n  Output: Run, Useful\n  References: Memory.hs:92, Memory.hs:459, Memory.hs:466\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform WorktreeSpec and WorktreePath into WorktreeError?\nSymbol: withWorktree\nModule: Tidepool.Effects.Worktree\nPackage: tidepool-core\nSignature: withWorktree :: forall (effs :: [Type -> Type]) a. Member Worktree effs => WorktreeSpec -> (WorktreePath -> Eff effs a) -> Eff effs (Either WorktreeError a)\n\nCandidates:\n  Fields: (none)\n  Inputs: WorktreeSpec, WorktreePath\n  Output: WorktreeError\n  References: Worktree.hs:31, Worktree.hs:79, Worktree.hs:302, Worktree.hs:307\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>WorktreeSpec,WorktreePath,WorktreeError<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if I need OpenAI format instead?\nSymbol: toAnthropicTool\nModule: Tidepool.Tool.Convert\nPackage: tidepool-core\nSignature: toAnthropicTool :: forall t. ToAnthropicTool t => t -> AnthropicTool\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: AnthropicTool\n  References: Convert.hs:88, Convert.hs:90, Convert.hs:91, Convert.hs:139\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to AsHandler?\nSymbol: runGraphFromWithSpans\nModule: Tidepool.Graph.Interpret.Instrumented\nPackage: tidepool-core\nSignature: runGraphFromWithSpans :: forall (name :: Symbol) (graph :: Type -> Type) entryType (targets :: [Type]) exitType (es :: [Type -> Type]) handler. (KnownSymbol name, HasField name (graph (AsHandler es)) handler, CallHandler handler entryType es targets, DispatchGotoTraced graph targets es exitType, Member Observability es) => graph (AsHandler es) -> entryType -> Eff es exitType\n\nCandidates:\n  Fields: (none)\n  Inputs: AsHandler\n  Output: (none)\n  References: Instrumented.hs:45, Instrumented.hs:134, Instrumented.hs:142, Instrumented.hs:153\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming TemplateInfo into Render?\nSymbol: renderTemplateComment\nModule: Tidepool.Graph.Mermaid\nPackage: tidepool-core\nSignature: renderTemplateComment :: Maybe TemplateInfo -> Text Render template comment.\n\nCandidates:\n  Fields: (none)\n  Inputs: TemplateInfo\n  Output: Render\n  References: Mermaid.hs:179, Mermaid.hs:193, Mermaid.hs:194, Mermaid.hs:195\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if I need anonymous Habitica operations?\nSymbol: getUser\nModule: Tidepool.Effects.Habitica\nPackage: tidepool-core\nSignature: getUser :: forall (effs :: [Type -> Type]). Member Habitica effs => Eff effs UserInfo\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: UserInfo\n  References: Habitica.hs:11, Habitica.hs:96, Habitica.hs:97\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform BaseUrl into Unwrap?\nSymbol: getBaseUrl\nModule: Tidepool.LLM.Types\nPackage: unknown\nSignature: getBaseUrl :: BaseUrl -> Text Unwrap a base URL to get the underlying text.\n\nCandidates:\n  Fields: (none)\n  Inputs: BaseUrl\n  Output: Unwrap, URL\n  References: Interpreter.hs:73, Interpreter.hs:104, Interpreter.hs:146, Types.hs:43, Types.hs:95, Types.hs:96\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>BaseUrl,Unwrap<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if I need synchronous subgraph execution?\nSymbol: getPending\nModule: Tidepool.Effect.Subgraph\nPackage: tidepool-core\nSignature: getPending :: forall entry result (effs :: [Type -> Type]). Member (Subgraph entry result) effs => Eff effs [ChildHandle] Get handles to all children that haven't completed yet. Useful for tracking progress or implementing custom collection strategies. Usage requires type application to specify both types: pending <- getPending @Spec @V2Result\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: ChildHandle, Get, Useful, Usage\n  References: Subgraph.hs:64, Subgraph.hs:96, Subgraph.hs:44, Subgraph.hs:139, Subgraph.hs:143\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to LogLevel?\nSymbol: runLog\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: runLog :: forall (effs :: [Type -> Type]) a. LastMember IO effs => LogLevel -> Eff (Log : effs) a -> Eff effs a\n\nCandidates:\n  Fields: (none)\n  Inputs: LogLevel\n  Output: (none)\n  References: Types.hs:94, Types.hs:715, Types.hs:716, MCP.hs:20, MCP.hs:71\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When should I override default tool options?\nSymbol: toolCallOptions\nModule: Tidepool.Effect.Session\nPackage: tidepool-core\nSignature: toolCallOptions :: Options\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Options\n  References: Session.hs:264, Session.hs:267, Session.hs:269, Session.hs:270\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with MermaidConfig and GraphInfo?\nSymbol: toMermaidWithConfig\nModule: Tidepool.Graph.Mermaid\nPackage: tidepool-core\nSignature: toMermaidWithConfig :: MermaidConfig -> GraphInfo -> Text\n\nCandidates:\n  Fields: (none)\n  Inputs: MermaidConfig, GraphInfo\n  Output: (none)\n  References: Mermaid.hs:30, Mermaid.hs:90, Mermaid.hs:136, Mermaid.hs:143, Mermaid.hs:144, Graph.hs:164\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>MermaidConfig,GraphInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming LSPSession and ControlMessage into ControlResponse?\nSymbol: handleMessage\nModule: Tidepool.Control.Handler\nPackage: tidepool-control-server\nSignature: handleMessage :: LSPSession -> ControlMessage -> IO ControlResponse\n\nCandidates:\n  Fields: (none)\n  Inputs: LSPSession, ControlMessage\n  Output: ControlResponse\n  References: Server.hs:29, Server.hs:124, Handler.hs:3, Handler.hs:12, Handler.hs:13\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if I need to preserve camelCase?\nSymbol: camelToSnake\nModule: Tidepool.Graph.MCPReify\nPackage: tidepool-core\nSignature: camelToSnake :: ShowS\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: ShowS\n  References: MCPReify.hs:152, MCPReify.hs:162, MCPReify.hs:163\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When should I pass data through inputs instead of memory?\nSymbol: GetMem\nModule: Tidepool.Actor.Graph\nPackage: tidepool-actor\nSignature: GetMem :: forall s. Memory s s\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetMem, Memory\n  References: Graph.hs:229, Graph.hs:234, Graph.hs:255\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming GetBead into BD or BeadInfo?\nSymbol: GetBead\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: GetBead :: Text %1 -> BD (Maybe BeadInfo) Get full bead info by ID.\n\nCandidates:\n  Fields: (none)\n  Inputs: GetBead\n  Output: BD, BeadInfo, Get, ID.\n  References: BD.hs:322, BD.hs:374\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform GetIssue and Repo into GitHub or Issue?\nSymbol: GetIssue\nModule: Tidepool.Effects.GitHub\nPackage: tidepool-core\nSignature: GetIssue :: Repo %1 -> Int %1 -> Bool %1 -> GitHub (Maybe Issue)\n\nCandidates:\n  Fields: (none)\n  Inputs: GetIssue, Repo\n  Output: GitHub, Issue\n  References: GitHub.hs:300, GitHub.hs:322, GitHub.hs:351\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetIssue,Repo,GitHub,Issue<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to FilePath and LSPSession and Start and LSP and HLS and Spawning and FIXES and Capability?\nSymbol: withLSPSession\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: withLSPSession :: forall a. FilePath -> (LSPSession -> IO a) -> IO a Start an LSP session with HLS and run an action. lsp-test handles: - Spawning HLS process - rootUri configuration (FIXES the empty workspaceFolders bug) - initialize/initialized handshake - Capability negotiation withLSPSession \" *path* to/project\" $ session -> do result <- runLSP session myLSPAction pure result\n\nCandidates:\n  Fields: (none)\n  Inputs: FilePath, LSPSession, Start, LSP, HLS, Spawning, FIXES, Capability\n  Output: (none)\n  References: Server.hs:31, Server.hs:72, Interpreter.hs:9, Interpreter.hs:85, Interpreter.hs:89\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When should I compile instead of interpret?\nSymbol: evaluate\nModule: Tidepool.Effect.GHCi\nPackage: tidepool-core\nSignature: evaluate :: forall (effs :: [Type -> Type]). (Member GHCi effs, NativeOnly) => Text -> Eff effs (Either GHCiError Text) Evaluate an expression and return the result. evaluate \"1 + 1\" -- Right \"2\"\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GHCiError, Evaluate, Right\n  References: GHCi.hs:75, GHCi.hs:269, GHCi.hs:270\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with LSPSession?\nSymbol: getCandidatePackage\nModule: Tidepool.Control.Export\nPackage: tidepool-control-server\nSignature: getCandidatePackage :: LSPSession -> Text -> IO Text\n\nCandidates:\n  Fields: (none)\n  Inputs: LSPSession\n  Output: (none)\n  References: Export.hs:327, Export.hs:328\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>LSPSession<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform BaseUrl into Unwrap?\nSymbol: getBaseUrl\nModule: Tidepool.LLM.Types\nPackage: unknown\nSignature: getBaseUrl :: BaseUrl -> Text Unwrap a base URL to get the underlying text.\n\nCandidates:\n  Fields: (none)\n  Inputs: BaseUrl\n  Output: Unwrap, URL\n  References: Interpreter.hs:73, Interpreter.hs:104, Interpreter.hs:146, Types.hs:43, Types.hs:95, Types.hs:96\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>BaseUrl,Unwrap<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I read the current memory state for this node?\nSymbol: GetMem\nModule: Tidepool.Graph.Memory\nPackage: tidepool-core\nSignature: GetMem :: forall s. Memory s s Get the current memory value.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetMem, Memory, Get\n  References: Memory.hs:121, Memory.hs:135, Memory.hs:206\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetMem,Memory<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with Type and Session and Run and Session and Used and For and IO-based and StartSession and ContinueSession and ForkSession?\nSymbol: runSession\nModule: Tidepool.Effect.Session\nPackage: tidepool-core\nSignature: runSession :: forall (effs :: [Type -> Type]) a. (forall x. Session x -> Eff effs x) -> Eff (Session : effs) a -> Eff effs a Run Session effect with a pure handler. Used for testing or alternative implementations. For IO-based execution, see `runSessionIO` in tidepool-session-interpreter. let mockHandler = \\case StartSession slug _ _ _ _ -> pure mockOutput { soBranch = slug <> \"-abc123\" } ContinueSession _ _ _ _ _ _ _ -> pure mockOutput ForkSession _ _ _ _ childSlug _ _ _ -> pure mockOutput { soBranch = childSlug <> \"-def456\" } result <- runM $ runSession mockHandler myProgram\n\nCandidates:\n  Fields: (none)\n  Inputs: Type, Session, Run, Session, Used, For, IO-based, StartSession, ContinueSession, ForkSession\n  Output: (none)\n  References: Session.hs:68, Session.hs:489, Session.hs:493\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Type,Session<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I check for pending child subgraph results?\nSymbol: getPending\nModule: Tidepool.Effect.Subgraph\nPackage: tidepool-core\nSignature: getPending :: forall entry result (effs :: [Type -> Type]). Member (Subgraph entry result) effs => Eff effs [ChildHandle]\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: ChildHandle\n  References: Subgraph.hs:64, Subgraph.hs:96, Subgraph.hs:44, Subgraph.hs:139, Subgraph.hs:143\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>ChildHandle<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I find beads that block a given bead?\nSymbol: getBlocking\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: getBlocking :: forall (effs :: [Type -> Type]). Member BD effs => Text -> Eff effs [BeadInfo] Get blocking beads (beads this one is blocking).\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: BeadInfo, Get\n  References: BD.hs:37, BD.hs:381, BD.hs:382\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>BeadInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Repo into Issue?\nSymbol: getIssue\nModule: Tidepool.Effects.GitHub\nPackage: tidepool-core\nSignature: getIssue :: forall (effs :: [Type -> Type]). Member GitHub effs => Repo -> Int -> Bool -> Eff effs (Maybe Issue)\n\nCandidates:\n  Fields: (none)\n  Inputs: Repo\n  Output: Issue\n  References: GitHub.hs:25, GitHub.hs:321, GitHub.hs:322\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Repo,Issue<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming AsHandler into Run?\nSymbol: runGraphFrom\nModule: Tidepool.Graph.Interpret\nPackage: tidepool-core\nSignature: runGraphFrom :: forall (name :: Symbol) (graph :: Type -> Type) entryType (targets :: [Type]) exitType (es :: [Effect]) handler. (KnownSymbol name, HasField name (graph (AsHandler es)) handler, CallHandler handler entryType es targets, DispatchGoto graph targets es exitType) => graph (AsHandler es) -> entryType -> Eff es exitType Run a graph starting from a named handler. Use this when you want to explicitly specify which handler to start from, bypassing automatic entry handler discovery. result <- runGraphFrom @\"compute\" handlers inputValue\n\nCandidates:\n  Fields: (none)\n  Inputs: AsHandler\n  Output: Run, Use\n  References: Interpret.hs:32, Interpret.hs:153, Interpret.hs:163, Interpret.hs:198, Interpret.hs:203\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I create a message queue for concurrent actor communication?\nSymbol: newMailboxIO\nModule: Tidepool.Actor.Mailbox\nPackage: tidepool-actor\nSignature: newMailboxIO :: forall msg. IO (Mailbox msg)\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Mailbox\n  References: Mailbox.hs:9, Mailbox.hs:30, Mailbox.hs:31, Spawn.hs:23, Spawn.hs:45\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Mailbox<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform ParseDiagnostic into ParseDiagnostic or Prepend?\nSymbol: prependPath\nModule: Tidepool.StructuredOutput.Generic\nPackage: tidepool-core\nSignature: prependPath :: [Text] -> ParseDiagnostic -> ParseDiagnostic Prepend path to a diagnostic's existing path.\n\nCandidates:\n  Fields: (none)\n  Inputs: ParseDiagnostic\n  Output: ParseDiagnostic, Prepend\n  References: Generic.hs:148, Generic.hs:182, Generic.hs:220, Generic.hs:221\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>ParseDiagnostic,Prepend<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Type into GraphContext?\nSymbol: runGraphContext\nModule: Tidepool.Effect.GraphContext\nPackage: tidepool-core\nSignature: runGraphContext :: forall entry (effs :: [Type -> Type]) a. entry -> Eff (GraphContext entry : effs) a -> Eff effs a Run GraphContext effect with a fixed entry value. Typically provided by the graph runner when spawning a graph. For recursive execution, each child graph gets its own entry. -- In graph runner runGraphContext scaffoldInput $ do ... -- all handlers can now call getEntry\n\nCandidates:\n  Fields: (none)\n  Inputs: Type\n  Output: Run, GraphContext, Typically, For, In\n  References: GraphContext.hs:59, GraphContext.hs:182, GraphContext.hs:186\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When should I avoid subprocess execution?\nSymbol: RuntimeClaudeCode\nModule: Tidepool.Graph.Reify\nPackage: tidepool-core\nSignature: RuntimeClaudeCode :: RuntimeNodeKind Claude Code subprocess\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: RuntimeClaudeCode, RuntimeNodeKind, Claude, Code\n  References: Reify.hs:198, Reify.hs:761, Mermaid.hs:187, Mermaid.hs:246, Mermaid.hs:254, Mermaid.hs:415, Export.hs:281\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When should I use a different tool format?\nSymbol: ToAnthropicTool\nModule: Tidepool.Tool.Convert\nPackage: tidepool-core\nSignature: $p1ToAnthropicTool :: forall t. ToAnthropicTool t => ToolDef t\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: ToolDef\n  References: Convert.hs:87, Convert.hs:91\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming LSPSession and Value into ControlResponse?\nSymbol: handleTeachTool\nModule: Tidepool.Control.Handler.MCP\nPackage: tidepool-control-server\nSignature: handleTeachTool :: LSPSession -> Text -> Value -> IO ControlResponse\n\nCandidates:\n  Fields: (none)\n  Inputs: LSPSession, Value\n  Output: ControlResponse\n  References: MCP.hs:33, MCP.hs:45, MCP.hs:46\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to WorktreeSpec and WorktreeError and WorktreePath and Create and WorktreeSpec and Nothing and Right and Left?\nSymbol: createWorktree\nModule: Tidepool.Effects.Worktree\nPackage: tidepool-core\nSignature: createWorktree :: forall (effs :: [Type -> Type]). Member Worktree effs => WorktreeSpec -> Eff effs (Either WorktreeError WorktreePath) Create a new worktree. result <- createWorktree (WorktreeSpec \"my-feature\" Nothing) case result of Right path -> -- path is like \" *repo* .worktrees/my-feature-abc123\" Left err -> handleError err\n\nCandidates:\n  Fields: (none)\n  Inputs: WorktreeSpec, WorktreeError, WorktreePath, Create, WorktreeSpec, Nothing, Right, Left\n  Output: (none)\n  References: Worktree.hs:72, Worktree.hs:228, Worktree.hs:232, Worktree.hs:297, Worktree.hs:308\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform GetLabels into BD?\nSymbol: GetLabels\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: GetLabels :: Text %1 -> BD [Text] Get labels attached to a bead.\n\nCandidates:\n  Fields: (none)\n  Inputs: GetLabels\n  Output: BD, Get\n  References: BD.hs:331, BD.hs:386\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetLabels,BD<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to TemplateDependency?\nSymbol: renderDepTree\nModule: Tidepool.Graph.Docs\nPackage: tidepool-core\nSignature: renderDepTree :: TemplateDependency -> Text\n\nCandidates:\n  Fields: (none)\n  Inputs: TemplateDependency\n  Output: (none)\n  References: Docs.hs:36, Docs.hs:70, Docs.hs:71, Docs.hs:145, Graph.hs:124\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform GotoAll into Value?\nSymbol: extractTargets\nModule: Tidepool.Actor.Dispatch\nPackage: tidepool-actor\nSignature: extractTargets :: forall (targets :: [Type]). SpawnWorkers targets => GotoAll targets -> [(Text, Value)] Extract (targetName, jsonPayload) pairs from a GotoAll.\n\nCandidates:\n  Fields: (none)\n  Inputs: GotoAll\n  Output: Value, Extract, GotoAll.\n  References: Dispatch.hs:129, Dispatch.hs:133, Dispatch.hs:141, Dispatch.hs:144\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GotoAll,Value,Extract<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if deploying outside Cloudflare?\nSymbol: toCfTool\nModule: Tidepool.Tool.Convert\nPackage: tidepool-core\nSignature: toCfTool :: forall t. ToCfTool t => t -> CfTool\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: CfTool\n  References: Convert.hs:118, Convert.hs:120, Convert.hs:121, Convert.hs:149\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When is the standard format not suitable?\nSymbol: formatSelectSymbolsExample\nModule: Tidepool.Training.Format\nPackage: tidepool-training-generator\nSignature: formatSelectSymbolsExample :: Text -> Text -> Text -> Text -> Maybe Text -> [Text] -> ByteString Format complete training example as JSONL line. Lean format: Module + Package + cleaned signature + first-sentence docs.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Format, JSONL, Lean, Module, Package\n  References: Format.hs:4, Format.hs:83, Format.hs:91, Export.hs:39, Export.hs:410, Export.hs:694\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming GetUsesEffectsFixed and Type into Effect or UsesEffects?\nSymbol: GetUsesEffectsFixed\nModule: Tidepool.Graph.Validate.ForkBarrier\nPackage: tidepool-core\nSignature: GetUsesEffectsFixed :: Type -> Maybe [Effect] Get UsesEffects with fixed kind.\n\nCandidates:\n  Fields: (none)\n  Inputs: GetUsesEffectsFixed, Type\n  Output: Effect, Get, UsesEffects\n  References: ForkBarrier.hs:223, ForkBarrier.hs:339, ForkBarrier.hs:340, ForkBarrier.hs:341, ForkBarrier.hs:342, ForkBarrier.hs:342, ForkBarrier.hs:343\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with Type and DevLog?\nSymbol: runDevLogPure\nModule: Tidepool.Effect.DevLog\nPackage: tidepool-core\nSignature: runDevLogPure :: forall (effs :: [Type -> Type]) a. Eff (DevLog : effs) a -> Eff effs a\n\nCandidates:\n  Fields: (none)\n  Inputs: Type, DevLog\n  Output: (none)\n  References: DevLog.hs:58, DevLog.hs:209, DevLog.hs:210\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Type,DevLog<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I access past messages in a chat context?\nSymbol: GetHistory\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: GetHistory :: ChatHistory [Message]\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetHistory, ChatHistory, Message\n  References: Types.hs:512, Types.hs:517, Types.hs:532\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetHistory,ChatHistory<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I get metadata for all registered effects?\nSymbol: allEffectMeta\nModule: Tidepool.Effect.Metadata\nPackage: tidepool-core\nSignature: allEffectMeta :: [EffectMeta]\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: EffectMeta\n  References: Metadata.hs:15, Metadata.hs:25, Metadata.hs:93, Metadata.hs:94\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>EffectMeta<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with InputHandler?\nSymbol: runRequestInput\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: runRequestInput :: forall (effs :: [Type -> Type]) a. LastMember IO effs => InputHandler -> Eff (RequestInput : effs) a -> Eff effs a\n\nCandidates:\n  Fields: (none)\n  Inputs: InputHandler\n  Output: (none)\n  References: Types.hs:96, Types.hs:629, Types.hs:630\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>InputHandler<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming EdgeType into InstanceSite?\nSymbol: extractConstraints\nModule: Tidepool.Control.Scout.EdgeTypes\nPackage: tidepool-control-server\nSignature: extractConstraints :: EdgeType -> Text -> Maybe [Text] Extract constraints from hover for InstanceSite edges.\n\nCandidates:\n  Fields: (none)\n  Inputs: EdgeType\n  Output: Extract, InstanceSite\n  References: EdgeTypes.hs:151, EdgeTypes.hs:182, EdgeTypes.hs:183, EdgeTypes.hs:187\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I access the entry value passed to this graph?\nSymbol: GetEntry\nModule: Tidepool.Effect.GraphContext\nPackage: tidepool-core\nSignature: GetEntry :: forall {k} (entry :: k). GraphContext entry entry Get the entry value that spawned this graph.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetEntry, GraphContext, Get\n  References: GraphContext.hs:87, GraphContext.hs:105, GraphContext.hs:187\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetEntry,GraphContext<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming Hover into HoverInfo?\nSymbol: fromHoverResult\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromHoverResult :: Maybe Hover -> Maybe HoverInfo\n\nCandidates:\n  Fields: (none)\n  Inputs: Hover\n  Output: HoverInfo\n  References: Interpreter.hs:192, Interpreter.hs:308, Interpreter.hs:309, Interpreter.hs:310\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with M1?\nSymbol: conName'\nModule: Tidepool.StructuredOutput.Generic\nPackage: tidepool-core\nSignature: conName' :: forall {k} (c :: Meta) (f :: k -> Type) (p :: k). Constructor c => M1 C c f p -> String\n\nCandidates:\n  Fields: (none)\n  Inputs: M1\n  Output: (none)\n  References: Generic.hs:259, Generic.hs:271, Generic.hs:280, Generic.hs:291, Generic.hs:292\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>M1<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When are blocking relationships not needed?\nSymbol: getBlocking\nModule: Tidepool.Effects.BD\nPackage: tidepool-core\nSignature: getBlocking :: forall (effs :: [Type -> Type]). Member BD effs => Text -> Eff effs [BeadInfo] Get blocking beads (beads this one is blocking).\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: BeadInfo, Get\n  References: BD.hs:37, BD.hs:381, BD.hs:382\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming CreateIssue and Repo and Label into GitHub or IssueUrl?\nSymbol: CreateIssue\nModule: Tidepool.Effects.GitHub\nPackage: tidepool-core\nSignature: CreateIssue :: Repo %1 -> Text %1 -> Text %1 -> [Label] %1 -> GitHub IssueUrl\n\nCandidates:\n  Fields: (none)\n  Inputs: CreateIssue, Repo, Label\n  Output: GitHub, IssueUrl\n  References: GitHub.hs:297, GitHub.hs:319, GitHub.hs:347\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform WorkspaceSymbol into SymbolInformation?\nSymbol: fromWorkspaceSymbol\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromWorkspaceSymbol :: WorkspaceSymbol -> SymbolInformation\n\nCandidates:\n  Fields: (none)\n  Inputs: WorkspaceSymbol\n  Output: SymbolInformation\n  References: Interpreter.hs:450, Interpreter.hs:461, Interpreter.hs:462\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>WorkspaceSymbol,SymbolInformation<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When should I use relative time instead of absolute?\nSymbol: getCurrentTime\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: getCurrentTime :: forall (effs :: [Type -> Type]). Member Time effs => Eff effs UTCTime\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: UTCTime\n  References: Types.hs:29, Types.hs:198, Types.hs:199\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming ParseDiagnostic into ParseDiagnostic or Prepend?\nSymbol: prependPath\nModule: Tidepool.StructuredOutput.Generic\nPackage: tidepool-core\nSignature: prependPath :: [Text] -> ParseDiagnostic -> ParseDiagnostic Prepend path to a diagnostic's existing path.\n\nCandidates:\n  Fields: (none)\n  Inputs: ParseDiagnostic\n  Output: ParseDiagnostic, Prepend\n  References: Generic.hs:148, Generic.hs:182, Generic.hs:220, Generic.hs:221\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform IORef into Memory or Each or IORef?\nSymbol: runMemoryWithIORef\nModule: Tidepool.Actor.Graph\nPackage: tidepool-actor\nSignature: runMemoryWithIORef :: forall s (effs :: [Type -> Type]) a. LastMember IO effs => IORef s -> Eff (Memory s : effs) a -> Eff effs a Run the Memory effect using an IORef. Each actor should have its own IORef, providing isolated persistent state. memRef <- newIORef initialState let interpreter = runM . runMemoryWithIORef memRef . runOtherEffects\n\nCandidates:\n  Fields: (none)\n  Inputs: IORef\n  Output: Run, Memory, IORef., Each, IORef\n  References: Graph.hs:59, Graph.hs:248, Graph.hs:254, Graph.hs:423\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>IORef,Memory<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What if templates don't use extends?\nSymbol: parseTemplateExtends\nModule: Tidepool.Template.DependencyTree\nPackage: tidepool-core\nSignature: parseTemplateExtends :: Text -> [FilePath] Parse a template for {% extends \"...\" %} directives. Returns a list of extended template paths.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: FilePath, Parse, Returns\n  References: DependencyTree.hs:33, DependencyTree.hs:218, DependencyTree.hs:219, DependencyTree.hs:229\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming ApiKey into Unwrap or API?\nSymbol: getApiKey\nModule: Tidepool.LLM.Types\nPackage: unknown\nSignature: getApiKey :: ApiKey -> Text Unwrap an API key to get the underlying text.\n\nCandidates:\n  Fields: (none)\n  Inputs: ApiKey\n  Output: Unwrap, API\n  References: Interpreter.hs:72, Interpreter.hs:108, Interpreter.hs:150, Types.hs:41, Types.hs:85, Types.hs:86\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming MermaidConfig and NodeInfo into Render?\nSymbol: renderNode\nModule: Tidepool.Graph.Mermaid\nPackage: tidepool-core\nSignature: renderNode :: MermaidConfig -> NodeInfo -> Text Render a single node declaration.\n\nCandidates:\n  Fields: (none)\n  Inputs: MermaidConfig, NodeInfo\n  Output: Render\n  References: Mermaid.hs:171, Mermaid.hs:237, Mermaid.hs:238\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Value into Describe?\nSymbol: describeValue\nModule: Tidepool.StructuredOutput.Error\nPackage: tidepool-core\nSignature: describeValue :: Value -> Text Describe a JSON value for error messages. Truncates long strings and summarizes structures.\n\nCandidates:\n  Fields: (none)\n  Inputs: Value\n  Output: Describe, JSON, Truncates\n  References: Error.hs:23, Error.hs:44, Error.hs:45, Error.hs:53, Error.hs:54, Error.hs:62, Error.hs:63, Error.hs:71, Error.hs:72, Error.hs:80, Error.hs:81, Error.hs:104, Error.hs:105, Error.hs:126, Error.hs:127\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Value<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform TypedTemplate and SourcePos and TypedTemplate and SourcePos and GotoChoice into GotoChoice or LLMBoth or LLM?\nSymbol: executeLLMHandler\nModule: Tidepool.Graph.Interpret\nPackage: tidepool-core\nSignature: executeLLMHandler :: forall needs schema (targets :: [Type]) (es :: [Type -> Type]) tpl. (Member LLM es, StructuredOutput schema, ValidStructuredOutput schema, GingerContext tpl, ConvertTransitionHint targets) => Maybe (TypedTemplate tpl SourcePos) -> TypedTemplate tpl SourcePos -> (needs -> Eff es tpl) -> (schema -> Eff es (GotoChoice targets)) -> needs -> Eff es (GotoChoice targets) Execute an LLMBoth handler, returning a GotoChoice. This function: 1. Calls the before-handler to build template context 2. Renders the system template (if provided) and user template 3. Calls the LLM effect with rendered prompts and JSON schema 4. Parses the structured output 5. Calls the after-handler to determine the next transition # Type Parameters + `needs` - The input type from Needs annotation + `schema` - The LLM output schema type + `targets` - The transition targets from UsesEffects + `es` - The effect stack (must include LLM) + `tpl` - The template context type # Example result <- executeLLMHandler Nothing -- no system template userTemplate -- user prompt template (\\input -> pure MyContext {...}) -- build context (\\output -> pure (gotoExit output)) -- route based on output inputValue\n\nCandidates:\n  Fields: (none)\n  Inputs: TypedTemplate, SourcePos, TypedTemplate, SourcePos, GotoChoice\n  Output: GotoChoice, Execute, LLMBoth, GotoChoice., This, Calls, Renders, LLM, JSON, Parses, Type, Parameters, The, Needs, UsesEffects, Example, Nothing, MyContext\n  References: Interpret.hs:39, Interpret.hs:259, Interpret.hs:273, Interpret.hs:298, Interpret.hs:535, Instrumented.hs:55\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>TypedTemplate,SourcePos,GotoChoice<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming GetIssue and Repo into GitHub or Issue?\nSymbol: GetIssue\nModule: Tidepool.Effects.GitHub\nPackage: tidepool-core\nSignature: GetIssue :: Repo %1 -> Int %1 -> Bool %1 -> GitHub (Maybe Issue)\n\nCandidates:\n  Fields: (none)\n  Inputs: GetIssue, Repo\n  Output: GitHub, Issue\n  References: GitHub.hs:300, GitHub.hs:322, GitHub.hs:351\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming ContentBlock and Value and Value into TurnOutcome or TurnParseResult?\nSymbol: runTurnContent\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: runTurnContent :: forall output (effs :: [Type -> Type]). (Member LLM effs, StructuredOutput output, ValidStructuredOutput output) => Text -> [ContentBlock] -> Value -> [Value] -> Eff effs (TurnOutcome (TurnParseResult output))\n\nCandidates:\n  Fields: (none)\n  Inputs: ContentBlock, Value, Value\n  Output: TurnOutcome, TurnParseResult\n  References: Types.hs:54, Types.hs:389, Types.hs:391, Types.hs:396\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with Value and Scope and Router and ActorId and Actor?\nSymbol: withActorSystem\nModule: Tidepool.Actor.Runtime\nPackage: tidepool-actor\nSignature: withActorSystem :: forall result. FromJSON result => Value -> (Scope -> Router -> IO (Map ActorId Actor)) -> IO result\n\nCandidates:\n  Fields: (none)\n  Inputs: Value, Scope, Router, ActorId, Actor\n  Output: (none)\n  References: Runtime.hs:6, Runtime.hs:50, Runtime.hs:57\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Value,Scope<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What can I do with MermaidConfig and GraphInfo?\nSymbol: toStateDiagramWithConfig\nModule: Tidepool.Graph.Mermaid\nPackage: tidepool-core\nSignature: toStateDiagramWithConfig :: MermaidConfig -> GraphInfo -> Text\n\nCandidates:\n  Fields: (none)\n  Inputs: MermaidConfig, GraphInfo\n  Output: (none)\n  References: Mermaid.hs:36, Mermaid.hs:388, Mermaid.hs:391, Mermaid.hs:392\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>MermaidConfig,GraphInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I convert a SchemaType into a JSONSchema for runtime validation?\nSymbol: emptySchema\nModule: Tidepool.Schema\nPackage: tidepool-core\nSignature: emptySchema :: SchemaType -> JSONSchema\n\nCandidates:\n  Fields: (none)\n  Inputs: SchemaType\n  Output: JSONSchema\n  References: [many references (36) - hub symbol]\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>SchemaType,JSONSchema<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When should I skip observability tracing?\nSymbol: withGraphSpan\nModule: Tidepool.Graph.Interpret.Instrumented\nPackage: tidepool-core\nSignature: withGraphSpan :: forall (es :: [Type -> Type]) a. Member Observability es => Text -> Eff es a -> Eff es a Wrap a graph execution with a root span. Creates a server span that contains all node spans as children. Use this when you want explicit control over the root span name. result <- withGraphSpan \"my-agent:handle-request\" $ do runGraphWithSpans handlers input\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Wrap, Creates, Use\n  References: Instrumented.hs:46, Instrumented.hs:244, Instrumented.hs:249\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What is unrelated to IORef and Message?\nSymbol: runChatHistoryWith\nModule: Tidepool.Effect.Types\nPackage: tidepool-core\nSignature: runChatHistoryWith :: forall (effs :: [Type -> Type]) a. LastMember IO effs => IORef [Message] -> Eff (ChatHistory : effs) a -> Eff effs a\n\nCandidates:\n  Fields: (none)\n  Inputs: IORef, Message\n  Output: (none)\n  References: Types.hs:528, Types.hs:530, Types.hs:531\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform MemoryStore into Useful?\nSymbol: evalMemoryScoped\nModule: Tidepool.Graph.Memory\nPackage: tidepool-core\nSignature: evalMemoryScoped :: forall s (effs :: [Type -> Type]) a. (ToJSON s, FromJSON s) => Text -> s -> MemoryStore -> Eff (Memory s : effs) a -> Eff effs a Run memory effect with scoped persistence, discarding result store. Useful when you don't need the updated store (e.g., read-only access).\n\nCandidates:\n  Fields: (none)\n  Inputs: MemoryStore\n  Output: Run, Useful\n  References: Memory.hs:92, Memory.hs:459, Memory.hs:466\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>MemoryStore,Useful<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: When should I avoid querying repo state?\nSymbol: GetWorktreeInfo\nModule: Tidepool.Effects.Git\nPackage: tidepool-core\nSignature: GetWorktreeInfo :: Git (Maybe WorktreeInfo) Get worktree/repo information. Returns Nothing if not in a git repository.\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: GetWorktreeInfo, Git, WorktreeInfo, Get, Returns, Nothing\n  References: Git.hs:84, Git.hs:102\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming LocationLink into Location?\nSymbol: fromLocationLink\nModule: Tidepool.LSP.Interpreter\nPackage: tidepool-lsp-interpreter\nSignature: fromLocationLink :: LocationLink -> Location\n\nCandidates:\n  Fields: (none)\n  Inputs: LocationLink\n  Output: Location\n  References: Interpreter.hs:343, Interpreter.hs:345, Interpreter.hs:346\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform GetUsesEffectsFixed and Type into Effect or UsesEffects?\nSymbol: GetUsesEffectsFixed\nModule: Tidepool.Graph.Validate.RecordStructure\nPackage: tidepool-core\nSignature: GetUsesEffectsFixed :: Type -> Maybe [Effect] Get UsesEffects with fixed kind.\n\nCandidates:\n  Fields: (none)\n  Inputs: GetUsesEffectsFixed, Type\n  Output: Effect, Get, UsesEffects\n  References: RecordStructure.hs:318, RecordStructure.hs:321, RecordStructure.hs:322, RecordStructure.hs:323, RecordStructure.hs:324, RecordStructure.hs:324, RecordStructure.hs:325, RecordStructure.hs:363, RecordStructure.hs:426, RecordStructure.hs:571, RecordStructure.hs:630, RecordStructure.hs:646\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>GetUsesEffectsFixed,Type,Effect<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Repo and Label into IssueUrl?\nSymbol: createIssue\nModule: Tidepool.Effects.GitHub\nPackage: tidepool-core\nSignature: createIssue :: forall (effs :: [Type -> Type]). Member GitHub effs => Repo -> Text -> Text -> [Label] -> Eff effs IssueUrl\n\nCandidates:\n  Fields: (none)\n  Inputs: Repo, Label\n  Output: IssueUrl\n  References: GitHub.hs:24, GitHub.hs:318, GitHub.hs:319\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Repo,Label,IssueUrl<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I use if I want to avoid concurrent message handling?\nSymbol: newMailboxIO\nModule: Tidepool.Actor.Mailbox\nPackage: tidepool-actor\nSignature: newMailboxIO :: forall msg. IO (Mailbox msg)\n\nCandidates:\n  Fields: (none)\n  Inputs: (none)\n  Output: Mailbox\n  References: Mailbox.hs:9, Mailbox.hs:30, Mailbox.hs:31, Spawn.hs:23, Spawn.hs:45\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform EdgeType into InstanceSite?\nSymbol: extractConstraints\nModule: Tidepool.Control.Scout.EdgeTypes\nPackage: tidepool-control-server\nSignature: extractConstraints :: EdgeType -> Text -> Maybe [Text] Extract constraints from hover for InstanceSite edges.\n\nCandidates:\n  Fields: (none)\n  Inputs: EdgeType\n  Output: Extract, InstanceSite\n  References: EdgeTypes.hs:151, EdgeTypes.hs:182, EdgeTypes.hs:183, EdgeTypes.hs:187\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>EdgeType,Extract,InstanceSite<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform EffectCategory into EffectCategory?\nSymbol: categoryToText\nModule: Tidepool.Effect.Metadata\nPackage: tidepool-core\nSignature: categoryToText :: EffectCategory -> Text Convert EffectCategory to Text for codegen.\n\nCandidates:\n  Fields: (none)\n  Inputs: EffectCategory\n  Output: Convert, EffectCategory\n  References: Metadata.hs:28, Metadata.hs:109, Metadata.hs:110, Metadata.hs:111\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>EffectCategory<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform ToolInfo into Value?\nSymbol: toolInfoToJSON\nModule: Tidepool.Graph.Tool\nPackage: tidepool-core\nSignature: toolInfoToJSON :: ToolInfo -> Value\n\nCandidates:\n  Fields: (none)\n  Inputs: ToolInfo\n  Output: Value\n  References: Tool.hs:72, Tool.hs:231, Tool.hs:232, Graph.hs:207\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>ToolInfo,Value<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: What should I avoid transforming EdgeContext into ScoringContext?\nSymbol: mkScoringContext\nModule: Tidepool.Control.Scout.Templates\nPackage: tidepool-control-server\nSignature: mkScoringContext :: Text -> EdgeContext -> ScoringContext\n\nCandidates:\n  Fields: (none)\n  Inputs: EdgeContext\n  Output: ScoringContext\n  References: Templates.hs:15, Templates.hs:58, Templates.hs:59\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape><escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform Value into Value?\nSymbol: parseArriveWithSource\nModule: Tidepool.Actor.Barrier\nPackage: tidepool-actor\nSignature: parseArriveWithSource :: Value -> Either String (Text, Value)\n\nCandidates:\n  Fields: (none)\n  Inputs: Value\n  Output: Value\n  References: Barrier.hs:166, Barrier.hs:198, Barrier.hs:199\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>Value<escape>}\n<end_function_call>\n<end_of_turn>\n"}
{"text": "<start_of_turn>developer\nYou are an expert function calling AI assistant.\nYou have access to the following functions:\n\n<start_function_declaration>select_symbols\nSelect relevant symbols from candidates that help understand the topic in context of the current symbol.\nParameters:\n  selected (array): Array of selected symbol names from the candidate list. (required)\n<end_function_declaration>\n\n<end_of_turn>\n<start_of_turn>user\nTopic: How do I transform MermaidConfig and NodeInfo into Render?\nSymbol: renderState\nModule: Tidepool.Graph.Mermaid\nPackage: tidepool-core\nSignature: renderState :: MermaidConfig -> NodeInfo -> Text Render a state definition.\n\nCandidates:\n  Fields: (none)\n  Inputs: MermaidConfig, NodeInfo\n  Output: Render\n  References: Mermaid.hs:404, Mermaid.hs:407, Mermaid.hs:408\n<end_of_turn>\n<start_of_turn>model\n<start_function_call>\ncall:select_symbols{selected:<escape>MermaidConfig,NodeInfo<escape>}\n<end_function_call>\n<end_of_turn>\n"}
